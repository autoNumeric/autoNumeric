(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-12-01 UTC 21:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     */\n    aSep: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     */\n    nSep: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * dGroup: \"3\", results in 999,999,999 default\n     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n     */\n    dGroup: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     */\n    aDec: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     */\n    altDec: null,\n\n    /* aSign = allowed currency symbol\n     * Must be in quotes aSign: \"$\"\n     * space to the right of the currency symbol aSign: '$ '\n     * space to the left of the currency symbol aSign: ' $'\n     */\n    aSign: '',\n\n    /* pSign = placement of currency sign as a p=prefix or s=suffix\n     * for prefix pSign: \"p\" (default)\n     * for suffix pSign: \"s\"\n     */\n    pSign: 'p',\n\n    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {aSign: \"$\"}\n     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n     * 1,234.56-  => {pNeg: \"s\"}\n     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n     */\n    pNeg: 'l',\n\n    /* Additional suffix\n     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     */\n    aSuffix: '',\n\n    /* Override min max limits\n     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n     * oLimits: \"ignore\" ignores both vMin & vMax\n     */\n    oLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than vMin\n     */\n    vMax: '9999999999999.99',\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than vMax\n     */\n    vMin: '-9999999999999.99',\n\n    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n     * value must be enclosed in quotes example mDec: \"3\",\n     */\n    mDec: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     */\n    eDec: null,\n\n    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     */\n    scaleDecimal: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the eDec value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     */\n    aStor: false,\n\n    /* method used for rounding\n     * mRound: \"S\", Round-Half-Up Symmetric (default)\n     * mRound: \"A\", Round-Half-Up Asymmetric\n     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * mRound: \"U05\" Rounds up to next .05\n     * mRound: \"D05\" Rounds down to next .05\n     */\n    mRound: 'S',\n\n    /* Controls decimal padding\n     * aPad: true - always Pad decimals with zeros\n     * aPad: false - does not pad with zeros.\n     * Note: setting aPad to 'false' will override the 'mDec' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     */\n    aPad: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * nBracket: null - (default)\n     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n     */\n    nBracket: null,\n\n    /* Displayed on empty string \"\"\n     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n     * wEmpty: \"press\" - currency sign displays on any key being pressed\n     * wEmpty: \"always\" - always displays the currency sign only\n     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     */\n    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n    wEmpty: 'focus',\n\n    /* Controls leading zero behavior\n     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * lZero: \"deny\", - allows only one leading zero on values less than one\n     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     */\n    lZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value\n     */\n    aForm: true,\n\n    /* Determine if the select all keyboard command will select\n     * the complete input text or only the input numeric value\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n     */\n    sNumber: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {anDefault: \"\"}\n     * value=1234.56 {anDefault: '1234.56'}\n     */\n    anDefault: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     */\n    unSetOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     */\n    outputType: null,\n\n    /* Error handling function\n     * true => all errors are thrown - helpful in site development\n     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n     */\n    debug: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the text given as a parameter is valid.\n     *\n     * @param text\n     * @returns {boolean}\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param text\n     * @param holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     * Return `null` otherwise.\n     *\n     * @param {string} str\n     * @returns {null|int}\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} suppressWarnings If TRUE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        //TODO Merge `autoCode()` into `getInitialSettings()`\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Places or removes brackets on negative values\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputType\" option definition for more details.\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputType [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Prepare number string to be converted to real number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function fixNumber(s, settings) {\n        if (settings.aDec !== '.') {\n            s = s.replace(settings.aDec, '.');\n        }\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace(settings.aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Prepare real number to be converted to our format\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg !== '-' && settings.aNeg !== '') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? inputValue + settings.aSign + settings.aSuffix : settings.aSign + inputValue + settings.aSuffix;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Private function that formats our number\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoGroup(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = autoStrip(inputValue, settings);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNeg = contains(inputValue, '-');\n        if (isNeg) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (empty !== null) {\n            return empty;\n        }\n\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.aDec),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.altDec);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            inputValue = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            inputValue = integerPart;\n        }\n\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = settings.aNeg + settings.aSign + inputValue;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = settings.aSign + settings.aNeg + inputValue;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                inputValue = settings.aSign + inputValue + settings.aNeg;\n            }\n            if (!isNeg) {\n                inputValue = settings.aSign + inputValue;\n            }\n        }\n\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = inputValue + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = inputValue + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                inputValue = settings.aNeg + inputValue + settings.aSign;\n            }\n            if (!isNeg) {\n                inputValue = inputValue + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = negativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param rDec\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the mDec length when aPad is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (rDec === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoRound(inputValue, settings) {\n        // value to string\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.lZero !== 'keep' || inputValue.length > 0 && settings.lZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {string} paste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(obj)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            obj = '#' + obj.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * Function to attach data to the element and imitate the holder\n     *\n     * @param $that\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getHolder($that, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when eDec & nSep options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     *\n     * @param that\n     * @param {object} settings\n     * @constructor\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '';\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = e.type === 'keydown';\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusInAndMouseEnter($this, holder) {\n        $this.on('focusin.autoNumeric mouseenter.autoNumeric', function (e) {\n            holder = getHolder($this);\n            var $settings = holder.settingsClone;\n            if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && $settings.wEmpty === 'focus') {\n                $settings.onOff = true;\n\n                if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                    $this.val(negativeBracket($this.val(), $settings));\n                }\n\n                var result = void 0;\n                if ($settings.eDec) {\n                    $settings.mDec = $settings.eDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.scaleDivisor) {\n                    $settings.mDec = $settings.oDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.nSep) {\n                    $settings.aSep = '';\n                    $settings.aSign = '';\n                    $settings.aSuffix = '';\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                    $this.autoNumeric('set', result);\n                }\n\n                holder.inVal = $this.val();\n                holder.lastVal = holder.inVal;\n                var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                    $this.val(onEmpty);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keydown' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeydown($this, holder) {\n        $this.on('keydown.autoNumeric', function (e) {\n            holder = getHolder($this);\n            if (holder.that.readOnly) {\n                holder.processed = true;\n\n                return true;\n            }\n            /* // The code below allows the \"enter\" keydown to throw a change() event\n             if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n             $this.change();\n             holder.inVal = $this.val();\n             } */\n            holder.init(e);\n            if (holder.skipAlways(e)) {\n                holder.processed = true;\n\n                return true;\n            }\n            if (holder.processAlways()) {\n                holder.processed = true;\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event in deletion character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return false;\n            }\n            holder.formatted = false;\n\n            return true;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keypress' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onKeypress($this, holder) {\n        $this.on('keypress.autoNumeric', function (e) {\n            // Firefox fix for Shift && insert paste event\n            if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                return;\n            }\n            holder = getHolder($this);\n            var processed = holder.processed;\n            holder.init(e);\n\n            if (holder.skipAlways(e)) {\n                return true;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return false;\n            }\n\n            if (holder.processAlways() || holder.processKeypress()) {\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event on adding character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return;\n            }\n            holder.formatted = false;\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'keyup' events\n     *\n     * @param $this\n     * @param holder\n     * @param settings\n     * @returns {*}\n     */\n    function onKeyup($this, holder, settings) {\n        $this.on('keyup.autoNumeric', function (e) {\n            holder = getHolder($this);\n            holder.init(e);\n            var skip = holder.skipAlways(e);\n            var tab = holder.kdCode;\n            holder.kdCode = 0;\n            delete holder.valuePartsBeforePaste;\n\n            // added to properly place the caret when only the currency sign is present\n            if ($this[0].value === holder.settingsClone.aSign) {\n                if (holder.settingsClone.pSign === 's') {\n                    setElementSelection(this, 0, 0);\n                } else {\n                    setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                }\n            } else if (tab === keyCode.Tab) {\n                setElementSelection(this, 0, $this.val().length);\n            }\n\n            if ($this[0].value === holder.settingsClone.aSuffix) {\n                setElementSelection(this, 0, 0);\n            }\n\n            if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                setElementSelection(this, 0, 0);\n            }\n\n            // saves the extended decimal to preserve the data when navigating away from the page\n            if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                autoSave($this, settings, 'set');\n            }\n            if (skip) {\n                return true;\n            }\n            if (this.value === '') {\n                return true;\n            }\n            if (!holder.formatted) {\n                holder.formatQuick(e);\n            }\n        });\n        return holder;\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onFocusOutAndMouseLeave($this, holder) {\n        $this.on('focusout.autoNumeric mouseleave.autoNumeric', function () {\n            if (!$this.is(':focus')) {\n                holder = getHolder($this);\n                var value = $this.val();\n                var origValue = value;\n                var settings = holder.settingsClone;\n                settings.onOff = false;\n                if (settings.aStor) {\n                    autoSave($this, settings, 'set');\n                }\n\n                if (settings.nSep === true) {\n                    settings.aSep = settings.oSep;\n                    settings.aSign = settings.oSign;\n                    settings.aSuffix = settings.oSuffix;\n                }\n\n                if (settings.eDec !== null) {\n                    settings.mDec = settings.oDec;\n                    settings.aPad = settings.oPad;\n                    settings.nBracket = settings.oBracket;\n                }\n\n                value = autoStrip(value, settings);\n                if (value !== '') {\n                    if (settings.trailingNegative) {\n                        value = '-' + value;\n                        settings.trailingNegative = false;\n                    }\n\n                    var _autoCheck3 = autoCheck(value, settings),\n                        _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                        minTest = _autoCheck4[0],\n                        maxTest = _autoCheck4[1];\n\n                    if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                        value = fixNumber(value, settings);\n                        settings.rawValue = value;\n\n                        if (settings.scaleDivisor) {\n                            value = value / settings.scaleDivisor;\n                            value = value.toString();\n                        }\n\n                        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? +settings.scaleDecimal : settings.mDec;\n                        value = autoRound(value, settings);\n                        value = presentNumber(value, settings);\n                    } else {\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        value = settings.rawValue;\n                    }\n                } else {\n                    if (settings.wEmpty === 'zero') {\n                        settings.rawValue = '0';\n                        value = autoRound('0', settings);\n                    } else {\n                        settings.rawValue = '';\n                    }\n                }\n\n                var groupedValue = checkEmpty(value, settings, false);\n                if (groupedValue === null) {\n                    groupedValue = autoGroup(value, settings);\n                }\n\n                if (groupedValue !== origValue) {\n                    groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                    $this.val(groupedValue);\n                }\n\n                if (groupedValue !== holder.inVal) {\n                    $this.change();\n                    delete holder.inVal;\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onPaste($this, holder) {\n        $this.on('paste', function (e) {\n            //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n            e.preventDefault();\n            holder = getHolder($this);\n\n            var oldRawValue = $this.autoNumeric('get');\n            var currentValue = this.value || '';\n            var selectionStart = this.selectionStart || 0;\n            var selectionEnd = this.selectionEnd || 0;\n            var prefix = currentValue.substring(0, selectionStart);\n            var suffix = currentValue.substring(selectionEnd, currentValue.length);\n            var pastedText = preparePastedText(e.originalEvent.clipboardData.getData('text/plain'), holder);\n\n            if (isValidPasteText(pastedText)) {\n                var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n                if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                    $this.autoNumeric('set', newValue);\n                    $this.trigger('input');\n                }\n            } else {\n                this.selectionStart = selectionEnd;\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param $this\n     * @param holder\n     * @returns {*}\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            holder = getHolder($this);\n\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unSetOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param $this\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param settings\n     * @param $input\n     * @param $this\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.aForm`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `anDefault` altogether.\n             */\n            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.eDec !== null && settings.aStor || settings.scaleDivisor && settings.aStor) {\n                        settings.rawValue = autoSave($this, settings, 'get');\n                    }\n\n                    // If the eDec value should NOT be saved in sessionStorage\n                    if (!settings.aStor) {\n                        var toStrip = void 0;\n\n                        if (settings.nBracket !== null && settings.aNeg !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.wEmpty) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.aSign);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.anDefault !== null) {\n                if (settings.anDefault === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `pNeg` option depending on `aSign` and `pSign`.\n     *\n     * If the user has not set the placement of the negative sign (`pNeg`), but has set a currency symbol (`aSign`),\n     * then we modify the default value of `pNeg` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({aSign: \"$\", pNeg: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({aSign: \"$\", pSign: \"s\", pNeg: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.pNeg) && options.aSign !== '') {\n            switch (settings.pSign) {\n                case 's':\n                    settings.pNeg = 'p';\n                    break;\n                case 'p':\n                    settings.pNeg = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param options\n     * @param $this\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n            // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n            var tagData = $this.data();\n\n            settings = $.extend({}, defaultSettings, tagData, options, {\n                onOff: false,\n                runOnce: false,\n                rawValue: '',\n                trailingNegative: false,\n                caretFix: false,\n                throwInput: true,\n                strip: true,\n                tagList: allowedTagList\n            });\n\n            // Modify the user settings to make them 'exploitable'\n            $.each(settings, function (key, value) {\n                // Convert the string 'true' and 'false' to real Boolean\n                if (value === 'true' || value === 'false') {\n                    settings[key] = value === 'true';\n                }\n\n                // Convert numbers in options to strings\n                //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                if (typeof value === 'number' && key !== 'aScale') {\n                    settings[key] = value.toString();\n                }\n            });\n\n            // Improve the `pNeg` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign\n            settings.aNeg = settings.vMin < 0 ? '-' : '';\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                //TODO Shouldn't the next line be in the `getInitialSettings()` function?\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                if (settings.runOnce === false && settings.aForm) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    holder = onFocusInAndMouseEnter($this, holder);\n                    holder = onFocusOutAndMouseLeave($this, holder);\n                    holder = onKeydown($this, holder);\n                    holder = onKeypress($this, holder);\n                    holder = onKeyup($this, holder, settings);\n                    holder = onPaste($this, holder);\n                    onSubmit($this, holder);\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                //TODO Replace all this duplicated code with a call to `getInitialSettings()`\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method');\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character');\n                }\n\n                // Improve the `pNeg` option if needed\n                correctPNegOption(options, settings);\n\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = autoGet(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n\n                value = fixNumber(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputType` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputType\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = autoGet(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputType);\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet(this);\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @return {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-'; //TODO Replace this with `getInitialSettings()` that already sets `aNeg`?\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * Public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputType);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.');\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.');\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.');\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.');\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.');\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.');\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.');\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.');\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.');\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.');\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].');\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.');\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.');\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.');\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.');\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.');\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.');\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.');\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.');\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputType) && !isInArray(options.outputType, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputType\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputType + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.');\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiYVNlcCIsIm5TZXAiLCJkR3JvdXAiLCJhRGVjIiwiYWx0RGVjIiwiYVNpZ24iLCJwU2lnbiIsInBOZWciLCJhU3VmZml4Iiwib0xpbWl0cyIsInZNYXgiLCJ2TWluIiwibURlYyIsImVEZWMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWwiLCJzY2FsZVN5bWJvbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNWYWxpZFBhc3RlVGV4dCIsInRleHQiLCJpc05hTiIsInByZXBhcmVQYXN0ZWRUZXh0IiwiaG9sZGVyIiwiYXV0b1N0cmlwIiwic2V0dGluZ3NDbG9uZSIsInJlcGxhY2UiLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImFyciIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsIkVycm9yIiwiaGFzRGVjaW1hbHMiLCJzcGxpdCIsImRlY2ltYWxQYXJ0IiwiZGVjaW1hbFBsYWNlcyIsImxlbmd0aCIsImdldEVsZW1lbnRTZWxlY3Rpb24iLCJ0aGF0IiwicG9zaXRpb24iLCJzZWxlY3Rpb25TdGFydCIsImZvY3VzIiwic2VsZWN0IiwiZG9jdW1lbnQiLCJzZWxlY3Rpb24iLCJjcmVhdGVSYW5nZSIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJ3YXJuaW5nIiwic3VwcHJlc3NXYXJuaW5ncyIsImNvbnNvbGUiLCJ3YXJuIiwicnVuQ2FsbGJhY2tzIiwiJHRoaXMiLCJzZXR0aW5ncyIsIiQiLCJlYWNoIiwidmFsIiwiYXV0b051bWVyaWMiLCJkZWNMZW5ndGgiLCJ2TWF4TGVuZ3RoIiwidk1pbkxlbmd0aCIsIk1hdGgiLCJtYXgiLCJhdXRvQ29kZSIsIm1JbnRQb3MiLCJtSW50TmVnIiwib0RlYyIsIk51bWJlciIsImFOZWdSZWciLCJhTmVnIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsInNraXBGaXJzdEF1dG9TdHJpcCIsIlJlZ0V4cCIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZCIsImFsbG93ZWRBdXRvU3RyaXAiLCJudW1SZWdBdXRvU3RyaXAiLCJ0cmFpbGluZ05lZ2F0aXZlIiwibWF0Y2giLCJqb2luIiwiblNpZ24iLCJpbnRlZ2VyUGFydCIsIm1vZGlmaWVkSW50ZWdlclBhcnQiLCJjaGFyQXQiLCJzbGljZSIsIm9uT2ZmIiwic3RyaXBSZWciLCJuZWdhdGl2ZUJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwicmVzdWx0IiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpbnB1dFZhbHVlIiwic2lnbk9uRW1wdHkiLCJhdXRvR3JvdXAiLCJzdHJpcCIsImVtcHR5IiwiaXNOZWciLCJkaWdpdGFsR3JvdXAiLCJ0ZXN0Iiwic3Vic3RyaW5nIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwicm91bmRlZElucHV0VmFsdWUiLCJyRGVjIiwicmVnZXgiLCJhdXRvUm91bmQiLCJyb3VuZCIsImNlaWwiLCJmbG9vciIsIml2Um91bmRlZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsImF1dG9HZXQiLCJnZXRIb2xkZXIiLCIkdGhhdCIsInVwZGF0ZSIsImRhdGEiLCJBdXRvTnVtZXJpY0hvbGRlciIsImdldCIsImtlZXBPcmlnaW5hbFNldHRpbmdzIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwib1N1ZmZpeCIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJhdXRvU2F2ZSIsInRvRG8iLCJzdG9yZWROYW1lIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWQiLCJkYXRlIiwiZXhwaXJlcyIsIkRhdGUiLCJzZXRUaW1lIiwiZ2V0VGltZSIsInRvVVRDU3RyaW5nIiwiZ2V0SXRlbSIsImZvcm1hdHRlZCIsImluaXQiLCJjdHJsS2V5IiwiY21kS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwidHlwZSIsImtkQ29kZSIsIndoaWNoIiwicHJvY2Vzc2VkIiwic2V0U2VsZWN0aW9uIiwic2V0UmVhbCIsIm1pbiIsInNldFBvc2l0aW9uIiwicG9zIiwiZ2V0QmVmb3JlQWZ0ZXIiLCJsZWZ0IiwicmlnaHQiLCJnZXRCZWZvcmVBZnRlclN0cmlwZWQiLCJub3JtYWxpemVQYXJ0cyIsIm5ld1ZhbHVlIiwic2V0VmFsdWVQYXJ0cyIsImFkdmVudCIsInBhcnRzIiwibWluVGVzdCIsIm1heFRlc3QiLCJ0ZXN0VmFsdWUiLCJ0cmlnZ2VyIiwic2lnblBvc2l0aW9uIiwiYVNpZ25MZW4iLCJoYXNOZWciLCJ2YWx1ZUxlbiIsImV4cGFuZFNlbGVjdGlvbk9uU2lnbiIsImNoZWNrUGFzdGUiLCJ2YWx1ZVBhcnRzQmVmb3JlUGFzdGUiLCJvbGRQYXJ0cyIsIm1vZGlmaWVkTGVmdFBhcnQiLCJzdWJzdHIiLCJza2lwQWx3YXlzIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJhU3VmZml4TGVuIiwic3RhcnRKdW1wIiwicHJvY2Vzc1RyYWlsaW5nIiwiY2FyZXRGaXgiLCJwcm9jZXNzQWx3YXlzIiwidGhyb3dJbnB1dCIsInByb2Nlc3NLZXlwcmVzcyIsImNDb2RlIiwiZnJvbUNoYXJDb2RlIiwiZm9ybWF0UXVpY2siLCJsZWZ0TGVuZ3RoIiwia3VDb2RlIiwic3ViUGFydHMiLCJsZWZ0QXIiLCJzaGlmdCIsInB1c2giLCJzaWduUGFydHMiLCJlc2NhcGVDaHIiLCJlc2NhcGVkUGFydHMiLCJtaW5pUGFydHMiLCJsZWZ0UmVnIiwibmV3TGVmdCIsIl9nZXRTdHJpbmdPckFycmF5IiwiZ2V0QXJyYXlCZWhhdmlvciIsImZvcm1JbmRleCIsImluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsImluQXJyYXkiLCJ0ZXN0SW5wdXQiLCJzZXJpYWxpemUiLCJmb3JtUGFydHMiLCJpbnB1dE5hbWUiLCJtb2RpZmllZElucHV0VmFsdWUiLCJvbkZvY3VzSW5BbmRNb3VzZUVudGVyIiwib24iLCIkc2V0dGluZ3MiLCJpcyIsImluVmFsIiwibGFzdFZhbCIsIm9uRW1wdHkiLCJvbktleWRvd24iLCJyZWFkT25seSIsImN1cnJlbnRWYWx1ZSIsIm9uS2V5cHJlc3MiLCJvbktleXVwIiwic2tpcCIsInRhYiIsIm9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlIiwib3JpZ1ZhbHVlIiwiZ3JvdXBlZFZhbHVlIiwiY2hhbmdlIiwib25QYXN0ZSIsIm9sZFJhd1ZhbHVlIiwicHJlZml4Iiwic3VmZml4IiwicGFzdGVkVGV4dCIsIm9yaWdpbmFsRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RGF0YSIsInZhbHVlT2YiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSIsIiRpbnB1dCIsImN1cnJlbnRFbGVtZW50VGFnIiwiZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZCIsInNldFZhbHVlIiwiYXR0ciIsInRlc3RlZEN1cnJlbnRWYWx1ZSIsInBhcnNlRmxvYXQiLCJJbmZpbml0eSIsImlzTnVtZXJpYyIsInRvU3RyaXAiLCJ0YWdMaXN0IiwiY29ycmVjdFBOZWdPcHRpb24iLCJvcHRpb25zIiwiZ2V0SW5pdGlhbFNldHRpbmdzIiwidGFnRGF0YSIsImV4dGVuZCIsInJ1bk9uY2UiLCJrZXkiLCJtZXRob2RzIiwiZGVzdHJveSIsInJlbW92ZURhdGEiLCJvZmYiLCJ3aXBlIiwic2V0IiwiYXR0ZW1wdGVkVmFsdWUiLCJ1blNldCIsInJlU2V0IiwiZXEiLCJnZXRMb2NhbGl6ZWQiLCJnZXRGb3JtYXR0ZWQiLCJnZXRTdHJpbmciLCJnZXRBcnJheSIsImdldFNldHRpbmdzIiwiZm4iLCJtZXRob2QiLCJhcmdzIiwiYXBwbHkiLCJkZWZhdWx0cyIsInNlbmRDdXN0b21FdmVudCIsImF1dG9VbmZvcm1hdCIsInVzZXJPcHRpb25zIiwic2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMiLCJ0ZXN0UG9zaXRpdmVJbnRlZ2VyIiwidGVzdE51bWVyaWNhbENoYXJhY3RlcnMiLCJ0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiIsInRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyIiwiZHBWTWluIiwiZHBWTWF4Iiwidk1pbk1heERlY2ltYWxQbGFjZXMiLCJpc1ZhbGlkIiwiZXJyb3IiLCJjcmVhdGVDdXN0b21FdmVudCIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJkaXNwYXRjaEV2ZW50IiwiZXZlbnQiLCJwYXJhbXMiLCJldnQiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsIkV2ZW50IiwiZm9ybWF0IiwidW5Gb3JtYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBOztBQUVBO0FBQ0EsSUFBSUEsbUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLHlCQUFKO0FBQ0EsSUFBSUMsaUJBQUo7QUFDQSxJQUFJQyx5QkFBSjs7QUFFQTtBQUNBOzs7QUFHQSxJQUFNQyxpQkFBaUIsQ0FDbkIsR0FEbUIsRUFFbkIsU0FGbUIsRUFHbkIsTUFIbUIsRUFJbkIsTUFKbUIsRUFLbkIsT0FMbUIsRUFNbkIsSUFObUIsRUFPbkIsS0FQbUIsRUFRbkIsS0FSbUIsRUFTbkIsS0FUbUIsRUFVbkIsSUFWbUIsRUFXbkIsSUFYbUIsRUFZbkIsSUFabUIsRUFhbkIsSUFibUIsRUFjbkIsSUFkbUIsRUFlbkIsSUFmbUIsRUFnQm5CLElBaEJtQixFQWlCbkIsSUFqQm1CLEVBa0JuQixLQWxCbUIsRUFtQm5CLEtBbkJtQixFQW9CbkIsT0FwQm1CLEVBcUJuQixJQXJCbUIsRUFzQm5CLFFBdEJtQixFQXVCbkIsUUF2Qm1CLEVBd0JuQixHQXhCbUIsRUF5Qm5CLEdBekJtQixF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QUFVLEVBQUVKLFNBQVMsS0FBWCxFQUFrQkMsWUFBWSxLQUE5QixFQUFxQ0gsUUFBUSxLQUFLLENBQWxELEVBQW5CO0FBQ0EsZ0JBQU1PLE1BQU0vVCxTQUFTZ1UsV0FBVCxDQUFxQixhQUFyQixDQUFaO0FBQ0FELGdCQUFJRSxlQUFKLENBQW9CSixLQUFwQixFQUEyQkMsT0FBT0osT0FBbEMsRUFBMkNJLE9BQU9ILFVBQWxELEVBQThERyxPQUFPTixNQUFyRTtBQUNBLG1CQUFPTyxHQUFQO0FBQ0g7O0FBRUROLG9CQUFZeFUsU0FBWixHQUF3QnBDLE9BQU9xWCxLQUFQLENBQWFqVixTQUFyQztBQUNBcEMsZUFBTzRXLFdBQVAsR0FBcUJBLFdBQXJCO0FBQ0gsS0FkRDtBQWVILENBL2tHQSxDQUFEOztBQWlsR0E7OztrQkFHZTtBQUNYVSxZQUFVcmdCLFVBREM7QUFFWHNnQixjQUFVcmdCLFlBRkM7QUFHWEMsc0NBSFc7QUFJWEMsc0JBSlcsRUFJRDtBQUNWQyxzQ0FMVyxFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogYXV0b051bWVyaWMuanNcbiogQGF1dGhvcjogQm9iIEtub3RoZVxuKiBAY29udHJpYnV0b3JzOiBTb2tvbG92IFl1cmEgYW5kIG90aGVyIEdpdGh1YiB1c2Vyc1xuKiBAdmVyc2lvbjogMi4wIC0gMjAxNi0xMi0wMSBVVEMgMjE6MDBcbipcbiogQ3JlYXRlZCBieSBSb2JlcnQgSi4gS25vdGhlIG9uIDIwMDktMDgtMDkuIFBsZWFzZSByZXBvcnQgYW55IGJ1Z3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL0JvYktub3RoZS9hdXRvTnVtZXJpY1xuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4qXG4qIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vKiBnbG9iYWwgbW9kdWxlLCByZXF1aXJlLCBkZWZpbmUgKi9cblxuLy8gRnVuY3Rpb25zIG5hbWVzIGZvciBFUzYgZXhwb3J0c1xubGV0IGF1dG9Gb3JtYXQ7XG5sZXQgYXV0b1VuRm9ybWF0O1xubGV0IGdldERlZmF1bHRDb25maWc7XG5sZXQgdmFsaWRhdGU7XG5sZXQgYXJlU2V0dGluZ3NWYWxpZDtcblxuLy8gQXV0b051bWVyaWMgZGVmYXVsdCBzZXR0aW5nc1xuLyoqXG4gKiBMaXN0IG9mIGFsbG93ZWQgdGFnIG9uIHdoaWNoIGF1dG9OdW1lcmljIGNhbiBiZSB1c2VkLlxuICovXG5jb25zdCBhbGxvd2VkVGFnTGlzdCA9IFtcbiAgICAnYicsXG4gICAgJ2NhcHRpb24nLFxuICAgICdjaXRlJyxcbiAgICAnY29kZScsXG4gICAgJ2NvbnN0JyxcbiAgICAnZGQnLFxuICAgICdkZWwnLFxuICAgICdkaXYnLFxuICAgICdkZm4nLFxuICAgICdkdCcsXG4gICAgJ2VtJyxcbiAgICAnaDEnLFxuICAgICdoMicsXG4gICAgJ2gzJyxcbiAgICAnaDQnLFxuICAgICdoNScsXG4gICAgJ2g2JyxcbiAgICAnaW5zJyxcbiAgICAna2RiJyxcbiAgICAnbGFiZWwnLFxuICAgICdsaScsXG4gICAgJ29wdGlvbicsXG4gICAgJ291dHB1dCcsXG4gICAgJ3AnLFxuICAgICdxJyxcbiAgICAncycsXG4gICAgJ3NhbXBsZScsXG4gICAgJ3NwYW4nLFxuICAgICdzdHJvbmcnLFxuICAgICd0ZCcsXG4gICAgJ3RoJyxcbiAgICAndScsXG5dO1xuXG4vKipcbiAqIERlZmF1bHRzIG9wdGlvbnMgYXJlIHB1YmxpYyAtIHRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmc6XG4gKiAtIEhUTUw1IGRhdGEgYXR0cmlidXRlc1xuICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHNcbiAqIC0gVXNlIGpRdWVyeSdzIGAkLmV4dGVuZGAgbWV0aG9kIGZvciBnbG9iYWwgY2hhbmdlcyAtIGFsc28gYSBncmVhdCB3YXkgdG8gcGFzcyBBU1AuTkVUIGN1cnJlbnQgY3VsdHVyZSBzZXR0aW5nc1xuICovXG5jb25zdCBkZWZhdWx0U2V0dGluZ3MgPSB7XG4gICAgLyogQWxsb3dlZCB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICogYXBvc3Ryb3BoZSBpcyBlc2NhcGVkID0gXCJcXFwiXCJcbiAgICAgKiBzcGFjZSA9IFwiIFwiXG4gICAgICogbm9uZSA9IFwiXCJcbiAgICAgKiBOT1RFOiBkbyBub3QgdXNlIG51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAqL1xuICAgIGFTZXA6ICcsJyxcblxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKi9cbiAgICBuU2VwOiBmYWxzZSxcblxuICAgIC8qIERpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcbiAgICAgKiBkR3JvdXA6IFwiMlwiLCByZXN1bHRzIGluIDk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzXG4gICAgICogZEdyb3VwOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxuICAgICAqIGRHcm91cDogXCI0XCIsIHJlc3VsdHMgaW4gOTk5OSw5OTk5LDk5OTkgdXNlZCBpbiBzb21lIEFzaWFuIGNvdW50cmllc1xuICAgICAqL1xuICAgIGRHcm91cDogJzMnLFxuXG4gICAgLyogQWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXJzXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgKi9cbiAgICBhRGVjOiAnLicsXG5cbiAgICAvKiBBbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgYURlY1xuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgKi9cbiAgICBhbHREZWM6IG51bGwsXG5cbiAgICAvKiBhU2lnbiA9IGFsbG93ZWQgY3VycmVuY3kgc3ltYm9sXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXG4gICAgICogc3BhY2UgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICckICdcbiAgICAgKiBzcGFjZSB0byB0aGUgbGVmdCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnICQnXG4gICAgICovXG4gICAgYVNpZ246ICcnLFxuXG4gICAgLyogcFNpZ24gPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XG4gICAgICogZm9yIHByZWZpeCBwU2lnbjogXCJwXCIgKGRlZmF1bHQpXG4gICAgICogZm9yIHN1ZmZpeCBwU2lnbjogXCJzXCJcbiAgICAgKi9cbiAgICBwU2lnbjogJ3AnLFxuXG4gICAgLyogUGxhY2VtZW50IG9mIG5lZ2F0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGFTaWduIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcbiAgICAgKiAtMSwyMzQuNTYgID0+IGRlZmF1bHQgbm8gb3B0aW9ucyByZXF1aXJlZFxuICAgICAqIC0kMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIn1cbiAgICAgKiAkLTEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwiclwifVxuICAgICAqIC0xLDIzNC41NiQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn1cbiAgICAgKiAxLDIzNC41Ni0gID0+IHtwTmVnOiBcInNcIn1cbiAgICAgKiAkMSwyMzQuNTYtID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwic1wifVxuICAgICAqIDEsMjM0LjU2LSQgPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wifVxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInJcIn1cbiAgICAgKi9cbiAgICBwTmVnOiAnbCcsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGFTdWZmaXg6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBhU3VmZml4OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqL1xuICAgIGFTdWZmaXg6ICcnLFxuXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcbiAgICAgKiBvTGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIHZNYXggYW5kIGlnbm9yZXMgdk1pbiBzZXR0aW5nc1xuICAgICAqIG9MaW1pdHM6IFwiZmxvb3JcIiBhZGhlcmVzIHRvIHZNaW4gYW5kIGlnbm9yZXMgdk1heCBzZXR0aW5nc1xuICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICovXG4gICAgb0xpbWl0czogbnVsbCxcblxuICAgIC8qIE1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICogdmFsdWUgbXVzdCBiZSBsYXJnZXIgdGhhbiB2TWluXG4gICAgICovXG4gICAgdk1heDogJzk5OTk5OTk5OTk5OTkuOTknLFxuXG4gICAgLyogTWluaW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbiB2TWF4XG4gICAgICovXG4gICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIHZNaW4gJiB2TWF4IHZhbHVlc1xuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGV4YW1wbGUgbURlYzogXCIzXCIsXG4gICAgICovXG4gICAgbURlYzogbnVsbCxcblxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAqIHtlRGVjOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKi9cbiAgICBlRGVjOiBudWxsLFxuXG4gICAgLyogVGhlIG5leHQgdGhyZWUgb3B0aW9ucyAoc2NhbGVEaXZpc29yLCBzY2FsZURlY2ltYWwgJiBzY2FsZVN5bWJvbCkgaGFuZGxlIHNjYWxpbmcgb2YgdGhlIGlucHV0IHdoZW4gdGhlIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXNcbiAgICAgKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBub24tc2NhbGVkIHZhbHVlIGlzIGhlbGQgaW4gZGF0YSBhbmQgaXQgaXMgYWR2aXNlZCB0aGF0IHlvdSB1c2UgdGhlIFwiYVN0b3JcIiBvcHRpb24gdG8gZW5zdXJlIHJldGFpbmluZyB0aGUgdmFsdWVcbiAgICAgKiBbXCJkaXZpc29yXCIsIFwiZGVjaW1hbCBwbGFjZXNcIiwgXCJzeW1ib2xcIl1cbiAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWw6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XG4gICAgICogRXhhbXBsZTogZm9jdXNpbiB2YWx1ZSBcIjEsMTExLjExXCIgZm9jdXNvdXQgdmFsdWUgXCIxLjEgS1wiXG4gICAgICovXG5cbiAgICAvKiBUaGUgYHNjYWxlRGl2aXNvcmAgZGVjaWRlcyB0aGUgb24gZm9jdXMgdmFsdWUgYW5kIHBsYWNlcyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBvbiBmb2N1c291dFxuICAgICAqIEV4YW1wbGUge3NjYWxlRGl2aXNvcjogJzEwMDAnfSBvciA8aW5wdXQgZGF0YS1zY2FsZS1kaXZpc29yPVwiMTAwMFwiPlxuICAgICAqIFRoZSBkaXZpc29yIHZhbHVlIC0gZG9lcyBub3QgbmVlZCB0byBiZSB3aG9sZSBudW1iZXIgYnV0IHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXG4gICAgICogVGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGZ1bGwgdmFsdWUsIGluY2x1ZGluZyB0aGUgJ2hpZGRlbicgZGVjaW1hbHMuXG4gICAgICovXG4gICAgc2NhbGVEaXZpc29yOiBudWxsLFxuXG4gICAgLypcbiAgICAgKiBUaGUgYHNjYWxlRGVjaW1hbGAgb3B0aW9uIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZSB3aGVuIG5vdCBpbiBmb2N1cyAtIGZvciB0aGlzIHRvIHdvcmssIGBzY2FsZWREaXZpc29yYCBtdXN0IG5vdCBiZSBgbnVsbGAuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCA7IGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIHRoZSBmb2N1cy5cbiAgICAgKi9cbiAgICBzY2FsZURlY2ltYWw6IG51bGwsXG5cbiAgICAvKlxuICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXG4gICAgICogVGhpcyBpcyBvcHRpb25hbCB0b28uXG4gICAgICovXG4gICAgc2NhbGVTeW1ib2w6IG51bGwsXG5cbiAgICAvKiBTZXQgdG8gdHJ1ZSB0byBhbGxvdyB0aGUgZURlYyB2YWx1ZSB0byBiZSBzYXZlZCB3aXRoIHNlc3Npb25TdG9yYWdlXG4gICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcbiAgICAgKi9cbiAgICBhU3RvcjogZmFsc2UsXG5cbiAgICAvKiBtZXRob2QgdXNlZCBmb3Igcm91bmRpbmdcbiAgICAgKiBtUm91bmQ6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiBtUm91bmQ6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcbiAgICAgKiBtUm91bmQ6IFwic1wiLCBSb3VuZC1IYWxmLURvd24gU3ltbWV0cmljIChsb3dlciBjYXNlIHMpXG4gICAgICogbVJvdW5kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiBtUm91bmQ6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcbiAgICAgKiBtUm91bmQ6IFwiVVwiLCBSb3VuZCBVcCBcIlJvdW5kLUF3YXktRnJvbS1aZXJvXCJcbiAgICAgKiBtUm91bmQ6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiBtUm91bmQ6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcbiAgICAgKiBtUm91bmQ6IFwiRlwiLCBSb3VuZCB0byBGbG9vciBcIlRvd2FyZCBOZWdhdGl2ZSBJbmZpbml0eVwiXG4gICAgICogbVJvdW5kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiBtUm91bmQ6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XG4gICAgICogbVJvdW5kOiBcIkQwNVwiIFJvdW5kcyBkb3duIHRvIG5leHQgLjA1XG4gICAgICovXG4gICAgbVJvdW5kOiAnUycsXG5cbiAgICAvKiBDb250cm9scyBkZWNpbWFsIHBhZGRpbmdcbiAgICAgKiBhUGFkOiB0cnVlIC0gYWx3YXlzIFBhZCBkZWNpbWFscyB3aXRoIHplcm9zXG4gICAgICogYVBhZDogZmFsc2UgLSBkb2VzIG5vdCBwYWQgd2l0aCB6ZXJvcy5cbiAgICAgKiBOb3RlOiBzZXR0aW5nIGFQYWQgdG8gJ2ZhbHNlJyB3aWxsIG92ZXJyaWRlIHRoZSAnbURlYycgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICovXG4gICAgYVBhZDogdHJ1ZSxcblxuICAgIC8qIEFkZHMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzIChpZS4gdHJhbnNmb3JtcyAnLSQgOTk5Ljk5JyB0byAnKDk5OS45OSknKVxuICAgICAqIFRob3NlIGJyYWNrZXRzIGFyZSB2aXNpYmxlIG9ubHkgd2hlbiB0aGUgZmllbGQgZG9lcyBOT1QgaGF2ZSB0aGUgZm9jdXMuXG4gICAgICogVGhlIGxlZnQgYW5kIHJpZ2h0IHN5bWJvbHMgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgc2VwYXJhdGVkIGJ5IGEgY29tbWFcbiAgICAgKiBuQnJhY2tldDogbnVsbCAtIChkZWZhdWx0KVxuICAgICAqIG5CcmFja2V0OiAnKCwpJywgbkJyYWNrZXQ6ICdbLF0nLCBuQnJhY2tldDogJzwsPicgb3IgbkJyYWNrZXQ6ICd7LH0nXG4gICAgICovXG4gICAgbkJyYWNrZXQ6IG51bGwsXG5cbiAgICAvKiBEaXNwbGF5ZWQgb24gZW1wdHkgc3RyaW5nIFwiXCJcbiAgICAgKiB3RW1wdHk6IFwiZm9jdXNcIiAtIChkZWZhdWx0KSBjdXJyZW5jeSBzaWduIGRpc3BsYXllZCBhbmQgdGhlIGlucHV0IHJlY2VpdmVzIGZvY3VzXG4gICAgICogd0VtcHR5OiBcInByZXNzXCIgLSBjdXJyZW5jeSBzaWduIGRpc3BsYXlzIG9uIGFueSBrZXkgYmVpbmcgcHJlc3NlZFxuICAgICAqIHdFbXB0eTogXCJhbHdheXNcIiAtIGFsd2F5cyBkaXNwbGF5cyB0aGUgY3VycmVuY3kgc2lnbiBvbmx5XG4gICAgICogd0VtcHR5OiBcInplcm9cIiAtIGlmIHRoZSBpbnB1dCBoYXMgbm8gdmFsdWUgb24gZm9jdXMgb3V0IGRpc3BsYXlzIGEgemVybyBcInJvdW5kZWRcIiB3aXRoIG9yIHdpdGhvdXQgYSBjdXJyZW5jeSBzaWduXG4gICAgICovXG4gICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gdG8gZGlzcGxheSB0aGUgY3VycmVuY3kgc2lnbiBvbmx5IG9uIGhvdmVyIChpZiB0aGUgaW5wdXQgaXMgZW1wdHkpXG4gICAgd0VtcHR5OiAnZm9jdXMnLFxuXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICogbFplcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgKiBsWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgKi9cbiAgICBsWmVybzogJ2RlbnknLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZVxuICAgICAqL1xuICAgIGFGb3JtOiB0cnVlLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBzZWxlY3QgYWxsIGtleWJvYXJkIGNvbW1hbmQgd2lsbCBzZWxlY3RcbiAgICAgKiB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCBvciBvbmx5IHRoZSBpbnB1dCBudW1lcmljIHZhbHVlXG4gICAgICogaWYgdGhlIGN1cnJlbmN5IHN5bWJvbCBpcyBiZXR3ZWVuIHRoZSBudW1lcmljIHZhbHVlIGFuZCB0aGUgbmVnYXRpdmUgc2lnbiBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBzTnVtYmVyOiBmYWxzZSxcblxuICAgIC8qIEhlbHBlciBvcHRpb24gZm9yIEFTUC5ORVQgcG9zdGJhY2tcbiAgICAgKiBzaG91bGQgYmUgdGhlIHZhbHVlIG9mIHRoZSB1bmZvcm1hdHRlZCBkZWZhdWx0IHZhbHVlXG4gICAgICogZXhhbXBsZXM6XG4gICAgICogbm8gZGVmYXVsdCB2YWx1ZT1cIlwiIHthbkRlZmF1bHQ6IFwiXCJ9XG4gICAgICogdmFsdWU9MTIzNC41NiB7YW5EZWZhdWx0OiAnMTIzNC41Nid9XG4gICAgICovXG4gICAgYW5EZWZhdWx0OiBudWxsLFxuXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxuICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICovXG4gICAgdW5TZXRPblN1Ym1pdDogZmFsc2UsXG5cbiAgICAvKiBBbGxvd3MgdGhlIG91dHB1dCB0byBiZSBpbiB0aGUgbG9jYWxlIGZvcm1hdCB2aWEgdGhlIFwiZ2V0XCIsIFwiZ2V0U3RyaW5nXCIgJiBcImdldEFycmF5XCIgbWV0aG9kc1xuICAgICAqIG51bGwgb3IgJ3N0cmluZycgPT4gJ25ubm4ubm4nIG9yICctbm5ubi5ubicgYXMgdGV4dCB0eXBlLiBUaGlzIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxuICAgICAqICdudW1iZXInICAgICAgICAgPT4gbm5ubi5ubiBvciAtbm5ubi5ubiBhcyBhIE51bWJlciAoV2FybmluZzogdGhpcyB3b3JrcyBvbmx5IGZvciBpbnRlZ2VycyBpbmZlcmlvciB0byBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUilcbiAgICAgKiAnLCcgb3IgJy0sJyAgICAgID0+ICdubm5uLG5uJyBvciAnLW5ubm4sbm4nXG4gICAgICogJy4tJyAgICAgICAgICAgICA9PiAnbm5ubi5ubicgb3IgJ25ubm4ubm4tJ1xuICAgICAqICcsLScgICAgICAgICAgICAgPT4gJ25ubm4sbm4nIG9yICdubm5uLG5uLSdcbiAgICAgKi9cbiAgICBvdXRwdXRUeXBlOiBudWxsLFxuXG4gICAgLyogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cbiAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAqIGZhbHNlID0+IHRocm93cyBlcnJvcnMgd2hlbiBjYWxsaW5nIG1ldGhvZHMgcHJpb3IgdG8gdGhlIHN1cHBvcnRlZCBlbGVtZW50IGhhcyBiZWVuIGluaXRpYWxpemVkIGJlIGF1dG9OdW1lcmljXG4gICAgICovXG4gICAgZGVidWc6IGZhbHNlLFxufTtcblxuLyoqXG4gKiBXcmFwcGVyIHZhcmlhYmxlIHRoYXQgaG9sZCBuYW1lZCBrZXlib2FyZCBrZXlzIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBrZXlDb2RlIGFzIHNlZW4gaW4gRE9NIGV2ZW50cy5cbiAqL1xuY29uc3Qga2V5Q29kZSA9IHtcbiAgICBCYWNrc3BhY2U6ICAgICAgOCxcbiAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICBFbnRlcjogICAgICAgICAgMTMsXG4gICAgU2hpZnQ6ICAgICAgICAgIDE2LFxuICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICBBbHQ6ICAgICAgICAgICAgMTgsXG4gICAgUGF1c2VCcmVhazogICAgIDE5LFxuICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICBFc2M6ICAgICAgICAgICAgMjcsXG4gICAgU3BhY2U6ICAgICAgICAgIDMyLFxuICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICBQYWdlRG93bjogICAgICAgMzQsXG4gICAgRW5kOiAgICAgICAgICAgIDM1LFxuICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICBMZWZ0QXJyb3c6ICAgICAgMzcsXG4gICAgVXBBcnJvdzogICAgICAgIDM4LFxuICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICBEb3duQXJyb3c6ICAgICAgNDAsXG4gICAgSW5zZXJ0OiAgICAgICAgIDQ1LFxuICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICBudW0wOiAgICAgICAgICAgNDgsXG4gICAgbnVtMTogICAgICAgICAgIDQ5LFxuICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICBudW0zOiAgICAgICAgICAgNTEsXG4gICAgbnVtNDogICAgICAgICAgIDUyLFxuICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICBudW02OiAgICAgICAgICAgNTQsXG4gICAgbnVtNzogICAgICAgICAgIDU1LFxuICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICBudW05OiAgICAgICAgICAgNTcsXG4gICAgYTogICAgICAgICAgICAgIDY1LFxuICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICBjOiAgICAgICAgICAgICAgNjcsXG4gICAgZDogICAgICAgICAgICAgIDY4LFxuICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICBmOiAgICAgICAgICAgICAgNzAsXG4gICAgZzogICAgICAgICAgICAgIDcxLFxuICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICBpOiAgICAgICAgICAgICAgNzMsXG4gICAgajogICAgICAgICAgICAgIDc0LFxuICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICBsOiAgICAgICAgICAgICAgNzYsXG4gICAgbTogICAgICAgICAgICAgIDc3LFxuICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICBvOiAgICAgICAgICAgICAgNzksXG4gICAgcDogICAgICAgICAgICAgIDgwLFxuICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICByOiAgICAgICAgICAgICAgODIsXG4gICAgczogICAgICAgICAgICAgIDgzLFxuICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICB1OiAgICAgICAgICAgICAgODUsXG4gICAgdjogICAgICAgICAgICAgIDg2LFxuICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICB4OiAgICAgICAgICAgICAgODgsXG4gICAgeTogICAgICAgICAgICAgIDg5LFxuICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICBXaW5kb3dzOiAgICAgICAgOTEsXG4gICAgUmlnaHRDbGljazogICAgIDkzLFxuICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICBudW1wYWQxOiAgICAgICAgOTcsXG4gICAgbnVtcGFkMjogICAgICAgIDk4LFxuICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICBudW1wYWQ0OiAgICAgICAgMTAwLFxuICAgIG51bXBhZDU6ICAgICAgICAxMDEsXG4gICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICBudW1wYWQ3OiAgICAgICAgMTAzLFxuICAgIG51bXBhZDg6ICAgICAgICAxMDQsXG4gICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICBNdWx0aXBseU51bXBhZDogMTA2LFxuICAgIFBsdXNOdW1wYWQ6ICAgICAxMDcsXG4gICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICBEb3ROdW1wYWQ6ICAgICAgMTEwLFxuICAgIFNsYXNoTnVtcGFkOiAgICAxMTEsXG4gICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICBGMjogICAgICAgICAgICAgMTEzLFxuICAgIEYzOiAgICAgICAgICAgICAxMTQsXG4gICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICBGNTogICAgICAgICAgICAgMTE2LFxuICAgIEY2OiAgICAgICAgICAgICAxMTcsXG4gICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICBGODogICAgICAgICAgICAgMTE5LFxuICAgIEY5OiAgICAgICAgICAgICAxMjAsXG4gICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICBGMTE6ICAgICAgICAgICAgMTIyLFxuICAgIEYxMjogICAgICAgICAgICAxMjMsXG4gICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICBTY3JvbGxMb2NrOiAgICAgMTQ1LFxuICAgIE15Q29tcHV0ZXI6ICAgICAxODIsXG4gICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICBTZW1pY29sb246ICAgICAgMTg2LFxuICAgIEVxdWFsOiAgICAgICAgICAxODcsXG4gICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICBIeXBoZW46ICAgICAgICAgMTg5LFxuICAgIERvdDogICAgICAgICAgICAxOTAsXG4gICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICBCYWNrcXVvdGU6ICAgICAgMTkyLFxuICAgIExlZnRCcmFja2V0OiAgICAyMTksXG4gICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICBSaWdodEJyYWNrZXQ6ICAgMjIxLFxuICAgIFF1b3RlOiAgICAgICAgICAyMjIsXG4gICAgQ29tbWFuZDogICAgICAgIDIyNCxcbn07XG5cblxuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvL1RPRE8gVGhpcyBzdXJlbHkgY2FuIGJlIGltcHJvdmVkIGJ5IGxldHRpbmcgd2VicGFjayB0YWtlIGNhcmUgb2YgZ2VuZXJhdGluZyB0aGlzIFVNRCBwYXJ0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbn0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbn1cbn0oJCA9PiB7XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc051bGwodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZvaWQoMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHBhcmFtZXRlciBpcyBhIFN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBib29sZWFuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgJ3RydWUnIG9yICdmYWxzZSdcbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNUcnVlT3JGYWxzZVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBsb3dlcmNhc2VWYWx1ZSA9IFN0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiByZWZlcmVuY2UgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkocmVmZXJlbmNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5XG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqKSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHRleHQgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIgaXMgdmFsaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRQYXN0ZVRleHQodGV4dCkge1xuICAgICAgICByZXR1cm4gdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGV4dFxuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZVBhc3RlZFRleHQodGV4dCwgaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBhdXRvU3RyaXAodGV4dCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUpLnJlcGxhY2UoaG9sZGVyLnNldHRpbmdzQ2xvbmUuYURlYywgJy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcbiAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvZXJjZSB0aGUgcGFyYW1ldGVycyB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIG5lZWRsZSkge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgIWlzU3RyaW5nKG5lZWRsZSkgfHwgc3RyID09PSAnJyB8fCBuZWVkbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGBuZWVkbGVgIGlzIGluIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5BcnJheShuZWVkbGUsIGFycmF5KSB7XG4gICAgICAgIGlmICghaXNBcnJheShhcnJheSkgfHwgYXJyYXkgPT09IFtdIHx8IGlzVW5kZWZpbmVkKG5lZWRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gQXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHsgLy8gTWFrZSBzdXJlIGFuIGFycmF5IGhhcyBhIGNsYXNzIGF0dHJpYnV0ZSBvZiBbb2JqZWN0IEFycmF5XVxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSB8fCAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1N0cmluZyBtZXNzYWdlIGNoYW5nZWQgZm9yIE9iamVjdCBBcnJheScpOyAvLyBWZXJpZnkgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AgZG9lcyBub3QgY2hhbmdlIGluIHRoZSBmdXR1cmUgKGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MzY1MjE1KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNEZWNpbWFscyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0LlxuICAgICAqIFJldHVybiBgbnVsbGAgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtudWxsfGludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGF0KSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge307XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBzZWxlY3QubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCAtdGhhdC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHRoYXQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSB0aGF0LnNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3Igc2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoYXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkaXNwbGF5IGEgd2FybmluZyBtZXNzYWdlcywgYWNjb3JkaW5nIHRvIHRoZSBkZWJ1ZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzdXBwcmVzc1dhcm5pbmdzIElmIFRSVUUsIHRoZW4gdGhlIHdhcm5pbmcgbWVzc2FnZSBpcyBub3QgZGlzcGxheWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCBzdXBwcmVzc1dhcm5pbmdzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHN1cHByZXNzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF1dG9OdW1lcmljLXNwZWNpZmljIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogcnVuIGNhbGxiYWNrcyBpbiBwYXJhbWV0ZXJzIGlmIGFueVxuICAgICAqIGFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrcygkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgdk1pbiB2TWF4IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpIHtcbiAgICAgICAgbGV0IHZNYXhMZW5ndGggPSAwO1xuICAgICAgICBsZXQgdk1pbkxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh2TWF4WzFdKSB7XG4gICAgICAgICAgICB2TWF4TGVuZ3RoID0gdk1heFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZNaW5bMV0pIHtcbiAgICAgICAgICAgIHZNaW5MZW5ndGggPSB2TWluWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2TWF4TGVuZ3RoLCB2TWluTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJpbmcgdXNlciBkZWZpbmVkIG9wdGlvbnMgZm9yIGZ1cnRoZXIgdXNhZ2VcbiAgICAgKiBtZXJnZSB0aGVtIHdpdGggZGVmYXVsdHMgYXBwcm9wcmlhdGVseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Db2RlKCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICAvL1RPRE8gTWVyZ2UgYGF1dG9Db2RlKClgIGludG8gYGdldEluaXRpYWxTZXR0aW5ncygpYFxuICAgICAgICBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgdk1heFswXSA9IHZNYXhbMF0ucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgdk1pblswXSA9IHZNaW5bMF0ucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KHZNYXhbMF0ubGVuZ3RoLCAxKTtcbiAgICAgICAgc2V0dGluZ3MubUludE5lZyA9IE1hdGgubWF4KHZNaW5bMF0ubGVuZ3RoLCAxKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBkZWNMZW5ndGgodk1pbiwgdk1heCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5vRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBOdW1iZXIoc2V0dGluZ3MubURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcblxuICAgICAgICAvLyBzZXQgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgPT09IG51bGwgJiYgc2V0dGluZ3MubURlYyA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLicgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJywnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLCcgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FjaGUgcmVnZXhwcyBmb3IgYXV0b1N0cmlwXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5hTmVnID9gKFstXFxcXCR7c2V0dGluZ3MuYU5lZ31dPylgIDonKC0/KSc7XG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHsoc2V0dGluZ3MuYU5lZz9gXFxcXCR7c2V0dGluZ3MuYU5lZ31gOicnKX1cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXS4qPyhcXFxcZHxcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmFEZWN9PylbXlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdXFxcXEQqJGApO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuYURlY30/KFxcXFxkK1xcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQrKXwoXFxcXGQqKD86XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCopPykpYCk7XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0cmlwIGFsbCB1bndhbnRlZCBjaGFyYWN0ZXJzIGFuZCBsZWF2ZSBvbmx5IGEgbnVtYmVyIGFsZXJ0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1N0cmlwKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2lnbiAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTaWduLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWZmaXhcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5hU3VmZml4KSkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVN1ZmZpeCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgcmVwbGFjZSBhbnl0aGluZyBiZWZvcmUgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xuXG4gICAgICAgIGlmICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIGNvbnRhaW5zKHMsICctJykgJiYgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyB0aGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGVkIGNoYXJhY3RlcnNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWx0RGVjLCBzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBvbmx5IG51bWJlciBzdHJpbmdcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcbiAgICAgICAgcyA9IG0gPyBbbVsxXSwgbVsyXSwgbVszXV0uam9pbignJykgOiAnJztcbiAgICAgICAgaWYgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5hTmVnKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5sWmVybyA9PT0gJ2RlbnknKSB8fCAoc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycgJiYgc2V0dGluZ3Mub25PZmYgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxuICAgICAgICAgICAgbGV0IHN0cmlwUmVnID0gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGQpYDtcbiAgICAgICAgICAgIHN0cmlwUmVnID0gbmV3IFJlZ0V4cChzdHJpcFJlZyk7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHN0cmlwUmVnLCAnJDEkMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxhY2VzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoKHNldHRpbmdzLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpKSB7XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm9uT2ZmICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGZpcnN0QnJhY2tldCwgc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydCBsb2NhbGUgZm9ybWF0IHRvIEphdmFzY3JpcHQgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWQgb2YgY3VycmVuY3kgc2lnbnMgYWxsb3dlZFxuICAgICAqICcxMjM0LjU2JyAgICBPS1xuICAgICAqICctMTIzNC41NicgICBPS1xuICAgICAqICcxMjM0LjU2LScgICBPS1xuICAgICAqICcxMjM0LDU2JyAgICBPS1xuICAgICAqICctMTIzNCw1NicgICBPS1xuICAgICAqICcxMjM0LDU2LScgICBPS1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Mb2NhbGUocykge1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgaWYgKGNvbnRhaW5zKHMsICctJykgJiYgcy5sYXN0SW5kZXhPZignLScpID09PSBzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICBzID0gJy0nICsgcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBJU08gbnVtZXJpYyBzdHJpbmcgdG8gdGhlIGxvY2FsZSBkZWNpbWFsIGFuZCBtaW51cyBzaWduIHBsYWNlbWVudC5cbiAgICAgKiBTZWUgdGhlIFwib3V0cHV0VHlwZVwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAoaXNOdWxsKGxvY2FsZSkgfHwgbG9jYWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4tJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgY2FzZSAnLSwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLC0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zKHJlc3VsdCwgJy0nKSA/IHJlc3VsdC5yZXBsYWNlKCctJywgJycpICsgJy0nIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2FzZVxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBjYXNlICctLic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gb3V0cHV0VHlwZSBbJHtsb2NhbGV9XSBvcHRpb24gaXMgbm90IHJlY29nbml6ZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZml4TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYURlYywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYU5lZyAhPT0gJy0nICYmIHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgZm9ybWF0dGVkIHdpdGggZGVjaW1hbHNcbiAgICAgICAgICAgIHMgKz0gJzAuMDAnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSByZWFsIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gb3VyIGZvcm1hdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICE9PSAnLScgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLmFOZWcpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5wTmVnID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYVN1ZmZpeCA6IHNldHRpbmdzLmFTaWduICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvR3JvdXAoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gYXV0b1N0cmlwKGlucHV0VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhpbnB1dFZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJy0nICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVtcHR5ID0gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IGlzTmVnID0gY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVtcHR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwID0gJyc7XG4gICAgICAgIHNldHRpbmdzLmRHcm91cCA9IHNldHRpbmdzLmRHcm91cC50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnMicpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnMnMnKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKD86XFxkezJ9KXswLDJ9XFxkezN9KD86KD86XFxkezJ9KXsyfVxcZHszfSkqPykkLztcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICc0Jykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7NH0/KSspJC87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHszfT8pKykkLztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNwbGl0cyB0aGUgc3RyaW5nIGF0IHRoZSBkZWNpbWFsIHN0cmluZ1xuICAgICAgICBsZXQgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjICYmIGlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuYVNlcCAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIHJlLWluc2VydHMgdGhlIHRob3VzYW5kIHNlcGFyYXRvciB2aWEgYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgICAgIHdoaWxlIChkaWdpdGFsR3JvdXAudGVzdChpbnRlZ2VyUGFydCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0LnJlcGxhY2UoZGlnaXRhbEdyb3VwLCBgJDEke3NldHRpbmdzLmFTZXB9JDJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjICE9PSAwICYmICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MubURlYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2hvbGUgbnVtYmVycyBvbmx5XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWcgKyBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MucFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hTmVnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hTmVnICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05lZykge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIGFuZCBwbGFjZXMgYnJhY2tldHNcbiAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIChzZXR0aW5ncy5yYXdWYWx1ZSA8IDAgfHwgaW5wdXRWYWx1ZS5jaGFyQXQoMCkgPT09ICctJykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTdWZmaXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgbm90IG5lZWRlZCB6ZXJvc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdW5kZWRJbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHJEZWNcbiAgICAgKiBAcmV0dXJucyB7dm9pZHxYTUx8c3RyaW5nfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhyb3VuZGVkSW5wdXRWYWx1ZSwgckRlYykge1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIHN3aXRjaCAockRlYykge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHVudGlsIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdCBpcyBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC4oPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIEFsbG93cyBwYWRkaW5nIHdoZW4gbURlYyBlcXVhbHMgb25lIC0gbGVhdmVzIG9uZSB6ZXJvIHRyYWlsaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC5cXGQoPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBhY2Nlc3MgemVyb3MgdG8gdGhlIG1EZWMgbGVuZ3RoIHdoZW4gYVBhZCBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcbiAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgaWYgKHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByb3VuZGVkSW5wdXRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByb3VuZCBudW1iZXIgYWZ0ZXIgc2V0dGluZyBieSBwYXN0aW5nIG9yICQoKS5hdXRvTnVtZXJpY1NldCgpXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiBmb3Igcm91bmQgdGhlIG51bWJlclxuICAgICAqIHBsZWFzZSBub3RlIHRoaXMgaGFuZGxlZCBhcyB0ZXh0IC0gSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXNcbiAgICAgKiBhbHNvIHRoaXMgb2ZmZXJzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMgdGhhdCBhcmUgbm90IGVhc2lseSBhY2NvbXBsaXNoZWQgaW4gSmF2YVNjcmlwdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdXRvUm91bmQoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHsgLy8gdmFsdWUgdG8gc3RyaW5nXG4gICAgICAgIGlucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZSA9PT0gJycpID8gJzAnIDogaW5wdXRWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubVJvdW5kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdDSEYnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnRDA1Jykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5tUm91bmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdOMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGgucm91bmQoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVMDUnOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguY2VpbChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguZmxvb3IoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCFjb250YWlucyhpbnB1dFZhbHVlLCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcuMDAnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFZhbHVlLmxlbmd0aCAtIGlucHV0VmFsdWUuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGl2Um91bmRlZCA9ICcnO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICBsZXQgckRlYztcblxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYVBhZCkge1xuICAgICAgICAgICAgckRlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByRGVjID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaW5wdXRWYWx1ZSAoaW5wdXQgVmFsdWUpIGlzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgaWYgKGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSB0byBiZSBhIGRvdClcbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlLm1hdGNoKC9eXFxkLykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnMCcgKyBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBOdW1iZXIoaW5wdXRWYWx1ZSkgPT09IDApIHtcbiAgICAgICAgICAgIG5TaWduID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltcyBsZWFkaW5nIHplcm8ncyBhcyBuZWVkZWRcbiAgICAgICAgaWYgKChOdW1iZXIoaW5wdXRWYWx1ZSkgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpbnB1dFZhbHVlLmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGlucHV0VmFsdWUubGFzdEluZGV4T2YoJy4nKTtcblxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdmRQb3MgPSAoZFBvcyA9PT0gLTEpID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZFBvcztcblxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcbiAgICAgICAgbGV0IGNEZWMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIHZkUG9zO1xuXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICBpZiAoY0RlYyA8IHJEZWMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZFBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHNldHRpbmdzLmFEZWM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHJEZWMgLSBjRGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgY29uc3Qgckxlbmd0aCA9IGRQb3MgKyBzZXR0aW5ncy5tRGVjOyAvL1RPRE8gTW9kaWZ5IGBkUG9zYCBoZXJlIGlmIGl0J3Mgbm90IGludGVuZGVkIHRoYXQgaXQgY2FuIGJlIGVxdWFsIHRvICctMSdcbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggKyAxKSk7XG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xuICAgICAgICBsZXQgaXZBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdhJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVjb25zdHJ1Y3QgdGhlIHN0cmluZywgY29udmVydGluZyBhbnkgMTAncyB0byAwJ3NcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcm91bmRlZCB2YWx1ZVxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHJEZWMpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3RlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVEZWNpbWFsKHMsIHNldHRpbmdzLCBwYXN0ZSkge1xuICAgICAgICBjb25zdCBhRGVjID0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgY29uc3QgbURlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIHMgPSAocGFzdGUgPT09ICdwYXN0ZScpID8gYXV0b1JvdW5kKHMsIHNldHRpbmdzKSA6IHM7XG5cbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgdGhlIG51bWJlciBzYXRpc2Z5IHRoZSBmb3JtYXQgY29uZGl0aW9uc1xuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqIGFuZCB0aGUgc3RyaW5nIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgdGhlIGRpZ2l0cyBpbiBzZXR0aW5ncy52TWluIGFuZCBzZXR0aW5ncy52TWF4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAoYW5kIHRoZXJlZm9yZSBpcyBhIENTUyBzZWxlY3RvciksIHRoZW4gd2UgbmVlZCB0byBtb2RpZnkgdGhpcyBzdHJpbmcgaW4gb3JkZXJcbiAgICAgICAgICogZm9yIGpRdWVyeSB0byBiZSBhYmxlIHRvIHBhcnNlIHRoZSBzZWxlY3RvciBjb3JyZWN0bHkuXG4gICAgICAgICAqIGNmLiBodHRwOi8vbGVhcm4uanF1ZXJ5LmNvbS91c2luZy1qcXVlcnktY29yZS9mYXEvaG93LWRvLWktc2VsZWN0LWFuLWVsZW1lbnQtYnktYW4taWQtdGhhdC1oYXMtY2hhcmFjdGVycy11c2VkLWluLWNzcy1ub3RhdGlvbi9cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1N0cmluZyhvYmopKSB7XG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBibG9jayBpcyBhcHBhcmVudGx5IG5ldmVyIGVudGVyZWQuIFdlIHNob3VsZCByZW1vdmUgaXQgYWZ0ZXIgbWFraW5nIHN1cmUgdGhhdCdzIDEwMCUgdGhlIGNhc2VcbiAgICAgICAgICAgIG9iaiA9IGAjJHtvYmoucmVwbGFjZSgvKDp8XFwufFxcW3xdfCx8PSkvZywgJ1xcXFwkMScpfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50IGFuZCBpbWl0YXRlIHRoZSBob2xkZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhhdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SG9sZGVyKCR0aGF0LCBzZXR0aW5ncywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGRhdGEgPSAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgICAgICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoYXQuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhvc2Ugb3JpZ2luYWwgc2V0dGluZ3MgYXJlIHVzZWQgZXhjbHVzaXZlbHkgaW4gdGhlIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hUGFkO1xuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5CcmFja2V0O1xuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmFTZXA7XG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuYVNpZ247XG4gICAgICAgIHNldHRpbmdzLm9TdWZmaXggID0gc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYyAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAqIHRha2VuIGZyb20gUXVpcmtzbW9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlYWRDb29raWUobmFtZSkge1xuICAgICAgICBjb25zdCBuYW1lRVEgPSBuYW1lICsgJz0nO1xuICAgICAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBsZXQgYyA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjID0gY2FbaV07XG4gICAgICAgICAgICB3aGlsZSAoYy5jaGFyQXQoMCkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYy5zdWJzdHJpbmcobmFtZUVRLmxlbmd0aCwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBzZXNzaW9uU3RvcmFnZSBpcyBzdXBwb3J0ZWQgLSB0YWtlbiBmcm9tIG1vZGVybml6clxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0b3JhZ2VUZXN0KCkge1xuICAgICAgICBjb25zdCBtb2QgPSAnbW9kZXJuaXpyJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShtb2QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZXMgb3IgcmVtb3ZlcyBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgdG9Ebykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JlZE5hbWUgPSAoJHRoaXNbMF0ubmFtZSAhPT0gJycgJiYgIWlzVW5kZWZpbmVkKCR0aGlzWzBdLm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoJHRoaXNbMF0ubmFtZSl9YCA6YEFVVE9fJHskdGhpc1swXS5pZH1gO1xuICAgICAgICAgICAgbGV0IGRhdGU7XG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcblxuICAgICAgICAgICAgLy8gc2V0cyBjb29raWUgZm9yIGJyb3dzZXIgdGhhdCBkbyBub3Qgc3VwcG9ydCBzZXNzaW9uU3RvcmFnZSBJRSA2ICYgSUUgN1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b0RvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0ke3NldHRpbmdzLnJhd1ZhbHVlfTsgZXhwaXJlcz0gOyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyBOb3RlIDogYHRvR01UU3RyaW5nKClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgKGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvR01UU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b0RvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHN0b3JlZE5hbWUsIHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhvbGRlciBvYmplY3QgZm9yIGZpZWxkIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aGF0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgZnVuY3Rpb24gQXV0b051bWVyaWNIb2xkZXIodGhhdCwgc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xuICAgIH1cblxuICAgIEF1dG9OdW1lcmljSG9sZGVyLnByb3RvdHlwZSA9IHtcbiAgICAgICAgaW5pdChlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgICAgICB0aGlzLmN0cmxLZXkgPSBlLmN0cmxLZXk7XG4gICAgICAgICAgICB0aGlzLmNtZEtleSA9IGUubWV0YUtleTtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xuXG4gICAgICAgICAgICAvLyBrZXlwcmVzcyBldmVudCBvdmVyd3JpdGVzIG1lYW5pbmdmdWwgdmFsdWUgb2YgZS5rZXlDb2RlXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtkQ29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMud2hpY2ggPSBlLndoaWNoO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCB0aGlzLnRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChzZXRSZWFsKSB8fCBzZXRSZWFsKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFBvc2l0aW9uKHBvcywgc2V0UmVhbCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocG9zLCBwb3MsIHNldFJlYWwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldEJlZm9yZUFmdGVyU3RyaXBlZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvZXNcbiAgICAgICAgICovXG4gICAgICAgIG5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCBzZXR0aW5nc0Nsb25lKTtcblxuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGFEZWMsXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhsZWZ0LCAnLScpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGxlZnQgPT09ICcnIHx8IGxlZnQgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgc2V0dGluZ3NDbG9uZS5sWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0ID4gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYURlYykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmFEZWN9YCkpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UobVsxXSwgbVsxXSArICcwJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIGtlZXBpbmcgcG9zaXRpb24gb2YgY3Vyc29yXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBhZHZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gYXV0b0NoZWNrKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gcGFydHNbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xuXG4gICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBhZHZlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IChjb250YWlucyh0aGlzLm5ld1ZhbHVlLCAnLCcpKSA/IHRoaXMubmV3VmFsdWUucmVwbGFjZSgnLCcsICcuJykgOiB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPT09ICcnIHx8IHRlc3RWYWx1ZSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gdGVzdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm5ld1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMubmV3VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciBleHBhbmRTZWxlY3Rpb25PblNpZ25cbiAgICAgICAgICogcmV0dXJucyBzaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzaWduUG9zaXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgYVNpZ24gPSBzZXR0aW5nc0Nsb25lLmFTaWduO1xuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcblxuICAgICAgICAgICAgaWYgKGFTaWduKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNpZ25MZW4gPSBhU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGFTaWduTGVuICsgMV0gOiBbMCwgYVNpZ25MZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBhU2lnbkxlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAgICAgKiBwcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICAgICAqL1xuICAgICAgICBleHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5zaWduUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMV0gJiYgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZW4gc2VsZWN0IHdpdGhvdXQgZW1wdHkgc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKE1hdGgubWluKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5tYXgoc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgY2hlY2tQYXN0ZSgpIHtcbiAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSBmaXJzdFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdC5zdWJzdHIoMCwgb2xkUGFydHNbMF0ubGVuZ3RoKSArIGF1dG9TdHJpcChsZWZ0LnN1YnN0cihvbGRQYXJ0c1swXS5sZW5ndGgpLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gb2xkUGFydHMuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ob2xkUGFydHNbMF0ubGVuZ3RoLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIHBhc3RpbmcsIGN1cnNvciBtb3ZpbmcgYW5kIHNraXBwaW5nIG9mIG5vdCBpbnRlcmVzdGluZyBrZXlzXG4gICAgICAgICAqIGlmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcbiAgICAgICAgICovXG4gICAgICAgIHNraXBBbHdheXMoZSkge1xuICAgICAgICAgICAgY29uc3Qga2RDb2RlID0gdGhpcy5rZENvZGU7XG4gICAgICAgICAgICBjb25zdCB3aGljaCA9IHRoaXMud2hpY2g7XG4gICAgICAgICAgICBjb25zdCBjdHJsS2V5ID0gdGhpcy5jdHJsS2V5O1xuICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gdGhpcy5jbWRLZXk7XG5cbiAgICAgICAgICAgIC8vIGNhdGNoIHRoZSBjdHJsIHVwIG9uIGN0cmwtdlxuICAgICAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xuICAgICAgICAgICAgaWYgKCgoY3RybEtleSB8fCBjbWRLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoc2hpZnRLZXkgJiYga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNraXAgRngga2V5cywgd2luZG93cyBrZXlzLCBvdGhlciBzcGVjaWFsIGtleXNcbiAgICAgICAgICAgIGlmICgoa2RDb2RlID49IGtleUNvZGUuRjEgJiYga2RDb2RlIDw9IGtleUNvZGUuRjEyKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5XaW5kb3dzICYmIGtkQ29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLlRhYiAmJiBrZENvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgICh3aGljaCA9PT0gMCB8fCB3aGljaCA9PT0ga2RDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5TY3JvbGxMb2NrIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHNlbGVjdCBhbGwgKGEpXG4gICAgICAgICAgICBpZiAoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBrZENvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gdGhpcy5zZXR0aW5ncy5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTdWZmaXhMZW4gPSB0aGlzLnNldHRpbmdzLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwU2lnbiA9IHRoaXMuc2V0dGluZ3MucFNpZ247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBOZWcgPSB0aGlzLnNldHRpbmdzLnBOZWc7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAocE5lZyA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBhU2lnbkxlbiA+IDApP2FTaWduTGVuICsgMTphU2lnbkxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIGFTdWZmaXhMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVN1ZmZpeExlbiArIGFTaWduTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IChhU2lnbkxlbiA+IDApP3ZhbHVlTGVuIC0gKGFTaWduTGVuICsgbmVnTGVuICsgYVN1ZmZpeExlbik6dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBjb3B5IChjKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgKGtkQ29kZSA9PT0ga2V5Q29kZS5jIHx8IGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS54KSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXG4gICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5nZXRCZWZvcmVBZnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCBrZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN0cmxLZXkgfHwgY21kS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVNlcCA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFEZWMgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYURlYztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEp1bXAgPSB0aGlzLnNlbGVjdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgJiYgKHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYVNlcCB8fCB2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFEZWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXJ0SnVtcCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGtkQ29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIGtkQ29kZSA8PSBrZXlDb2RlLkRvd25BcnJvdztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTdWZmaXgpICYmIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5sZW5ndGggLSBzZXR0aW5nc0Nsb25lLmFTdWZmaXgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgKyBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0WzBdID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSArIHNldHRpbmdzQ2xvbmUuYU5lZy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSAtIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJycgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCByaWdodDtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyB8fCBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zKHRoaXMudmFsdWUsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLnByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGluc2VydGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0tleXByZXNzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5tRGVjIHx8ICFzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBhTmVnIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5hRGVjLCByaWdodCwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChjQ29kZSA9PT0gJy0nIHx8IGNDb2RlID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUuYU5lZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyAhPT0gJ3AnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2Ugc2lnbiBvZiBudW1iZXIsIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRyeSB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzXG4gICAgICAgICAgICBpZiAoY0NvZGUgPj0gJzAnICYmIGNDb2RlIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgbGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudk1heCA8PSAwICYmIHNldHRpbmdzQ2xvbmUudk1pbiA8IHNldHRpbmdzQ2xvbmUudk1heCAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSAmJiBjQ29kZSAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCArIGNDb2RlLCByaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmb3JtYXR0aW5nIG9mIGp1c3QgcHJvY2Vzc2VkIHZhbHVlIHdpdGgga2VlcGluZyBvZiBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIGZvcm1hdFF1aWNrKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBsZWZ0TGVuZ3RoID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGt1Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuXG4gICAgICAgICAgICAvLyBubyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5hU2VwICA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuYVNlcCAhPT0gJycgICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmFTZXApKSkgJiZcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5hU2lnbiA9PT0gJycgfHwgKHNldHRpbmdzQ2xvbmUuYVNpZ24gIT09ICcnICYmICFjb250YWlucyhsZWZ0TGVuZ3RoLCBzZXR0aW5nc0Nsb25lLmFTaWduKSkpKSB7XG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuYURlYyk7XG4gICAgICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHN1YlBhcnRzLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBzdWJQYXJ0cyA9IHN1YlBhcnRzLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50TmVnICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnQgPSBuU2lnbiArIGxlZnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXV0b0dyb3VwKHRoaXMudmFsdWUsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHJlZ2V4cCB3aGljaCBzZWFyY2hlcyBmb3IgY3Vyc29yIHBvc2l0aW9uIGZyb20gdW5mb3JtYXR0ZWQgbGVmdCBwYXJ0XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXhlcyBjYXJldCBwb3NpdGlvbiB3aXRoIHRyYWlsaW5nIG1pbnVzIHNpZ25cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnICE9PSAncCcpKSAmJiBsZWZ0QXJbMF0gPT09ICctJyAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRBci5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnblBhcnRzID0gc2V0dGluZ3NDbG9uZS5hU2lnbi5zcGxpdCgnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXNjYXBlZFBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goc2lnblBhcnRzLCAoaSwgbWluaVBhcnRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkobWluaVBhcnRzLCBlc2NhcGVDaHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCdcXFxcJyArIG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2gobWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKCctJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goZXNjYXBlZFBhcnRzLmpvaW4oJycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xuXG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUganVzdCBiZWZvcmUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykpICYmIHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBhZnRlciBwcmVmaXggc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoICsgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzaWduIGFzIGEgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4IGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBmYWN0b3Jpc2UgdGhlIGBnZXRTdHJpbmcoKWAgYW5kIGBnZXRBcnJheSgpYCBmdW5jdGlvbnMgc2luY2UgdGhleSBzaGFyZSBxdWl0ZSBhIGxvdCBvZiBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dFR5cGVcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGdldEFycmF5QmVoYXZpb3IgLSBJZiBzZXQgdG8gVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIGJlaGF2ZSBsaWtlIGBnZXRBcnJheSgpYCwgb3RoZXJ3aXNlIGlmIHNldCB0byBGQUxTRSwgaXQgYmVoYXZlIGxpa2UgYGdldFN0cmluZygpYFxuICAgICAqIEBwYXJhbSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGF0KTtcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtRmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2V0U3RyaW5nKCkgYmVoYXZpb3JcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1QYXJ0cyA9IGZvcm1GaWVsZHMuc3BsaXQoJyYnKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2lucHV0TmFtZSwgaW5wdXRWYWx1ZV0gPSBmb3JtUGFydHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY0VsZW1lbnQgPSAkLmluQXJyYXkoaSwgc2NJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBlbGVtZW50IGlzIGEgdmFsaWQgZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkSW5wdXRWYWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNpbicgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0gaG9sZGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLm9uKCdmb2N1c2luLmF1dG9OdW1lcmljIG1vdXNlZW50ZXIuYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdmb2N1c2luJyB8fCBlLnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiAhJHRoaXMuaXMoJzpmb2N1cycpICYmICRzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAkc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKG5lZ2F0aXZlQnJhY2tldCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3MuZURlYztcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLm5TZXApIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTaWduID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU3VmZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IGF1dG9TdHJpcCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSkgIT09ICRzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIuaW5WYWwsICRzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiAkc2V0dGluZ3Mud0VtcHR5ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleWRvd24nIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHBhcmFtIGhvbGRlclxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5ZG93bigkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLm9uKCdrZXlkb3duLmF1dG9OdW1lcmljJywgZSA9PiB7XG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgaWYgKGhvbGRlci50aGF0LnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIC8vIFRoZSBjb2RlIGJlbG93IGFsbG93cyB0aGUgXCJlbnRlclwiIGtleWRvd24gdG8gdGhyb3cgYSBjaGFuZ2UoKSBldmVudFxuICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLmluVmFsICE9PSAkdGhpcy52YWwoKSkge1xuICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xuICAgICAgICAgICAgIGhvbGRlci5pblZhbCA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob2xkZXIucHJvY2Vzc0Fsd2F5cygpKSB7XG4gICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgaW4gZGVsZXRpb24gY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleXByZXNzJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXByZXNzKCR0aGlzLCBob2xkZXIpIHtcbiAgICAgICAgJHRoaXMub24oJ2tleXByZXNzLmF1dG9OdW1lcmljJywgZSA9PiB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IGZpeCBmb3IgU2hpZnQgJiYgaW5zZXJ0IHBhc3RlIGV2ZW50XG4gICAgICAgICAgICBpZiAoZS5zaGlmdEtleSAmJiBlLmtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XG4gICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcblxuICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob2xkZXIucHJvY2Vzc0Fsd2F5cygpIHx8IGhvbGRlci5wcm9jZXNzS2V5cHJlc3MoKSkge1xuICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXl1cCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcGFyYW0gaG9sZGVyXG4gICAgICogQHBhcmFtIHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXl1cCgkdGhpcywgaG9sZGVyLCBzZXR0aW5ncykge1xuICAgICAgICAkdGhpcy5vbigna2V5dXAuYXV0b051bWVyaWMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLnNraXBBbHdheXMoZSk7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBob2xkZXIua2RDb2RlO1xuICAgICAgICAgICAgaG9sZGVyLmtkQ29kZSA9IDA7XG4gICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcblxuXHRcdFx0Ly8gYWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhYiA9PT0ga2V5Q29kZS5UYWIpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsICR0aGlzLnZhbCgpLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24gIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2F2ZXMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgdG8gcHJlc2VydmUgdGhlIGRhdGEgd2hlbiBuYXZpZ2F0aW5nIGF3YXkgZnJvbSB0aGUgcGFnZVxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmVEZWMgIT09IG51bGwgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChza2lwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3Vzb3V0JyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLm9uKCdmb2N1c291dC5hdXRvTnVtZXJpYyBtb3VzZWxlYXZlLmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEkdGhpcy5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5TZXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYVNlcCA9IHNldHRpbmdzLm9TZXA7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFTaWduID0gc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFTdWZmaXggPSBzZXR0aW5ncy5vU3VmZml4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hUGFkID0gc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubkJyYWNrZXQgPSBzZXR0aW5ncy5vQnJhY2tldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSkgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gK3NldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Sb3VuZCgnMCcsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IG9yaWdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci5pblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ3Bhc3RlJyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBhc3RlKCR0aGlzLCBob2xkZXIpIHtcbiAgICAgICAgJHRoaXMub24oJ3Bhc3RlJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0Ly9GSVhNRSBBZnRlciBhIHBhc3RlLCB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSBmYXIgcmlnaHQgb2YgdGhlIGlucHV0LCBpdCBzaG91bGQgYmUgc2V0IHRvIHNvbWV0aGluZyBsaWtlIGBuZXdDYXJldFBvc2l0aW9uID0gb2xkQ2FyZXRQb3NpdGlvbiArIHBhc3RlVGV4dC5sZW5ndGg7YCwgd2hpbGUgdGFraW5nIGludG8gYWNjb3VudCB0aGUgdGhvdXNhbmQgc2VwYXJhdG9ycyBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuXG4gICAgICAgICAgICBjb25zdCBvbGRSYXdWYWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWUgfHwgJyc7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IHRoaXMuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IHRoaXMuc2VsZWN0aW9uRW5kIHx8IDA7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kLCBjdXJyZW50VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3RlZFRleHQgPSBwcmVwYXJlUGFzdGVkVGV4dChlLm9yaWdpbmFsRXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyksIGhvbGRlcik7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkUGFzdGVUZXh0KHBhc3RlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlUGFzdGVkVGV4dChwcmVmaXggKyBOdW1iZXIocGFzdGVkVGV4dCkudmFsdWVPZigpICsgc3VmZml4LCBob2xkZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXN0ZVRleHQobmV3VmFsdWUpICYmIE51bWJlcihvbGRSYXdWYWx1ZSkudmFsdWVPZigpICE9PSBOdW1iZXIobmV3VmFsdWUpLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydCA9IHNlbGVjdGlvbkVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkdGhpc1xuICAgICAqIEBwYXJhbSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy51blNldE9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGpRdWVyeSBzZWxlY3RlZCBpbnB1dCBpZiB0aGUgdGFnIGFuZCB0eXBlIGFyZSBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJHRoaXNcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKSB7XG4gICAgICAgIC8vIFN1cHBvcnRlZCBpbnB1dCB0eXBlXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgaW5wdXQgdHlwZXNcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBpbnB1dCB0eXBlIFwiJHskdGhpcy5wcm9wKCd0eXBlJyl9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIHRhZ3NcbiAgICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRUYWcgPSAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIDwke2N1cnJlbnRFbGVtZW50VGFnfT4gdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkaW5wdXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91dGluZSB0byBmb3JtYXQgdGhlIGRlZmF1bHQgdmFsdWUgb24gcGFnZSBsb2FkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gJGlucHV0XG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcykge1xuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xuXG4gICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiBgc2V0dGluZ3MuYUZvcm1gKSkuXG4gICAgICAgICAgICAgKiBOb3RlOyB0aGlzIGlzIHRydWUgd2hhdGV2ZXIgdGhlIGRldmVsb3BlciBoYXMgc2V0IGZvciBgZGF0YS1hbi1kZWZhdWx0YCBpbiB0aGUgaHRtbCAoYXNwLm5ldCB1c2VycykuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW4gb3RoZXIgd29yZHMgOiBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgYW5EZWZhdWx0YCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LFxuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgYW5EZWZhdWx0YCBhbHRvZ2V0aGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYUZvcm0gJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJ1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmFuRGVmYXVsdCAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hbkRlZmF1bHQudG9TdHJpbmcoKSAhPT0gY3VycmVudFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICEkLmlzTnVtZXJpYyhjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmVEZWMgIT09IG51bGwgJiYgc2V0dGluZ3MuYVN0b3IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLmFTdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlRGVjIHZhbHVlIHNob3VsZCBOT1QgYmUgc2F2ZWQgaW4gc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hTmVnICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gbmVnYXRpdmVCcmFja2V0KGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIHNldHRpbmdzLmFOZWcgIT09ICcnICYmIGNvbnRhaW5zKGN1cnJlbnRWYWx1ZSwgJy0nKSk/Jy0nICsgYXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzKTphdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy53RW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKHNldHRpbmdzLmFTaWduKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnemVybyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXRWYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnRleHQoKSAhPT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSAkdGhpcy50ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2UgdGhlIHVzZXIgZXhwZXJpZW5jZSBieSBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgYHBOZWdgIG9wdGlvbiBkZXBlbmRpbmcgb24gYGFTaWduYCBhbmQgYHBTaWduYC5cbiAgICAgKlxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gKGBwTmVnYCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgYVNpZ25gKSxcbiAgICAgKiB0aGVuIHdlIG1vZGlmeSB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgcE5lZ2AgaW4gb3JkZXIgdG8ga2VlcCB0aGUgcmVzdWx0aW5nIG91dHB1dCBsb2dpY2FsIGJ5IGRlZmF1bHQgOlxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2FTaWduOiBcIiRcIiwgcE5lZzogXCJyXCJ9KVxuICAgICAqIC0gXCItMSwyMzQuNTYkXCIgaW5zdGVhZCBvZiBcIjEsMjM0LjU2LSRcIiAoe2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn0pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9ucykgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMucE5lZykgJiYgb3B0aW9ucy5hU2lnbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3MucFNpZ24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucE5lZyA9ICdwJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnBOZWcgPSAncic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXG4gICAgICogTm90ZTogVGhpcyByZXR1cm5zIGBudWxsYCBpZiBzb21laG93IHRoZSBzZXR0aW5ncyByZXR1cm5lZCBieSBqUXVlcnkgaXMgbm90IGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtICR0aGlzXG4gICAgICogQHJldHVybnMge29iamVjdHxudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcykge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgXCJhdXRvTnVtZXJpY1wiIHNldHRpbmdzLiBJZiB0aGV5IGRvIG5vdCBleGlzdCwgaXQgcmV0dXJucyBcInVuZGVmaW5lZFwiLlxuICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgYW55IHNldHRpbmdzLCBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIEhUTUw1IGRhdGEsIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIHdlJ2xsIGdldCBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICBjb25zdCB0YWdEYXRhID0gJHRoaXMuZGF0YSgpO1xuXG4gICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHRhZ0RhdGEsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICBvbk9mZiAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByYXdWYWx1ZSAgICAgICAgOiAnJyxcbiAgICAgICAgICAgICAgICB0cmFpbGluZ05lZ2F0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aHJvd0lucHV0ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0cmlwICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgIDogYWxsb3dlZFRhZ0xpc3QsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXG4gICAgICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nICd0cnVlJyBhbmQgJ2ZhbHNlJyB0byByZWFsIEJvb2xlYW5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMgaW4gb3B0aW9ucyB0byBzdHJpbmdzXG4gICAgICAgICAgICAgICAgLy9UT0RPIGlmIGEgdmFsdWUgaXMgb2YgdHlwZSAnTnVtYmVyJywgc2hvdWxkbid0IHdlIGtlZXAgaXQgYXMgYSBudW1iZXIgZm9yIGZ1cnRoZXIgbWFuaXB1bGF0aW9uLCBpbnN0ZWFkIG9mIHVzaW5nIGEgc3RyaW5nP1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEltcHJvdmUgdGhlIGBwTmVnYCBvcHRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb3JyZWN0UE5lZ09wdGlvbihvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9IHNldHRpbmdzLnZNaW4gPCAwID8gJy0nIDogJyc7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgdmFsaWRhdGUoc2V0dGluZ3MsIGZhbHNlKTsgLy8gVGhyb3dzIGlmIG5lY2Vzc2FyeVxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZHMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljXG4gICAgICovXG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBpbml0aWF0ZSBhdXRvTnVtZXJpYyBhbmQgYXR0YWNoIHRoZSBzZXR0aW5ncyAob3B0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyKVxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2FTZXA6IFwiLlwiLCBhRGVjOiBcIixcIiwgYVNpZ246ICfigqwgJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcpOyAgICAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCk7ICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnLCB7b3B0aW9uc30pOyAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKHtvcHRpb25zfSk7ICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9IGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYywgc2NhbGVEaXZpc29yICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICAgICAgICAgICAga2VlcE9yaWdpbmFsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGxldCBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3QgdGhlIG5leHQgbGluZSBiZSBpbiB0aGUgYGdldEluaXRpYWxTZXR0aW5ncygpYCBmdW5jdGlvbj9cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlID09PSBmYWxzZSAmJiBzZXR0aW5ncy5hRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25Gb2N1c0luQW5kTW91c2VFbnRlcigkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IG9uS2V5ZG93bigkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25LZXlwcmVzcygkdGhpcywgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25LZXl1cCgkdGhpcywgaG9sZGVyLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IG9uUGFzdGUoJHRoaXMsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gcmVtb3ZlIHNldHRpbmdzIGFuZCBzdG9wIGF1dG9OdW1lcmljKCkgLSBkb2VzIG5vdCByZW1vdmUgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gZGVzdHJveXMgYXV0b051bWVyaWNcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnJlbW92ZURhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9mZignLmF1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciB0aGUgdmFsdWUgYW5kIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyByZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqL1xuICAgICAgICB3aXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3NcbiAgICAgICAgICogSXQgY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpZiBuZWVkZWRcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwidXBkYXRlXCIsIHtvcHRpb25zfSk7IC8vIHVwZGF0ZXMgdGhlIHNldHRpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSBhbGwgdGhpcyBkdXBsaWNhdGVkIGNvZGUgd2l0aCBhIGNhbGwgdG8gYGdldEluaXRpYWxTZXR0aW5ncygpYFxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwidXBkYXRlXCIgbWV0aG9kYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZWVwT3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgZ2V0SG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYURlYyA9PT0gc2V0dGluZ3MuYVNlcCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjOiBcIiR7c2V0dGluZ3MuYURlY31cIiBhbmQgdGhvdXNhbmQgc2VwYXJhdG9yIGFTZXA6IFwiJHtzZXR0aW5ncy5hU2VwfVwiIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXJgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJbXByb3ZlIHRoZSBgcE5lZ2Agb3B0aW9uIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCR0aGlzLnZhbCgpICE9PSAnJyB8fCAkdGhpcy50ZXh0KCkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc3RyaXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZm9ybWF0IHRoZSB2YWx1ZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJ3ZhbHVlJyk7IC8vIGZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHsqfSBuZXdWYWx1ZVxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICBzZXQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgbG9va3MgYSBsb3QgbGlrZSBgZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoKWAuIElzIHRoYXQgbmVjZXNzYXJ5PyBDYW4gdGhlIGlucHV0IGVsZW1lbnQgYmUgY2hhbmdlZCBzaW5jZSBhdXRvTnVtZXJpYyBoYXMgYmVlbiBpbml0aWFsaXplZD9cbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInNldFwiIG1ldGhvZGApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBjb21tYSAtIG5vIHRob3VzYW5kIHNlcGFyYXRvciBhbGxvd2VkXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgYmVpbmcgc2V0IGlzIG5vdCBudW1lcmljXG4gICAgICAgICAgICAgICAgaWYgKCEkLmlzTnVtZXJpYyhOdW1iZXIodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmIChzZXR0aW5ncy5lRGVjIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIG1heCByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiAhc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgPT09IG51bGwgJiYgc2V0dGluZ3Muc2NhbGVEaXZpc29yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTdG9yICYmIChzZXR0aW5ncy5lRGVjIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRlbXB0ZWRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIG9mIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLnNjYWxlU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBzZXR0aW5ncy5zY2FsZVN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dFR5cGVcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICB1blNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkdGhpcy5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gcmUtZm9ybWF0IGlucHV0cyAtIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb25cbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpOyAvLyBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXG4gICAgICAgICAqIHRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSAndW5TZXQnIG1ldGhvZCB0byByZWZvcm1hdCB0aGUgaW5wdXRcbiAgICAgICAgICovXG4gICAgICAgIHJlU2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy52YWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGVsZW1lbnQgdHlwZSB0aGVuIHVzZSAuZXEoMCkgc2VsZWN0b3IgdG8gZ3JhYiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gc2VsZWN0b3JcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc2V0dGluZ3MucmF3VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCgvXFxkLykudGVzdCh2YWx1ZSkgfHwgTnVtYmVyKHZhbHVlKSA9PT0gMCkgJiYgc2V0dGluZ3Mud0VtcHR5ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnICYmIHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZpeE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGJ1dCBmb2xsb3dpbmcgdGhlIGBvdXRwdXRUeXBlYCBzZXR0aW5nLCB3aGljaCBtZWFucyB0aGUgb3V0cHV0IGNhbiBlaXRoZXIgYmUgOlxuICAgICAgICAgKiAtIGEgc3RyaW5nICh0aGF0IGNvdWxkIG9yIGNvdWxkIG5vdCByZXByZXNlbnQgYSBudW1iZXIgKGllLiBcIjEyMzQ1LDY3LVwiKSksIG9yXG4gICAgICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXR1cm5lZCB2YWx1ZXMgYXJlIGFuIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kLlxuICAgICAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRUeXBlXCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMb2NhbGl6ZWQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICcwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRUeXBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgYXV0b051bWVyaWMgZWxlbWVudC5cbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGB0aGlzWzBdYCBleGlzdHMgYXMgd2VsbCBhcyBgLnZhbHVlYCBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGF0IHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJzAnKSB8fCAhKCd2YWx1ZScgaW4gdGhpc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgc3RyaW5nIGZyb20gdGhlIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLnZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0VHlwZVwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRUeXBlXCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KHRydWUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIHRoZSBvYmplY3Qgd2l0aCBhdXRvTnVtZXJpYyBzZXR0aW5ncyBmb3IgdGhvc2Ugd2hvIG5lZWQgdG8gbG9vayB1bmRlciB0aGUgaG9vZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJyk7IC8vIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpLmFEZWM7IC8vIHJldHVybiB0aGUgYURlYyBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW50IHZhbGlkIHNldHRpbmcgY2FuIGJlIHVzZWRcbiAgICAgICAgICovXG4gICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gJHRoaXMuZXEoMCkuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cbiAgICAgKiBJdCBpbml0aWFsaXplIGF1dG9OdW1lcmljIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XG5cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0gZGVmYXVsdFNldHRpbmdzOyAvLyBNYWtlIHRob3NlIHNldHRpbmdzIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyBmb3JtYXR0aW5nIHdpdGhvdXQgYW4gZWxlbWVudCB0cmlnZ2VyXG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgdmFsdWUgPSBmcm9tTG9jYWxlKHZhbHVlKTtcbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nOyAvL1RPRE8gUmVwbGFjZSB0aGlzIHdpdGggYGdldEluaXRpYWxTZXR0aW5ncygpYCB0aGF0IGFscmVhZHkgc2V0cyBgYU5lZ2A/XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgIGlmICghbWluVGVzdCB8fCAhbWF4VGVzdCkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBjdXN0b20gZXZlbnRcbiAgICAgICAgICAgIHNlbmRDdXN0b21FdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGBSYW5nZSB0ZXN0IGZhaWxlZGApO1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFske3ZhbHVlfV0gYmVpbmcgc2V0IGZhbGxzIG91dHNpZGUgb2YgdGhlIHZNaW4gWyR7c2V0dGluZ3Mudk1pbn1dIGFuZCB2TWF4IFske3NldHRpbmdzLnZNYXh9XSByYW5nZSBzZXQgZm9yIHRoaXMgZWxlbWVudGApO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcbiAgICAgICAgY29uc3QgYXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoYXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dFR5cGUpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvVW5mb3JtYXQgPSBhdXRvVW5Gb3JtYXQ7XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgZ2l2ZW4gb3B0aW9uIG9iamVjdC5cbiAgICAgKiBJZiB0aGUgb3B0aW9ucyBhcmUgdmFsaWQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBub3RoaW5nLCBvdGhlcndpc2UgaWYgdGhlIG9wdGlvbnMgYXJlIGludmFsaWQsIHRoaXMgZnVuY3Rpb24gdGhyb3dzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogVGhpcyB0ZXN0cyBpZiB0aGUgb3B0aW9ucyBhcmUgbm90IGNvbmZsaWN0aW5nIGFuZCBhcmUgd2VsbCBmb3JtYXR0ZWQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsZW5pZW50IHNpbmNlIGl0IG9ubHkgdGVzdHMgdGhlIHNldHRpbmdzIHByb3BlcnRpZXMgOyBpdCBpZ25vcmVzIGFueSBvdGhlciBwcm9wZXJ0aWVzIHRoZSBvcHRpb25zIG9iamVjdCBjb3VsZCBoYXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB1c2VyT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgSWYgVFJVRSwgdGhlbiB0aGlzIGZ1bmN0aW9uIHdpbGwgZXh0ZW5kcyB0aGUgYHVzZXJPcHRpb25zYCBwYXNzZWQgYnkgdGhlIHVzZXIsIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICovXG4gICAgdmFsaWRhdGUgPSAodXNlck9wdGlvbnMsIHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zID0gdHJ1ZSkgPT4ge1xuICAgICAgICBjb25zdCBkZWJ1ZyA9IHRydWU7IC8vIFRoZSBlcnJvciBoZXJlIG11c3QgYWx3YXlzIGJlIHRocm93biwgc2luY2UgYSBiYWRseSBjb25maWd1cmVkIG9wdGlvbnMgb2JqZWN0IHdpbGwgbGVhZCB0byB3cm9uZyByZXN1bHRzLCBpZiBhbnkuXG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIWlzT2JqZWN0KHVzZXJPcHRpb25zKSB8fCBpc0VtcHR5T2JqKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFTZXAsIFsnLCcsICcuJywgJyAnLCAnJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FTZXAnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJywnLCAnLicsICcgJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmFTZXB9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm5TZXApICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5uU2VwKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlICduU2VwJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMublNlcH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kR3JvdXApKSB7IC8vIGlzTmFOKHBhcnNlSW50KG9wdGlvbnMuZEdyb3VwKSkgLy9ERUJVR1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RHcm91cCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZEdyb3VwfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFEZWMsIFsnLCcsICcuJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLicgb3IgJywnLCBbJHtvcHRpb25zLmFEZWN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgY2hhcmFjdGVycyBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG9wdGlvbnMuYURlYyA9PT0gb3B0aW9ucy5hU2VwKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnYURlYycgWyR7b3B0aW9ucy5hRGVjfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2FTZXAnIFske29wdGlvbnMuYVNlcH1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFsdERlYykgJiYgIWlzU3RyaW5nKG9wdGlvbnMuYWx0RGVjKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFsdGVybmF0ZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhbHREZWMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuYWx0RGVjfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hU2lnbiAhPT0gJycgJiYgIWlzU3RyaW5nKG9wdGlvbnMuYVNpZ24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VycmVuY3kgc3ltYm9sIG9wdGlvbiAnYVNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuYVNpZ259XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucFNpZ24sIFsncCcsICdzJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAncFNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMucFNpZ259XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucE5lZywgWydwJywgJ3MnLCAnbCcsICdyJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIG9wdGlvbiAncE5lZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpLCAncycgKHN1ZmZpeCksICdsJyAobGVmdCkgb3IgJ3InIChyaWdodCksIFske29wdGlvbnMucE5lZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLmFTdWZmaXgpIHx8IChvcHRpb25zLmFTdWZmaXggIT09ICcnICYmIChjb250YWlucyhvcHRpb25zLmFTdWZmaXgsICctJykgfHwgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMudGVzdChvcHRpb25zLmFTdWZmaXgpKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhZGRpdGlvbmFsIHN1ZmZpeCBvcHRpb24gJ2FTdWZmaXgnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgbm90IGNvbnRhaW5zIHRoZSBuZWdhdGl2ZSBzaWduICctJyBub3IgYW55IG51bWVyaWNhbCBjaGFyYWN0ZXJzLCBbJHtvcHRpb25zLmFTdWZmaXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub0xpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm9MaW1pdHMsIFsnY2VpbGluZycsICdmbG9vcicsICdpZ25vcmUnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb0xpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm9MaW1pdHN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy52TWF4KSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLnZNYXgpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ3ZNYXgnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLnZNYXh9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy52TWluKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLnZNaW4pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ3ZNaW4nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLnZNaW59XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZUZsb2F0KG9wdGlvbnMudk1pbikgPiBwYXJzZUZsb2F0KG9wdGlvbnMudk1heCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ3ZNaW4nIFske29wdGlvbnMudk1pbn1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5tRGVjKSAmJiAoIWlzU3RyaW5nKG9wdGlvbnMubURlYykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLm1EZWMpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnbURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMubURlY31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFQYWQgJiYgIWlzTnVsbChvcHRpb25zLm1EZWMpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdhUGFkJyB0byBbZmFsc2VdIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ21EZWMnIHNldHRpbmcgWyR7b3B0aW9ucy5tRGVjfV0uYCwgZGVidWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV3JpdGUgYSB3YXJuaW5nIG1lc3NhZ2UgaW4gdGhlIGNvbnNvbGUgaWYgdGhlIG51bWJlciBvZiBkZWNpbWFsIGluIHZNaW4vdk1heCBpcyBvdmVycmlkZGVuIGJ5IG1EZWMgKGFuZCBub3QgaWYgbURlYyBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiB2TWluL3ZNYXgpXG4gICAgICAgIGxldCBkcFZNaW4gPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1pbik7XG4gICAgICAgIGxldCBkcFZNYXggPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1heCk7XG4gICAgICAgIGRwVk1pbiA9IGlzTnVsbChkcFZNaW4pPzA6ZHBWTWluO1xuICAgICAgICBkcFZNYXggPSBpc051bGwoZHBWTWF4KT8wOmRwVk1heDtcbiAgICAgICAgY29uc3Qgdk1pbk1heERlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChkcFZNaW4sIGRwVk1heCk7XG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubURlYykgJiZcbiAgICAgICAgICAgICgoaGFzRGVjaW1hbHMob3B0aW9ucy52TWluKSB8fCBoYXNEZWNpbWFscyhvcHRpb25zLnZNYXgpKSAmJiB2TWluTWF4RGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMubURlYykpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdtRGVjJyB0byBbJHtvcHRpb25zLm1EZWN9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAndk1pbicgWyR7b3B0aW9ucy52TWlufV0gYW5kICd2TWF4JyBbJHtvcHRpb25zLnZNYXh9XS5gLCBkZWJ1Zyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICghaXNTdHJpbmcob3B0aW9ucy5lRGVjKSB8fCAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZURlYykpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbnVtYmVyIG9mIGV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZURlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZURlY31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyBcImVEZWNcIiBpcyBncmVhdGVyIHRoYW4gdGhlIG5vcm1hbCBkZWNpbWFsIHBsYWNlcyBcIm1EZWNcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICFpc051bGwob3B0aW9ucy5tRGVjKSAmJiBOdW1iZXIob3B0aW9ucy5tRGVjKSA8IE51bWJlcihvcHRpb25zLmVEZWMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZURlYycgWyR7b3B0aW9ucy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSAnbURlYycgWyR7b3B0aW9ucy5tRGVjfV0gdmFsdWUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGl2aXNvcikgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgZGl2aXNvciBvcHRpb24gJ3NjYWxlRGl2aXNvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlciwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGl2aXNvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWwpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWwpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWx9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hU3RvcikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFTdG9yKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnYVN0b3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFTdG9yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLm1Sb3VuZCwgW1xuICAgICAgICAgICAgJ1MnLFxuICAgICAgICAgICAgJ0EnLFxuICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgJ0InLFxuICAgICAgICAgICAgJ1UnLFxuICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgJ0MnLFxuICAgICAgICAgICAgJ0YnLFxuICAgICAgICAgICAgJ04wNScsXG4gICAgICAgICAgICAnQ0hGJyxcbiAgICAgICAgICAgICdVMDUnLFxuICAgICAgICAgICAgJ0QwNScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcm91bmRpbmcgbWV0aG9kIG9wdGlvbiAnbVJvdW5kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMubVJvdW5kfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hUGFkKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVBhZCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FQYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFQYWR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubkJyYWNrZXQpICYmICFpc0luQXJyYXkob3B0aW9ucy5uQnJhY2tldCwgWycoLCknLCAnWyxdJywgJzwsPicsICd7LH0nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbkJyYWNrZXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicgb3IgJ3ssfScsIFske29wdGlvbnMubkJyYWNrZXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMud0VtcHR5LCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICd3RW1wdHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy53RW1wdHl9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubFplcm8sIFsnYWxsb3cnLCAnZGVueScsICdrZWVwJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbGVhZGluZyB6ZXJvIGJlaGF2aW9yIG9wdGlvbiAnbFplcm8nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdhbGxvdycsICdkZW55JyBvciAna2VlcCcsIFske29wdGlvbnMubFplcm99XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFGb3JtKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYUZvcm0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnYUZvcm0nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFGb3JtfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zTnVtYmVyKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc051bWJlcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzZWxlY3QgbnVtYmVyIG9ubHkgb3B0aW9uICdzTnVtYmVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5zTnVtYmVyfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFuRGVmYXVsdCkgJiYgKG9wdGlvbnMuYW5EZWZhdWx0ICE9PSAnJyAmJiAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLmFuRGVmYXVsdCkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2FuRGVmYXVsdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuYW5EZWZhdWx0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy51blNldE9uU3VibWl0KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMudW5TZXRPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByZW1vdmUgZm9ybWF0dGluZyBvbiBzdWJtaXQgb3B0aW9uICd1blNldE9uU3VibWl0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51blNldE9uU3VibWl0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm91dHB1dFR5cGUpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdXRwdXRUeXBlLCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dFR5cGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIG51bGwsICdzdHJpbmcnLCAnbnVtYmVyJywgJy4nLCAnLS4nLCAnLCcsICctLCcsICcuLScgb3IgJywtJywgWyR7b3B0aW9ucy5vdXRwdXRUeXBlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5kZWJ1ZykgJiYgIWlzQm9vbGVhbihvcHRpb25zLmRlYnVnKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZGVidWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmRlYnVnfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudC5cbiAgICAgKiBjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIHN0cmluZ1xuICAgICAqIEBwYXJhbSBkZXRhaWxcbiAgICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjdXN0b20gZXZlbnQgYW5kIGltbWVkaWF0ZWx5IGJyb2FkY2FzdCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNlbmRDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3JlYXRlQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkZXRhaWwpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgKElFKVxuICAgICAqL1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7IGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgZGV0YWlsOiB2b2lkKDApIH07XG4gICAgICAgICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSwgcGFyYW1zLmRldGFpbCk7XG4gICAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgQ3VzdG9tRXZlbnQucHJvdG90eXBlID0gd2luZG93LkV2ZW50LnByb3RvdHlwZTtcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XG4gICAgfSkoKTtcbn0pKTtcblxuLyoqXG4gKiBUaGlzIGV4cG9ydHMgdGhlIGludGVyZmFjZSBmb3IgdGhlIGF1dG9OdW1lcmljIG9iamVjdFxuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgZm9ybWF0ICA6IGF1dG9Gb3JtYXQsXG4gICAgdW5Gb3JtYXQ6IGF1dG9VbkZvcm1hdCxcbiAgICBnZXREZWZhdWx0Q29uZmlnLFxuICAgIHZhbGlkYXRlLCAvLyBhbi52YWxpZGF0ZShvcHRpb25zKSA6IHRocm93cyBpZiBuZWNlc3NhcnlcbiAgICBhcmVTZXR0aW5nc1ZhbGlkLCAvL2FuLmFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgOiByZXR1cm4gdHJ1ZSBvciBmYWxzZSAvL1RPRE8gSXMgdGhpcyByZWR1bmRhbnQ/IFNob3VsZCB3ZSBsZXQgdGhlIGRldmVsb3BlcnMgd3JhcCBlYWNoIGF1dG9OdW1lcmljLnZhbGlkYXRlKCkgY2FsbHMgaW4gdHJ5L2NhdGNoIGJsb2NrPyBPciBzaG91bGQgd2UganVzdCBmYWNpbGl0YXRlIHRoZWlyIGxpZmUgYnkgZG9pbmcgaXQgYWxyZWFkeT9cblxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxuICAgIC8vaW5pdCAgICAgICAgIDogYW4uaW5pdChvcHRpb25zLCBpbnB1dClcbiAgICAvL2dldCAgICAgICAgICA6IGFuLmdldChpbnB1dClcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXG4gICAgLy9mb3JtU3RyaW5nICAgOiBhbi5mb3JtU3RyaW5nKGZvcm0pXG4gICAgLy9mb3JtQXJyYXkgICAgOiBhbi5mb3JtQXJyYXkoZm9ybSlcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcbiAgICAvL3Vuc2V0ICAgICAgICA6IGFuLnVuc2V0KGlucHV0KSAvL3RvIHJlbmFtZSB0byAndW5mb3JtYXQnPyAoYW5kIG1lcmdlIHdpdGggYXV0b1VuRm9ybWF0L3VuRm9ybWF0PylcbiAgICAvL3JlZm9ybWF0ICAgICA6IGFuLnJlZm9ybWF0KGlucHV0KSAvLyAncmVTZXQnIGlzIHZlcnkgdG8gY2xvc2UgdG8gJ3Jlc2V0JyBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSByZW5hbWVkLiBXZSBjb3VsZCBzdGlsbCBleHBvc2UgJ3JlU2V0JywgYnV0IGFkZCBhIEBkZXByZWNhdGVkIHRhZyBvbiBpdHMgZGVjbGFyYXRpb24uXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcbiAgICAvL3VwZGF0ZSAgICAgICA6IGFuLnVwZGF0ZShvcHRpb25zLCBpbnB1dClcbiAgICAvL3dpcGUgICAgICAgICA6IGFuLndpcGUoaW5wdXQpXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9hdXRvTnVtZXJpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;