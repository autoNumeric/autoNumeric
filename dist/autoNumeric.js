(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n* autoNumeric.js\r\n* @author: Bob Knothe\r\n* @contributors: Sokolov Yura and other Github users\r\n* @version: 2.0 - 2016-12-01 UTC 5:00\r\n*\r\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\r\n*\r\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\r\n*\r\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\r\n*\r\n* Permission is hereby granted, free of charge, to any person\r\n* obtaining a copy of this software and associated documentation\r\n* files (the \"Software\"), to deal in the Software without\r\n* restriction, including without limitation the rights to use,\r\n* copy, modify, merge, publish, distribute, sub license, and/or sell\r\n* copies of the Software, and to permit persons to whom the\r\n* Software is furnished to do so, subject to the following\r\n* conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be\r\n* included in all copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\n* OTHER DEALINGS IN THE SOFTWARE.\r\n*/\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\r\n * List of allowed tag on which autoNumeric can be used.\r\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\r\n * Defaults options are public - these can be overridden by the following:\r\n * - HTML5 data attributes\r\n * - Options passed by the 'init' or 'update' methods\r\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\r\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\r\n     * comma = \",\"\r\n     * period \"full stop\" = \".\"\r\n     * apostrophe is escaped = \"\\\"\"\r\n     * space = \" \"\r\n     * none = \"\"\r\n     * NOTE: do not use numeric characters\r\n     */\n    aSep: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\r\n     * example if the input value \"$ 1,999.88 suffix\"\r\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\r\n     */\n    nSep: false,\n\n    /* Digital grouping for the thousand separator used in Format\r\n     * dGroup: \"2\", results in 99,99,99,999 India's lakhs\r\n     * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\r\n     * dGroup: \"3\", results in 999,999,999 default\r\n     * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\r\n     */\n    dGroup: '3',\n\n    /* Allowed decimal separator characters\r\n     * period \"full stop\" = \".\"\r\n     * comma = \",\"\r\n     */\n    aDec: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by aDec\r\n     * developed for countries the use a comma \",\" as the decimal character\r\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\r\n     */\n    altDec: null,\n\n    /* aSign = allowed currency symbol\r\n     * Must be in quotes aSign: \"$\"\r\n     * space to the right of the currency symbol aSign: '$ '\r\n     * space to the left of the currency symbol aSign: ' $'\r\n     */\n    aSign: '',\n\n    /* pSign = placement of currency sign as a p=prefix or s=suffix\r\n     * for prefix pSign: \"p\" (default)\r\n     * for suffix pSign: \"s\"\r\n     */\n    pSign: 'p',\n\n    /* Placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\r\n     * -1,234.56  => default no options required\r\n     * -$1,234.56 => {aSign: \"$\"}\r\n     * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\r\n     * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\r\n     * 1,234.56-  => {pNeg: \"s\"}\r\n     * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\r\n     * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\r\n     * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\r\n     */\n    pNeg: 'l',\n\n    /* Additional suffix\r\n     * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\r\n     * Numeric characters and negative sign not allowed'\r\n     */\n    aSuffix: '',\n\n    /* Override min max limits\r\n     * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\r\n     * oLimits: \"floor\" adheres to vMin and ignores vMax settings\r\n     * oLimits: \"ignore\" ignores both vMin & vMax\r\n     */\n    oLimits: null,\n\n    /* Maximum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be larger than vMin\r\n     */\n    vMax: '9999999999999.99',\n\n    /* Minimum possible value\r\n     * value must be enclosed in quotes and use the period for the decimal point\r\n     * value must be smaller than vMax\r\n     */\n    vMin: '-9999999999999.99',\n\n    /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\r\n     * value must be enclosed in quotes example mDec: \"3\",\r\n     */\n    mDec: null,\n\n    /* Expanded decimal places visible when input has focus - example:\r\n     * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\r\n     * the \"get\" method returns the extended decimal places\r\n     */\n    eDec: null,\n\n    /* The next three options (scaleDivisor, scaleDecimal & scaleSymbol) handle scaling of the input when the input does not have focus\r\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"aStor\" option to ensure retaining the value\r\n     * [\"divisor\", \"decimal places\", \"symbol\"]\r\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimal: '1', scaleSymbol: ' K'}\r\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\r\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\r\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\r\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\r\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\r\n     */\n    scaleDivisor: null,\n\n    /*\r\n     * The `scaleDecimal` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\r\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\r\n     */\n    scaleDecimal: null,\n\n    /*\r\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\r\n     * This is optional too.\r\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the eDec value to be saved with sessionStorage\r\n     * if ie 6 or 7 the value will be saved as a session cookie\r\n     */\n    aStor: false,\n\n    /* method used for rounding\r\n     * mRound: \"S\", Round-Half-Up Symmetric (default)\r\n     * mRound: \"A\", Round-Half-Up Asymmetric\r\n     * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\r\n     * mRound: \"a\", Round-Half-Down Asymmetric (lower case a)\r\n     * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\r\n     * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\r\n     * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\r\n     * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\r\n     * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\r\n     * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\r\n     * mRound: \"U05\" Rounds up to next .05\r\n     * mRound: \"D05\" Rounds down to next .05\r\n     */\n    mRound: 'S',\n\n    /* Controls decimal padding\r\n     * aPad: true - always Pad decimals with zeros\r\n     * aPad: false - does not pad with zeros.\r\n     * Note: setting aPad to 'false' will override the 'mDec' setting.\r\n     *\r\n     * thanks to Jonas Johansson for the suggestion\r\n     */\n    aPad: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\r\n     * Those brackets are visible only when the field does NOT have the focus.\r\n     * The left and right symbols should be enclosed in quotes and separated by a comma\r\n     * nBracket: null - (default)\r\n     * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\r\n     */\n    nBracket: null,\n\n    /* Displayed on empty string \"\"\r\n     * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\r\n     * wEmpty: \"press\" - currency sign displays on any key being pressed\r\n     * wEmpty: \"always\" - always displays the currency sign only\r\n     * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\r\n     */\n    //TODO Add an option to display the currency sign only on hover (if the input is empty)\n    wEmpty: 'focus',\n\n    /* Controls leading zero behavior\r\n     * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\r\n     * lZero: \"deny\", - allows only one leading zero on values less than one\r\n     * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\r\n     */\n    lZero: 'allow',\n\n    /* Determine if the default value will be formatted on initialization.\r\n     * true = automatically formats the default value on initialization\r\n     * false = will not format the default value\r\n     */\n    aForm: true,\n\n    /* Determine if the select all keyboard command will select\r\n     * the complete input text or only the input numeric value\r\n     * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\r\n     */\n    sNumber: false,\n\n    /* Helper option for ASP.NET postback\r\n     * should be the value of the unformatted default value\r\n     * examples:\r\n     * no default value=\"\" {anDefault: \"\"}\r\n     * value=1234.56 {anDefault: '1234.56'}\r\n     */\n    anDefault: null,\n\n    /* Removes formatting on submit event\r\n     * this output format: positive nnnn.nn, negative -nnnn.nn\r\n     * review the 'unSet' method for other formats\r\n     */\n    unSetOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\r\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\r\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\r\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\r\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\r\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\r\n     */\n    outputType: null,\n\n    /* Error handling function\r\n     * true => all errors are thrown - helpful in site development\r\n     * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\r\n     */\n    debug: false\n};\n\n/**\r\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\r\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\r\n     * Return TRUE if the `value` is null\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\r\n     * Return TRUE if the `value` is undefined, null or empty\r\n     *\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\r\n     * Return TRUE if the given parameter is a String\r\n     *\r\n     * @param {*} str\r\n     * @returns {boolean}\r\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a boolean\r\n     *\r\n     * @static\r\n     * @param {*} value\r\n     * @returns {boolean}\r\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string 'true' or 'false'\r\n     *\r\n     * This function accepts any cases for those strings.\r\n     * @param value\r\n     * @returns {boolean}\r\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an object\r\n     *\r\n     * @param {*} reference\r\n     * @returns {boolean}\r\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\r\n     * Return TRUE if the given object is empty\r\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\r\n     *\r\n     * @param obj\r\n     * @returns {boolean}\r\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\r\n     * Return TRUE if the text given as a parameter is valid.\r\n     *\r\n     * @param text\r\n     * @returns {boolean}\r\n     */\n    function isValidPasteText(text) {\n        return text !== '' && !isNaN(text);\n    }\n\n    /**\r\n     * Return the pasted text that will be used.\r\n     *\r\n     * @param text\r\n     * @param holder\r\n     * @returns {string|void|XML|*}\r\n     */\n    function preparePastedText(text, holder) {\n        return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n    }\n\n    /**\r\n     * Return TRUE is the string `str` contains the string `needle`\r\n     * Note: this function does not coerce the parameters types\r\n     *\r\n     * @param {string} str\r\n     * @param {string} needle\r\n     * @returns {boolean}\r\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the `needle` is in the array\r\n     *\r\n     * @param {Array} array\r\n     * @param {*} needle\r\n     * @returns {boolean}\r\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\r\n     * Return TRUE if the parameter is an Array\r\n     *\r\n     * @param {*} arr\r\n     * @throws Error\r\n     * @returns {*|boolean}\r\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\r\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\r\n     *\r\n     * @param {string} str\r\n     * @returns {boolean}\r\n     */\n    function hasDecimals(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        return !isUndefined(decimalPart);\n    }\n\n    /**\r\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\r\n     * Return `null` otherwise.\r\n     *\r\n     * @param {string} str\r\n     * @returns {null|int}\r\n     */\n    function decimalPlaces(str) {\n        var _str$split3 = str.split('.'),\n            _str$split4 = _slicedToArray(_str$split3, 2),\n            decimalPart = _str$split4[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Cross browser routine for getting selected range/cursor position\r\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\r\n     * Cross browser routine for setting selected range/cursor position\r\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\r\n     * Function that throw error messages\r\n     *\r\n     * @param {string} message\r\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\r\n     * Function that display a warning messages, according to the debug level.\r\n     *\r\n     * @param {string} message\r\n     * @param {boolean} suppressWarnings If TRUE, then the warning message is not displayed\r\n     */\n    function warning(message) {\n        var suppressWarnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (suppressWarnings) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\r\n     * run callbacks in parameters if any\r\n     * any parameter could be a callback:\r\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\r\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\r\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\r\n     * Determine the decimal length from the vMin vMax settings\r\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\r\n     * Preparing user defined options for further usage\r\n     * merge them with defaults appropriately\r\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n\n        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\r\n     * strip all unwanted characters and leave only a number alert\r\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Places or removes brackets on negative values\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * convert locale format to Javascript numeric string\r\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\r\n     * '1234.56'    OK\r\n     * '-1234.56'   OK\r\n     * '1234.56-'   OK\r\n     * '1234,56'    OK\r\n     * '-1234,56'   OK\r\n     * '1234,56-'   OK\r\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\r\n     * See the \"outputType\" option definition for more details.\r\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputType [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Prepare number string to be converted to real number\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function fixNumber(s, settings) {\n        if (settings.aDec !== '.') {\n            s = s.replace(settings.aDec, '.');\n        }\n        if (settings.aNeg !== '-') {\n            s = s.replace(settings.aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Prepare real number to be converted to our format\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Private function to check for empty value\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @param {boolean} signOnEmpty\r\n     * @returns {*}\r\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? inputValue + settings.aSign + settings.aSuffix : settings.aSign + inputValue + settings.aSuffix;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Private function that formats our number\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function autoGroup(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = autoStrip(inputValue, settings);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNeg = contains(inputValue, '-');\n        if (isNeg) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (empty !== null) {\n            return empty;\n        }\n\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.aDec),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.altDec);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            inputValue = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            inputValue = integerPart;\n        }\n\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = settings.aNeg + settings.aSign + inputValue;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = settings.aSign + settings.aNeg + inputValue;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                inputValue = settings.aSign + inputValue + settings.aNeg;\n            }\n            if (!isNeg) {\n                inputValue = settings.aSign + inputValue;\n            }\n        }\n\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                inputValue = inputValue + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                inputValue = inputValue + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                inputValue = settings.aNeg + inputValue + settings.aSign;\n            }\n            if (!isNeg) {\n                inputValue = inputValue + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = negativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.aSuffix;\n    }\n\n    /**\r\n     * Truncate not needed zeros\r\n     *\r\n     * @param {string} roundedInputValue\r\n     * @param rDec\r\n     * @returns {void|XML|string|*}\r\n     */\n    function truncateZeros(roundedInputValue, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when mDec equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the mDec length when aPad is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (rDec === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\r\n     * round number after setting by pasting or $().autoNumericSet()\r\n     * private function for round the number\r\n     * please note this handled as text - JavaScript math function can return inaccurate values\r\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\r\n     *\r\n     * @param {string} inputValue\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function autoRound(inputValue, settings) {\n        // value to string\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        // sets the truncate zero method\n        if (settings.aPad) {\n            rDec = settings.mDec;\n        } else {\n            rDec = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.lZero !== 'keep' || inputValue.length > 0 && settings.lZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n\n        // Virtual decimal position\n        var vdPos = dPos === -1 ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.mDec) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.mRound === 'S' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\r\n     * Truncates the decimal part of a number\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @param {string} paste\r\n     * @returns {*}\r\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\r\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\r\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\r\n     * Many thanks to Mike\r\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\r\n     * Function to test if the input value falls with the Min / Max settings\r\n     * This uses the parsed strings for the above parseStr function\r\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\r\n     * Many thanks to Mike\r\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\r\n     * Check that the number satisfy the format conditions\r\n     * and lays between settings.vMin and settings.vMax\r\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\r\n     *\r\n     * @param {string} s\r\n     * @param {object} settings\r\n     * @returns {*}\r\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\r\n     * thanks to Anthony & Evan C\r\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\r\n     * Function to attach data to the element and imitate the holder\r\n     *\r\n     * @param $that\r\n     * @param {object} settings\r\n     * @param {boolean} update\r\n     * @returns {*}\r\n     */\n    function getHolder($that, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\r\n     * Original settings saved for use when eDec & nSep options are being used.\r\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\r\n     *\r\n     * @param {object} settings\r\n     */\n    function keepOriginalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n        settings.oSuffix = settings.aSuffix;\n    }\n\n    /**\r\n     * original settings saved for use when eDec & nSep options are being used\r\n     * taken from Quirksmode\r\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\r\n     * Test if sessionStorage is supported - taken from modernizr\r\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\r\n     * creates or removes sessionStorage or cookie depending on browser support\r\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\r\n     * Holder object for field properties\r\n     *\r\n     * @param that\r\n     * @param {object} settings\r\n     * @constructor\r\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * strip parts from excess characters and leading zeroes\r\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * set part of number to value keeping position of cursor\r\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\r\n         * helper function for expandSelectionOnSign\r\n         * returns sign position of a formatted value\r\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\r\n         * expands selection to cover whole sign\r\n         * prevents partial deletion/copying/overwriting of a sign\r\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\r\n         * try to strip pasted value to digits\r\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\r\n         * process pasting, cursor moving and skipping of not interesting keys\r\n         * if returns true, further processing is not performed\r\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\r\n         * process deletion of characters when the minus sign is to the right of the numeric characters\r\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '';\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length;\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '';\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\r\n         * process deletion of characters\r\n         * returns true if processing performed\r\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\r\n         * process insertion of characters\r\n         * returns true if processing performed\r\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\r\n         * formatting of just processed value with keeping of cursor position\r\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = e.type === 'keydown';\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = e.type === 'keydown';\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\r\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\r\n     *\r\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n     *\r\n     * It then loops through the string and un-formats the inputs with autoNumeric.\r\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\r\n     *\r\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\r\n     * @param that - A reference to the current DOM element\r\n     * @returns {*}\r\n     * @private\r\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\r\n     * Handler for 'focusin' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onFocusInAndMouseEnter($this, holder) {\n        $this.on('focusin.autoNumeric mouseenter.autoNumeric', function (e) {\n            holder = getHolder($this);\n            var $settings = holder.settingsClone;\n            if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && $settings.wEmpty === 'focus') {\n                $settings.onOff = true;\n\n                if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                    $this.val(negativeBracket($this.val(), $settings));\n                }\n\n                var result = void 0;\n                if ($settings.eDec) {\n                    $settings.mDec = $settings.eDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.scaleDivisor) {\n                    $settings.mDec = $settings.oDec;\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ($settings.nSep) {\n                    $settings.aSep = '';\n                    $settings.aSign = '';\n                    $settings.aSuffix = '';\n                    $this.autoNumeric('set', $settings.rawValue);\n                } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                    $this.autoNumeric('set', result);\n                }\n\n                holder.inVal = $this.val();\n                holder.lastVal = holder.inVal;\n                var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                    $this.val(onEmpty);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'keydown' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onKeydown($this, holder) {\n        $this.on('keydown.autoNumeric', function (e) {\n            holder = getHolder($this);\n            if (holder.that.readOnly) {\n                holder.processed = true;\n\n                return true;\n            }\n            /* // The code below allows the \"enter\" keydown to throw a change() event\r\n             if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\r\n             $this.change();\r\n             holder.inVal = $this.val();\r\n             } */\n            holder.init(e);\n            if (holder.skipAlways(e)) {\n                holder.processed = true;\n\n                return true;\n            }\n            if (holder.processAlways()) {\n                holder.processed = true;\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event in deletion character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return false;\n            }\n            holder.formatted = false;\n\n            return true;\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'keypress' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onKeypress($this, holder) {\n        $this.on('keypress.autoNumeric', function (e) {\n            // Firefox fix for Shift && insert paste event\n            if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                return;\n            }\n            holder = getHolder($this);\n            var processed = holder.processed;\n            holder.init(e);\n\n            if (holder.skipAlways(e)) {\n                return true;\n            }\n\n            if (processed) {\n                e.preventDefault();\n\n                return false;\n            }\n\n            if (holder.processAlways() || holder.processKeypress()) {\n                holder.formatQuick(e);\n                var currentValue = $this.val();\n                if (currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                    // throws input event on adding character\n                    $this.trigger('input');\n                }\n                holder.lastVal = currentValue;\n                holder.settingsClone.throwInput = true;\n                e.preventDefault();\n\n                return;\n            }\n            holder.formatted = false;\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'keyup' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @param settings\r\n     * @returns {*}\r\n     */\n    function onKeyup($this, holder, settings) {\n        $this.on('keyup.autoNumeric', function (e) {\n            holder = getHolder($this);\n            holder.init(e);\n            var skip = holder.skipAlways(e);\n            var tab = holder.kdCode;\n            holder.kdCode = 0;\n            delete holder.valuePartsBeforePaste;\n\n            // added to properly place the caret when only the currency sign is present\n            if ($this[0].value === holder.settingsClone.aSign) {\n                if (holder.settingsClone.pSign === 's') {\n                    setElementSelection(this, 0, 0);\n                } else {\n                    setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                }\n            } else if (tab === keyCode.Tab) {\n                setElementSelection(this, 0, $this.val().length);\n            }\n\n            if ($this[0].value === holder.settingsClone.aSuffix) {\n                setElementSelection(this, 0, 0);\n            }\n\n            if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                setElementSelection(this, 0, 0);\n            }\n\n            // saves the extended decimal to preserve the data when navigating away from the page\n            if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                autoSave($this, settings, 'set');\n            }\n            if (skip) {\n                return true;\n            }\n            if (this.value === '') {\n                return true;\n            }\n            if (!holder.formatted) {\n                holder.formatQuick(e);\n            }\n        });\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'focusout' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onFocusOutAndMouseLeave($this, holder) {\n        $this.on('focusout.autoNumeric mouseleave.autoNumeric', function () {\n            if (!$this.is(':focus')) {\n                holder = getHolder($this);\n                var value = $this.val();\n                var origValue = value;\n                var settings = holder.settingsClone;\n                settings.onOff = false;\n                if (settings.aStor) {\n                    autoSave($this, settings, 'set');\n                }\n\n                if (settings.nSep === true) {\n                    settings.aSep = settings.oSep;\n                    settings.aSign = settings.oSign;\n                    settings.aSuffix = settings.oSuffix;\n                }\n\n                if (settings.eDec !== null) {\n                    settings.mDec = settings.oDec;\n                    settings.aPad = settings.oPad;\n                    settings.nBracket = settings.oBracket;\n                }\n\n                value = autoStrip(value, settings);\n                if (value !== '') {\n                    if (settings.trailingNegative) {\n                        value = '-' + value;\n                        settings.trailingNegative = false;\n                    }\n\n                    var _autoCheck3 = autoCheck(value, settings),\n                        _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                        minTest = _autoCheck4[0],\n                        maxTest = _autoCheck4[1];\n\n                    if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                        value = fixNumber(value, settings);\n                        settings.rawValue = value;\n\n                        if (settings.scaleDivisor) {\n                            value = value / settings.scaleDivisor;\n                            value = value.toString();\n                        }\n\n                        settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? +settings.scaleDecimal : settings.mDec;\n                        value = autoRound(value, settings);\n                        value = presentNumber(value, settings);\n                    } else {\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        value = settings.rawValue;\n                    }\n                } else {\n                    if (settings.wEmpty === 'zero') {\n                        settings.rawValue = '0';\n                        value = autoRound('0', settings);\n                    } else {\n                        settings.rawValue = '';\n                    }\n                }\n\n                var groupedValue = checkEmpty(value, settings, false);\n                if (groupedValue === null) {\n                    groupedValue = autoGroup(value, settings);\n                }\n\n                if (groupedValue !== origValue) {\n                    groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                    $this.val(groupedValue);\n                }\n\n                if (groupedValue !== holder.inVal) {\n                    $this.change();\n                    delete holder.inVal;\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'paste' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onPaste($this, holder) {\n        $this.on('paste', function (e) {\n            //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n            e.preventDefault();\n            holder = getHolder($this);\n\n            var oldRawValue = $this.autoNumeric('get');\n            var currentValue = this.value || '';\n            var selectionStart = this.selectionStart || 0;\n            var selectionEnd = this.selectionEnd || 0;\n            var prefix = currentValue.substring(0, selectionStart);\n            var suffix = currentValue.substring(selectionEnd, currentValue.length);\n            var pastedText = preparePastedText(e.originalEvent.clipboardData.getData('text/plain').holder);\n\n            if (isValidPasteText(pastedText)) {\n                var newValue = preparePastedText(prefix + Number(pastedText).valueOf() + suffix, holder);\n\n                if (isValidPasteText(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                    $this.autoNumeric('set', newValue);\n                    $this.trigger('input');\n                }\n            } else {\n                this.selectionStart = selectionEnd;\n            }\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Handler for 'submit' events\r\n     *\r\n     * @param $this\r\n     * @param holder\r\n     * @returns {*}\r\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            holder = getHolder($this);\n\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unSetOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n\n        return holder;\n    }\n\n    /**\r\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\r\n     *\r\n     * @param $this\r\n     * @returns {boolean|*}\r\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\r\n     * Routine to format the default value on page load\r\n     *\r\n     * @param settings\r\n     * @param $input\r\n     * @param $this\r\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\r\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\r\n             * precedence and should get formatted on init (if this input value is a valid number and that the\r\n             * developer wants it formatted on init (cf. `settings.aForm`)).\r\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\r\n             *\r\n             * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\r\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\r\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\r\n             * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\r\n             * we should ignore `anDefault` altogether.\r\n             */\n            if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\r\n                 * - page reload from back button, and\r\n                 * - ASP.net form post back\r\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\r\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\r\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.eDec !== null && settings.aStor || settings.scaleDivisor && settings.aStor) {\n                        settings.rawValue = autoSave($this, settings, 'get');\n                    }\n\n                    // If the eDec value should NOT be saved in sessionStorage\n                    if (!settings.aStor) {\n                        var toStrip = void 0;\n\n                        if (settings.nBracket !== null && settings.aNeg !== '') {\n                            settings.onOff = true;\n                            toStrip = negativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.wEmpty) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.aSign);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.anDefault !== null) {\n                if (settings.anDefault === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\r\n     * Enhance the user experience by modifying the default `pNeg` option depending on `aSign` and `pSign`.\r\n     *\r\n     * If the user has not set the placement of the negative sign (`pNeg`), but has set a currency symbol (`aSign`),\r\n     * then we modify the default value of `pNeg` in order to keep the resulting output logical by default :\r\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({aSign: \"$\", pNeg: \"r\"})\r\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({aSign: \"$\", pSign: \"s\", pNeg: \"p\"})\r\n     *\r\n     * @param {object} options\r\n     * @param {object} settings\r\n     */\n    function correctPNegOption(options, settings) {\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.pNeg) && options.aSign !== '') {\n            switch (settings.pSign) {\n                case 's':\n                    settings.pNeg = 'p';\n                    break;\n                case 'p':\n                    settings.pNeg = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\r\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\r\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\r\n     *\r\n     * @param options\r\n     * @param $this\r\n     * @returns {object|null}\r\n     */\n    function getInitialSettings(options, $this) {\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n            // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n            var tagData = $this.data();\n\n            settings = $.extend({}, defaultSettings, tagData, options, {\n                onOff: false,\n                runOnce: false,\n                rawValue: '',\n                trailingNegative: false,\n                caretFix: false,\n                throwInput: true,\n                strip: true,\n                tagList: allowedTagList\n            });\n\n            // Modify the user settings to make them 'exploitable'\n            $.each(settings, function (key, value) {\n                // Convert the string 'true' and 'false' to real Boolean\n                if (value === 'true' || value === 'false') {\n                    settings[key] = value === 'true';\n                }\n\n                // Convert numbers in options to strings\n                //TODO if a value is of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n                if (typeof value === 'number' && key !== 'aScale') {\n                    settings[key] = value.toString();\n                }\n            });\n\n            // Improve the `pNeg` option if needed\n            correctPNegOption(options, settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\r\n     * Methods supported by autoNumeric\r\n     */\n    var methods = {\n        /**\r\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\r\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\r\n         *\r\n         * @example\r\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\r\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\r\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\r\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // original settings saved for use when eDec, scaleDivisor & nSep options are being used\n                keepOriginalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                //TODO Shouldn't the next line be in the `getInitialSettings()` function?\n                settings.mDec = settings.scaleDivisor && settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n\n                if (settings.runOnce === false && settings.aForm) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    holder = onFocusInAndMouseEnter($this, holder);\n                    holder = onFocusOutAndMouseLeave($this, holder);\n                    holder = onKeydown($this, holder);\n                    holder = onKeypress($this, holder);\n                    holder = onKeyup($this, holder, settings);\n                    holder = onPaste($this, holder);\n                    onSubmit($this, holder);\n                }\n            });\n        },\n\n\n        /**\r\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\r\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\r\n         * no parameters accepted\r\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\r\n         * method to clear the value and sessionStorage or cookie depending on browser supports\r\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\r\n         * no parameters accepted\r\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\r\n         * Method that updates the autoNumeric settings\r\n         * It can be called multiple times if needed\r\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\r\n         *\r\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\r\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                //TODO Replace all this duplicated code with a call to `getInitialSettings()`\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method');\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.scaleDivisor) {\n                    settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                }\n                keepOriginalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character');\n                }\n\n                // Improve the `pNeg` option if needed\n                correctPNegOption(options, settings);\n\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\r\n         * Method to format the value passed as a parameter.\r\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\r\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\r\n         * and must contain only numbers and one decimal (period) character\r\n         *\r\n         * @param {*} newValue\r\n         * @returns {*|jQuery}\r\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.eDec || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal ? settings.scaleDecimal : settings.mDec;\n                            }\n\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n\n                        if (settings.aStor && (settings.eDec || settings.scaleDivisor)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\r\n         * method to un-format inputs - handy to use right before form submission\r\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\r\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputType\" for more details\r\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\r\n         * method to re-format inputs - handy to use right after form submission\r\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\r\n         * this is called after the 'unSet' method to reformat the input\r\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\r\n         * Return the unformatted value as a string.\r\n         *\r\n         * @usage $(someSelector).autoNumeric('get');\r\n         *\r\n         * @returns {string}\r\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = autoGet(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.eDec || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\r\n         * Returns the unformatted value, but following the `outputType` setting, which means the output can either be :\r\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\r\n         * - a plain number (if the setting 'number' is used).\r\n         *\r\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\r\n         * Check the \"outputType\" option definition for more details.\r\n         *\r\n         * @returns {*}\r\n         */\n        getLocalized: function getLocalized() {\n            var $this = autoGet(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputType);\n        },\n\n\n        /**\r\n         * Return the current formatted value of the autoNumeric element.\r\n         * @usage aNInput.autoNumeric('getFormatted'))\r\n         *\r\n         * @returns {string}\r\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\r\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\r\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\r\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\r\n         *\r\n         * It then loops through the string and un-formats the inputs with autoNumeric.\r\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\r\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputType\" for details\r\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\r\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\r\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\r\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\r\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet(this);\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\r\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\r\n     * It initialize autoNumeric on the given element.\r\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\r\n     * Return the default autoNumeric settings.\r\n     *\r\n     * @return {object}\r\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\r\n     * Public function that allows formatting without an element trigger\r\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside of the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] range set for this element');\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\r\n     * Public function that allows unformatting without an element\r\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputType);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\r\n     * Validate the given option object.\r\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\r\n     *\r\n     * This tests if the options are not conflicting and are well formatted.\r\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\r\n     *\r\n     * @param {*} userOptions\r\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\r\n     * @throws Error\r\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        var debug = true; // The error here must always be thrown, since a badly configured options object will lead to wrong results, if any.\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.aSep, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'aSep\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.aSep + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.nSep) && !isBoolean(options.nSep)) {\n            throwError('The \\'nSep\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.nSep + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.dGroup)) {\n            // isNaN(parseInt(options.dGroup)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'dGroup\\' is invalid ; it should be a positive integer, [' + options.dGroup + '] given.');\n        }\n\n        if (!isInArray(options.aDec, [',', '.'])) {\n            throwError('The decimal separator character option \\'aDec\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.aDec + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.aDec === options.aSep) {\n            throwError('autoNumeric will not function properly when the decimal character \\'aDec\\' [' + options.aDec + '] and the thousand separator \\'aSep\\' [' + options.aSep + '] are the same character.');\n        }\n\n        if (!isNull(options.altDec) && !isString(options.altDec)) {\n            throwError('The alternate decimal separator character option \\'altDec\\' is invalid ; it should be a string, [' + options.altDec + '] given.');\n        }\n\n        if (options.aSign !== '' && !isString(options.aSign)) {\n            throwError('The currency symbol option \\'aSign\\' is invalid ; it should be a string, [' + options.aSign + '] given.');\n        }\n\n        if (!isInArray(options.pSign, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'pSign\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.pSign + '] given.');\n        }\n\n        if (!isInArray(options.pNeg, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'pNeg\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.pNeg + '] given.');\n        }\n\n        if (!isString(options.aSuffix) || options.aSuffix !== '' && (contains(options.aSuffix, '-') || testNumericalCharacters.test(options.aSuffix))) {\n            throwError('The additional suffix option \\'aSuffix\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.aSuffix + '] given.');\n        }\n\n        if (!isNull(options.oLimits) && !isInArray(options.oLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'oLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.oLimits + '] given.');\n        }\n\n        if (!isString(options.vMax) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMax)) {\n            throwError('The maximum possible value option \\'vMax\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMax + '] given.');\n        }\n\n        if (!isString(options.vMin) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.vMin)) {\n            throwError('The minimum possible value option \\'vMin\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.vMin + '] given.');\n        }\n\n        if (parseFloat(options.vMin) > parseFloat(options.vMax)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'vMin\\' [' + options.vMin + '] should be smaller than \\'vMax\\' [' + options.vMax + '].');\n        }\n\n        if (!isNull(options.mDec) && (!isString(options.mDec) || !testPositiveInteger.test(options.mDec))) {\n            throwError('The maximum number of decimal places option \\'mDec\\' is invalid ; it should be a positive integer, [' + options.mDec + '] given.');\n        }\n\n        if (!options.aPad && !isNull(options.mDec)) {\n            warning('Setting \\'aPad\\' to [false] will override the current \\'mDec\\' setting [' + options.mDec + '].', debug);\n        }\n\n        // Write a warning message in the console if the number of decimal in vMin/vMax is overridden by mDec (and not if mDec is equal to the number of decimal used in vMin/vMax)\n        var dpVMin = decimalPlaces(options.vMin);\n        var dpVMax = decimalPlaces(options.vMax);\n        dpVMin = isNull(dpVMin) ? 0 : dpVMin;\n        dpVMax = isNull(dpVMax) ? 0 : dpVMax;\n        var vMinMaxDecimalPlaces = Math.max(dpVMin, dpVMax);\n        if (!isNull(options.mDec) && (hasDecimals(options.vMin) || hasDecimals(options.vMax)) && vMinMaxDecimalPlaces !== Number(options.mDec)) {\n            warning('Setting \\'mDec\\' to [' + options.mDec + '] will override the decimals declared in \\'vMin\\' [' + options.vMin + '] and \\'vMax\\' [' + options.vMax + '].', debug);\n        }\n\n        if (!isNull(options.eDec) && (!isString(options.eDec) || !testPositiveInteger.test(options.eDec))) {\n            throwError('The number of expanded decimal places option \\'eDec\\' is invalid ; it should be a positive integer, [' + options.eDec + '] given.');\n        }\n\n        // Checks if the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n        if (!isNull(options.eDec) && !isNull(options.mDec) && Number(options.mDec) < Number(options.eDec)) {\n            throwError('autoNumeric will not function properly when the extended decimal places \\'eDec\\' [' + options.eDec + '] is greater than the \\'mDec\\' [' + options.mDec + '] value.');\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimal) && !testPositiveInteger.test(options.scaleDecimal)) {\n            throwError('The scale number of decimals option \\'scaleDecimal\\' is invalid ; it should be a positive integer, [' + options.scaleDecimal + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aStor) && !isBoolean(options.aStor)) {\n            throwError('The save to session storage option \\'aStor\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aStor + '] given.');\n        }\n\n        if (!isInArray(options.mRound, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'mRound\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.mRound + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aPad) && !isBoolean(options.aPad)) {\n            throwError('The control decimal padding option \\'aPad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aPad + '] given.');\n        }\n\n        if (!isNull(options.nBracket) && !isInArray(options.nBracket, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'nBracket\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.nBracket + '] given.');\n        }\n\n        if (!isInArray(options.wEmpty, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'wEmpty\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.wEmpty + '] given.');\n        }\n\n        if (!isInArray(options.lZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'lZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.lZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.aForm) && !isBoolean(options.aForm)) {\n            throwError('The format on initialization option \\'aForm\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.aForm + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.sNumber) && !isBoolean(options.sNumber)) {\n            throwError('The select number only option \\'sNumber\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.sNumber + '] given.');\n        }\n\n        if (!isNull(options.anDefault) && options.anDefault !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.anDefault)) {\n            throwError('The unformatted default value option \\'anDefault\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.anDefault + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unSetOnSubmit) && !isBoolean(options.unSetOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unSetOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unSetOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputType) && !isInArray(options.outputType, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputType\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputType + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.debug) && !isBoolean(options.debug)) {\n            throwError('The debug option \\'debug\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.debug + '] given.');\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\r\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\r\n     *\r\n     * @param {object} options\r\n     * @returns {boolean}\r\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\r\n     * Create a custom event.\r\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\r\n     *\r\n     * @param eventName string\r\n     * @param detail\r\n     * @returns {CustomEvent}\r\n     */\n    function createCustomEvent(eventName, detail) {\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\r\n     * Create a custom event and immediately broadcast it.\r\n     *\r\n     * @param eventName string\r\n     * @param detail\r\n     * @returns {boolean}\r\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\r\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\r\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\r\n * This exports the interface for the autoNumeric object\r\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9ib2Jrbi9Eb2N1bWVudHMvR2l0SHViL2F1dG9OdW1lcmljL3NyYy9hdXRvTnVtZXJpYy5qcz81OTRhIl0sIm5hbWVzIjpbImF1dG9Gb3JtYXQiLCJhdXRvVW5Gb3JtYXQiLCJnZXREZWZhdWx0Q29uZmlnIiwidmFsaWRhdGUiLCJhcmVTZXR0aW5nc1ZhbGlkIiwiYWxsb3dlZFRhZ0xpc3QiLCJkZWZhdWx0U2V0dGluZ3MiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGl2aXNvciIsInNjYWxlRGVjaW1hbCIsInNjYWxlU3ltYm9sIiwiYVN0b3IiLCJtUm91bmQiLCJhUGFkIiwibkJyYWNrZXQiLCJ3RW1wdHkiLCJsWmVybyIsImFGb3JtIiwic051bWJlciIsImFuRGVmYXVsdCIsInVuU2V0T25TdWJtaXQiLCJvdXRwdXRUeXBlIiwiZGVidWciLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZUJyZWFrIiwiQ2Fwc0xvY2siLCJFc2MiLCJTcGFjZSIsIlBhZ2VVcCIsIlBhZ2VEb3duIiwiRW5kIiwiSG9tZSIsIkxlZnRBcnJvdyIsIlVwQXJyb3ciLCJSaWdodEFycm93IiwiRG93bkFycm93IiwiSW5zZXJ0IiwiRGVsZXRlIiwibnVtMCIsIm51bTEiLCJudW0yIiwibnVtMyIsIm51bTQiLCJudW01IiwibnVtNiIsIm51bTciLCJudW04IiwibnVtOSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiV2luZG93cyIsIlJpZ2h0Q2xpY2siLCJudW1wYWQwIiwibnVtcGFkMSIsIm51bXBhZDIiLCJudW1wYWQzIiwibnVtcGFkNCIsIm51bXBhZDUiLCJudW1wYWQ2IiwibnVtcGFkNyIsIm51bXBhZDgiLCJudW1wYWQ5IiwiTXVsdGlwbHlOdW1wYWQiLCJQbHVzTnVtcGFkIiwiTWludXNOdW1wYWQiLCJEb3ROdW1wYWQiLCJTbGFzaE51bXBhZCIsIkYxIiwiRjIiLCJGMyIsIkY0IiwiRjUiLCJGNiIsIkY3IiwiRjgiLCJGOSIsIkYxMCIsIkYxMSIsIkYxMiIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiTXlDb21wdXRlciIsIk15Q2FsY3VsYXRvciIsIlNlbWljb2xvbiIsIkVxdWFsIiwiQ29tbWEiLCJIeXBoZW4iLCJEb3QiLCJTbGFzaCIsIkJhY2txdW90ZSIsIkxlZnRCcmFja2V0IiwiQmFja3NsYXNoIiwiUmlnaHRCcmFja2V0IiwiUXVvdGUiLCJDb21tYW5kIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwid2luZG93IiwialF1ZXJ5IiwiaXNOdWxsIiwidmFsdWUiLCJpc1VuZGVmaW5lZCIsImlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSIsImlzU3RyaW5nIiwic3RyIiwiU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNUcnVlT3JGYWxzZVN0cmluZyIsImxvd2VyY2FzZVZhbHVlIiwidG9Mb3dlckNhc2UiLCJpc09iamVjdCIsInJlZmVyZW5jZSIsIkFycmF5IiwiaXNBcnJheSIsImlzRW1wdHlPYmoiLCJvYmoiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJpc1ZhbGlkUGFzdGVUZXh0IiwidGV4dCIsImlzTmFOIiwicHJlcGFyZVBhc3RlZFRleHQiLCJob2xkZXIiLCJhdXRvU3RyaXAiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJoYXNEZWNpbWFscyIsInNwbGl0IiwiZGVjaW1hbFBhcnQiLCJkZWNpbWFsUGxhY2VzIiwibGVuZ3RoIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzdXBwcmVzc1dhcm5pbmdzIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3MiLCIkdGhpcyIsInNldHRpbmdzIiwiJCIsImVhY2giLCJ2YWwiLCJhdXRvTnVtZXJpYyIsImRlY0xlbmd0aCIsInZNYXhMZW5ndGgiLCJ2TWluTGVuZ3RoIiwiTWF0aCIsIm1heCIsImF1dG9Db2RlIiwiYU5lZyIsIm1JbnRQb3MiLCJtSW50TmVnIiwib0RlYyIsIk51bWJlciIsImFOZWdSZWciLCJhTmVnUmVnQXV0b1N0cmlwIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwiUmVnRXhwIiwic2tpcExhc3RBdXRvU3RyaXAiLCJhbGxvd2VkIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm51bVJlZ0F1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJtYXRjaCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsImNoYXJBdCIsInNsaWNlIiwib25PZmYiLCJzdHJpcFJlZyIsIm5lZ2F0aXZlQnJhY2tldCIsImZpcnN0QnJhY2tldCIsImxhc3RCcmFja2V0IiwiZnJvbUxvY2FsZSIsImxhc3RJbmRleE9mIiwidG9Mb2NhbGUiLCJsb2NhbGUiLCJyZXN1bHQiLCJmaXhOdW1iZXIiLCJwcmVzZW50TnVtYmVyIiwiY2hlY2tFbXB0eSIsImlucHV0VmFsdWUiLCJzaWduT25FbXB0eSIsImF1dG9Hcm91cCIsInN0cmlwIiwiZW1wdHkiLCJpc05lZyIsImRpZ2l0YWxHcm91cCIsInRlc3QiLCJzdWJzdHJpbmciLCJyYXdWYWx1ZSIsInRydW5jYXRlWmVyb3MiLCJyb3VuZGVkSW5wdXRWYWx1ZSIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwiaXZSb3VuZGVkIiwiZFBvcyIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJwYXN0ZSIsIm1vZGlmaWVkRGVjaW1hbFBhcnQiLCJwYXJzZVN0ciIsIm5MIiwic2VhcmNoIiwidGVzdE1pbk1heCIsInhjIiwieWMiLCJ4TmVnIiwiYXV0b0NoZWNrIiwibWluUGFyc2UiLCJtYXhQYXJzZSIsInZhbFBhcnNlIiwiYXV0b0dldCIsImdldEhvbGRlciIsIiR0aGF0IiwidXBkYXRlIiwiZGF0YSIsIkF1dG9OdW1lcmljSG9sZGVyIiwiZ2V0Iiwia2VlcE9yaWdpbmFsU2V0dGluZ3MiLCJvUGFkIiwib0JyYWNrZXQiLCJvU2VwIiwib1NpZ24iLCJvU3VmZml4IiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImF1dG9TYXZlIiwidG9EbyIsInN0b3JlZE5hbWUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZCIsImRhdGUiLCJleHBpcmVzIiwiRGF0ZSIsInNldFRpbWUiLCJnZXRUaW1lIiwidG9VVENTdHJpbmciLCJnZXRJdGVtIiwiZm9ybWF0dGVkIiwiaW5pdCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwid2hpY2giLCJwcm9jZXNzZWQiLCJzZXRTZWxlY3Rpb24iLCJzZXRSZWFsIiwibWluIiwic2V0UG9zaXRpb24iLCJwb3MiLCJnZXRCZWZvcmVBZnRlciIsImxlZnQiLCJyaWdodCIsImdldEJlZm9yZUFmdGVyU3RyaXBlZCIsIm5vcm1hbGl6ZVBhcnRzIiwibmV3VmFsdWUiLCJzZXRWYWx1ZVBhcnRzIiwiYWR2ZW50IiwicGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsInRyaWdnZXIiLCJzaWduUG9zaXRpb24iLCJhU2lnbkxlbiIsImhhc05lZyIsInZhbHVlTGVuIiwiZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2hlY2tQYXN0ZSIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsInN1YnN0ciIsInNraXBBbHdheXMiLCJwcmV2ZW50RGVmYXVsdCIsIm5lZ0xlbiIsImFTdWZmaXhMZW4iLCJzdGFydEp1bXAiLCJwcm9jZXNzVHJhaWxpbmciLCJjYXJldEZpeCIsInByb2Nlc3NBbHdheXMiLCJ0aHJvd0lucHV0IiwicHJvY2Vzc0tleXByZXNzIiwiY0NvZGUiLCJmcm9tQ2hhckNvZGUiLCJmb3JtYXRRdWljayIsImxlZnRMZW5ndGgiLCJrdUNvZGUiLCJzdWJQYXJ0cyIsImxlZnRBciIsInNoaWZ0IiwicHVzaCIsInNpZ25QYXJ0cyIsImVzY2FwZUNociIsImVzY2FwZWRQYXJ0cyIsIm1pbmlQYXJ0cyIsImxlZnRSZWciLCJuZXdMZWZ0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiaW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwiaW5BcnJheSIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJvbiIsIiRzZXR0aW5ncyIsImlzIiwiaW5WYWwiLCJsYXN0VmFsIiwib25FbXB0eSIsIm9uS2V5ZG93biIsInJlYWRPbmx5IiwiY3VycmVudFZhbHVlIiwib25LZXlwcmVzcyIsIm9uS2V5dXAiLCJza2lwIiwidGFiIiwib25Gb2N1c091dEFuZE1vdXNlTGVhdmUiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJvblBhc3RlIiwib2xkUmF3VmFsdWUiLCJwcmVmaXgiLCJzdWZmaXgiLCJwYXN0ZWRUZXh0Iiwib3JpZ2luYWxFdmVudCIsImNsaXBib2FyZERhdGEiLCJnZXREYXRhIiwidmFsdWVPZiIsIm9uU3VibWl0IiwiY2xvc2VzdCIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJhdHRyIiwidGVzdGVkQ3VycmVudFZhbHVlIiwicGFyc2VGbG9hdCIsIkluZmluaXR5IiwiaXNOdW1lcmljIiwidG9TdHJpcCIsInRhZ0xpc3QiLCJjb3JyZWN0UE5lZ09wdGlvbiIsIm9wdGlvbnMiLCJnZXRJbml0aWFsU2V0dGluZ3MiLCJ0YWdEYXRhIiwiZXh0ZW5kIiwicnVuT25jZSIsImtleSIsIm1ldGhvZHMiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJmbiIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwic2VuZEN1c3RvbUV2ZW50IiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJkcFZNaW4iLCJkcFZNYXgiLCJ2TWluTWF4RGVjaW1hbFBsYWNlcyIsImlzVmFsaWQiLCJlcnJvciIsImNyZWF0ZUN1c3RvbUV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsInBhcmFtcyIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiRXZlbnQiLCJmb3JtYXQiLCJ1bkZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0E7O0FBRUE7QUFDQSxJQUFJQSxtQkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMseUJBQUo7QUFDQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBO0FBQ0E7OztBQUdBLElBQU1DLGlCQUFpQixDQUNuQixHQURtQixFQUVuQixTQUZtQixFQUduQixNQUhtQixFQUluQixNQUptQixFQUtuQixPQUxtQixFQU1uQixJQU5tQixFQU9uQixLQVBtQixFQVFuQixLQVJtQixFQVNuQixLQVRtQixFQVVuQixJQVZtQixFQVduQixJQVhtQixFQVluQixJQVptQixFQWFuQixJQWJtQixFQWNuQixJQWRtQixFQWVuQixJQWZtQixFQWdCbkIsSUFoQm1CLEVBaUJuQixJQWpCbUIsRUFrQm5CLEtBbEJtQixFQW1CbkIsS0FuQm1CLEVBb0JuQixPQXBCbUIsRUFxQm5CLElBckJtQixFQXNCbkIsUUF0Qm1C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LE1BQTVCLEVBQW9DO0FBQ2hDQSxxQkFBU0EsVUFBVSxFQUFFSixTQUFTLEtBQVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNTyxNQUFNL1QsU0FBU2dVLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBRCxnQkFBSUUsZUFBSixDQUFvQkosS0FBcEIsRUFBMkJDLE9BQU9KLE9BQWxDLEVBQTJDSSxPQUFPSCxVQUFsRCxFQUE4REcsT0FBT04sTUFBckU7QUFDQSxtQkFBT08sR0FBUDtBQUNIOztBQUVETixvQkFBWXhVLFNBQVosR0FBd0JwQyxPQUFPcVgsS0FBUCxDQUFhalYsU0FBckM7QUFDQXBDLGVBQU80VyxXQUFQLEdBQXFCQSxXQUFyQjtBQUNILEtBZEQ7QUFlSCxDQXRrR0EsQ0FBRDs7QUF3a0dBOzs7a0JBR2U7QUFDWFUsWUFBVXJnQixVQURDO0FBRVhzZ0IsY0FBVXJnQixZQUZDO0FBR1hDLHNDQUhXO0FBSVhDLHNCQUpXLEVBSUQ7QUFDVkMsc0NBTFcsRSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiogYXV0b051bWVyaWMuanNcclxuKiBAYXV0aG9yOiBCb2IgS25vdGhlXHJcbiogQGNvbnRyaWJ1dG9yczogU29rb2xvdiBZdXJhIGFuZCBvdGhlciBHaXRodWIgdXNlcnNcclxuKiBAdmVyc2lvbjogMi4wIC0gMjAxNi0xMi0wMSBVVEMgNTowMFxyXG4qXHJcbiogQ3JlYXRlZCBieSBSb2JlcnQgSi4gS25vdGhlIG9uIDIwMDktMDgtMDkuIFBsZWFzZSByZXBvcnQgYW55IGJ1Z3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL0JvYktub3RoZS9hdXRvTnVtZXJpY1xyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDA5IFJvYmVydCBKLiBLbm90aGUgaHR0cDovL3d3dy5kZWNvcnBsYW5pdC5jb20vcGx1Z2luL1xyXG4qXHJcbiogVGhlIE1JVCBMaWNlbnNlIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcclxuKlxyXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXHJcbiogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cclxuKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcclxuKiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWIgbGljZW5zZSwgYW5kL29yIHNlbGxcclxuKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcclxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xyXG4qIGNvbmRpdGlvbnM6XHJcbipcclxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4qIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG4qXHJcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuKiBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxyXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXHJcbiogSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbiogV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXHJcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxyXG4qIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuKi9cclxuXHJcbi8qIGdsb2JhbCBtb2R1bGUsIHJlcXVpcmUsIGRlZmluZSAqL1xyXG5cclxuLy8gRnVuY3Rpb25zIG5hbWVzIGZvciBFUzYgZXhwb3J0c1xyXG5sZXQgYXV0b0Zvcm1hdDtcclxubGV0IGF1dG9VbkZvcm1hdDtcclxubGV0IGdldERlZmF1bHRDb25maWc7XHJcbmxldCB2YWxpZGF0ZTtcclxubGV0IGFyZVNldHRpbmdzVmFsaWQ7XHJcblxyXG4vLyBBdXRvTnVtZXJpYyBkZWZhdWx0IHNldHRpbmdzXHJcbi8qKlxyXG4gKiBMaXN0IG9mIGFsbG93ZWQgdGFnIG9uIHdoaWNoIGF1dG9OdW1lcmljIGNhbiBiZSB1c2VkLlxyXG4gKi9cclxuY29uc3QgYWxsb3dlZFRhZ0xpc3QgPSBbXHJcbiAgICAnYicsXHJcbiAgICAnY2FwdGlvbicsXHJcbiAgICAnY2l0ZScsXHJcbiAgICAnY29kZScsXHJcbiAgICAnY29uc3QnLFxyXG4gICAgJ2RkJyxcclxuICAgICdkZWwnLFxyXG4gICAgJ2RpdicsXHJcbiAgICAnZGZuJyxcclxuICAgICdkdCcsXHJcbiAgICAnZW0nLFxyXG4gICAgJ2gxJyxcclxuICAgICdoMicsXHJcbiAgICAnaDMnLFxyXG4gICAgJ2g0JyxcclxuICAgICdoNScsXHJcbiAgICAnaDYnLFxyXG4gICAgJ2lucycsXHJcbiAgICAna2RiJyxcclxuICAgICdsYWJlbCcsXHJcbiAgICAnbGknLFxyXG4gICAgJ29wdGlvbicsXHJcbiAgICAnb3V0cHV0JyxcclxuICAgICdwJyxcclxuICAgICdxJyxcclxuICAgICdzJyxcclxuICAgICdzYW1wbGUnLFxyXG4gICAgJ3NwYW4nLFxyXG4gICAgJ3N0cm9uZycsXHJcbiAgICAndGQnLFxyXG4gICAgJ3RoJyxcclxuICAgICd1JyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxyXG4gKiAtIEhUTUw1IGRhdGEgYXR0cmlidXRlc1xyXG4gKiAtIE9wdGlvbnMgcGFzc2VkIGJ5IHRoZSAnaW5pdCcgb3IgJ3VwZGF0ZScgbWV0aG9kc1xyXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcclxuICovXHJcbmNvbnN0IGRlZmF1bHRTZXR0aW5ncyA9IHtcclxuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcclxuICAgICAqIGNvbW1hID0gXCIsXCJcclxuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcclxuICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXHJcbiAgICAgKiBzcGFjZSA9IFwiIFwiXHJcbiAgICAgKiBub25lID0gXCJcIlxyXG4gICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcclxuICAgICAqL1xyXG4gICAgYVNlcDogJywnLFxyXG5cclxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxyXG4gICAgICogZXhhbXBsZSBpZiB0aGUgaW5wdXQgdmFsdWUgXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiXHJcbiAgICAgKiBvbiBcImZvY3VzaW5cIiBpdCBiZWNvbWVzIFwiMTk5OS44OFwiIGFuZCBiYWNrIHRvIFwiJCAxLDk5OS44OCBzdWZmaXhcIiBvbiBmb2N1cyBvdXQuXHJcbiAgICAgKi9cclxuICAgIG5TZXA6IGZhbHNlLFxyXG5cclxuICAgIC8qIERpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcclxuICAgICAqIGRHcm91cDogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcclxuICAgICAqIGRHcm91cDogXCIyc1wiLCByZXN1bHRzIGluIDk5LDk5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtocyBzY2FsZWRcclxuICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxyXG4gICAgICogZEdyb3VwOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXHJcbiAgICAgKi9cclxuICAgIGRHcm91cDogJzMnLFxyXG5cclxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xyXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxyXG4gICAgICogY29tbWEgPSBcIixcIlxyXG4gICAgICovXHJcbiAgICBhRGVjOiAnLicsXHJcblxyXG4gICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGFEZWNcclxuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAqIGFuZCBoYXZlIGtleWJvYXJkc1xcbnVtZXJpYyBwYWRzIHRoYXQgaGF2ZSBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJzIChTcGFpbiBpcyBhbiBleGFtcGxlKVxyXG4gICAgICovXHJcbiAgICBhbHREZWM6IG51bGwsXHJcblxyXG4gICAgLyogYVNpZ24gPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxyXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXHJcbiAgICAgKiBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyQgJ1xyXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBhU2lnbjogJyAkJ1xyXG4gICAgICovXHJcbiAgICBhU2lnbjogJycsXHJcblxyXG4gICAgLyogcFNpZ24gPSBwbGFjZW1lbnQgb2YgY3VycmVuY3kgc2lnbiBhcyBhIHA9cHJlZml4IG9yIHM9c3VmZml4XHJcbiAgICAgKiBmb3IgcHJlZml4IHBTaWduOiBcInBcIiAoZGVmYXVsdClcclxuICAgICAqIGZvciBzdWZmaXggcFNpZ246IFwic1wiXHJcbiAgICAgKi9cclxuICAgIHBTaWduOiAncCcsXHJcblxyXG4gICAgLyogUGxhY2VtZW50IG9mIG5lZ2F0aXZlIHNpZ24gcmVsYXRpdmUgdG8gdGhlIGFTaWduIG9wdGlvbiBsPWxlZnQsIHI9cmlnaHQsIHA9cHJlZml4ICYgcz1zdWZmaXhcclxuICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXHJcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCJ9XHJcbiAgICAgKiAkLTEsMjM0LjU2ID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwiclwifVxyXG4gICAgICogLTEsMjM0LjU2JCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCIsIHBOZWc6IFwicFwifVxyXG4gICAgICogMSwyMzQuNTYtICA9PiB7cE5lZzogXCJzXCJ9XHJcbiAgICAgKiAkMSwyMzQuNTYtID0+IHthU2lnbjogXCIkXCIsIHBOZWc6IFwic1wifVxyXG4gICAgICogMSwyMzQuNTYtJCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCJ9XHJcbiAgICAgKiAxLDIzNC41NiQtID0+IHthU2lnbjogXCIkXCIsIHBTaWduOiBcInNcIiwgcE5lZzogXCJyXCJ9XHJcbiAgICAgKi9cclxuICAgIHBOZWc6ICdsJyxcclxuXHJcbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxyXG4gICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVN1ZmZpeDogJ2dyb3NzJywgYSBzcGFjZSBpcyBhbGxvd2VkIGFTdWZmaXg6ICcgZG9sbGFycydcclxuICAgICAqIE51bWVyaWMgY2hhcmFjdGVycyBhbmQgbmVnYXRpdmUgc2lnbiBub3QgYWxsb3dlZCdcclxuICAgICAqL1xyXG4gICAgYVN1ZmZpeDogJycsXHJcblxyXG4gICAgLyogT3ZlcnJpZGUgbWluIG1heCBsaW1pdHNcclxuICAgICAqIG9MaW1pdHM6IFwiY2VpbGluZ1wiIGFkaGVyZXMgdG8gdk1heCBhbmQgaWdub3JlcyB2TWluIHNldHRpbmdzXHJcbiAgICAgKiBvTGltaXRzOiBcImZsb29yXCIgYWRoZXJlcyB0byB2TWluIGFuZCBpZ25vcmVzIHZNYXggc2V0dGluZ3NcclxuICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XHJcbiAgICAgKi9cclxuICAgIG9MaW1pdHM6IG51bGwsXHJcblxyXG4gICAgLyogTWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxyXG4gICAgICogdmFsdWUgbXVzdCBiZSBsYXJnZXIgdGhhbiB2TWluXHJcbiAgICAgKi9cclxuICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcclxuXHJcbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBhbmQgdXNlIHRoZSBwZXJpb2QgZm9yIHRoZSBkZWNpbWFsIHBvaW50XHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIHNtYWxsZXIgdGhhbiB2TWF4XHJcbiAgICAgKi9cclxuICAgIHZNaW46ICctOTk5OTk5OTk5OTk5OS45OScsXHJcblxyXG4gICAgLyogTWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgPSB1c2VkIHRvIG92ZXJyaWRlIGRlY2ltYWwgcGxhY2VzIHNldCBieSB0aGUgdk1pbiAmIHZNYXggdmFsdWVzXHJcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGVuY2xvc2VkIGluIHF1b3RlcyBleGFtcGxlIG1EZWM6IFwiM1wiLFxyXG4gICAgICovXHJcbiAgICBtRGVjOiBudWxsLFxyXG5cclxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxyXG4gICAgICoge2VEZWM6IFwiNVwifSBhbmQgdGhlIGRlZmF1bHQgMiBkZWNpbWFsIHBsYWNlcyB3aXRoIGZvY3VzIFwiMSwwMDAuMTIzNDVcIiB3aXRob3V0IGZvY3VzIFwiMSwwMDAuMTJcIiB0aGUgcmVzdWx0cyBkZXBlbmRzIG9uIHRoZSByb3VuZGluZyBtZXRob2QgdXNlZFxyXG4gICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXHJcbiAgICAgKi9cclxuICAgIGVEZWM6IG51bGwsXHJcblxyXG4gICAgLyogVGhlIG5leHQgdGhyZWUgb3B0aW9ucyAoc2NhbGVEaXZpc29yLCBzY2FsZURlY2ltYWwgJiBzY2FsZVN5bWJvbCkgaGFuZGxlIHNjYWxpbmcgb2YgdGhlIGlucHV0IHdoZW4gdGhlIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXNcclxuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJhU3RvclwiIG9wdGlvbiB0byBlbnN1cmUgcmV0YWluaW5nIHRoZSB2YWx1ZVxyXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXHJcbiAgICAgKiBFeGFtcGxlOiB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9ucyBzZXQge3NjYWxlRGl2aXNvcjogJzEwMDAnLCBzY2FsZURlY2ltYWw6ICcxJywgc2NhbGVTeW1ib2w6ICcgSyd9XHJcbiAgICAgKiBFeGFtcGxlOiBmb2N1c2luIHZhbHVlIFwiMSwxMTEuMTFcIiBmb2N1c291dCB2YWx1ZSBcIjEuMSBLXCJcclxuICAgICAqL1xyXG5cclxuICAgIC8qIFRoZSBgc2NhbGVEaXZpc29yYCBkZWNpZGVzIHRoZSBvbiBmb2N1cyB2YWx1ZSBhbmQgcGxhY2VzIHRoZSByZXN1bHQgaW4gdGhlIGlucHV0IG9uIGZvY3Vzb3V0XHJcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cclxuICAgICAqIFRoZSBkaXZpc29yIHZhbHVlIC0gZG9lcyBub3QgbmVlZCB0byBiZSB3aG9sZSBudW1iZXIgYnV0IHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXHJcbiAgICAgKiBUaGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZnVsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSAnaGlkZGVuJyBkZWNpbWFscy5cclxuICAgICAqL1xyXG4gICAgc2NhbGVEaXZpc29yOiBudWxsLFxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgYHNjYWxlRGVjaW1hbGAgb3B0aW9uIGlzIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZSB3aGVuIG5vdCBpbiBmb2N1cyAtIGZvciB0aGlzIHRvIHdvcmssIGBzY2FsZWREaXZpc29yYCBtdXN0IG5vdCBiZSBgbnVsbGAuXHJcbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIDsgaWYgb21pdHRlZCB0aGUgZGVjaW1hbCBwbGFjZXMgd2lsbCBiZSB0aGUgc2FtZSB3aGVuIHRoZSBpbnB1dCBoYXMgdGhlIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBzY2FsZURlY2ltYWw6IG51bGwsXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBgc2NhbGVTeW1ib2xgIG9wdGlvbiBpcyBhIHN5bWJvbCBwbGFjZWQgYXMgYSBzdWZmaXggd2hlbiBub3QgaW4gZm9jdXMuXHJcbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cclxuICAgICAqL1xyXG4gICAgc2NhbGVTeW1ib2w6IG51bGwsXHJcblxyXG4gICAgLyogU2V0IHRvIHRydWUgdG8gYWxsb3cgdGhlIGVEZWMgdmFsdWUgdG8gYmUgc2F2ZWQgd2l0aCBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcclxuICAgICAqL1xyXG4gICAgYVN0b3I6IGZhbHNlLFxyXG5cclxuICAgIC8qIG1ldGhvZCB1c2VkIGZvciByb3VuZGluZ1xyXG4gICAgICogbVJvdW5kOiBcIlNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXHJcbiAgICAgKiBtUm91bmQ6IFwiQVwiLCBSb3VuZC1IYWxmLVVwIEFzeW1tZXRyaWNcclxuICAgICAqIG1Sb3VuZDogXCJzXCIsIFJvdW5kLUhhbGYtRG93biBTeW1tZXRyaWMgKGxvd2VyIGNhc2UgcylcclxuICAgICAqIG1Sb3VuZDogXCJhXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXHJcbiAgICAgKiBtUm91bmQ6IFwiQlwiLCBSb3VuZC1IYWxmLUV2ZW4gXCJCYW5rZXJzIFJvdW5kaW5nXCJcclxuICAgICAqIG1Sb3VuZDogXCJVXCIsIFJvdW5kIFVwIFwiUm91bmQtQXdheS1Gcm9tLVplcm9cIlxyXG4gICAgICogbVJvdW5kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXHJcbiAgICAgKiBtUm91bmQ6IFwiQ1wiLCBSb3VuZCB0byBDZWlsaW5nIFwiVG93YXJkIFBvc2l0aXZlIEluZmluaXR5XCJcclxuICAgICAqIG1Sb3VuZDogXCJGXCIsIFJvdW5kIHRvIEZsb29yIFwiVG93YXJkIE5lZ2F0aXZlIEluZmluaXR5XCJcclxuICAgICAqIG1Sb3VuZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXHJcbiAgICAgKiBtUm91bmQ6IFwiVTA1XCIgUm91bmRzIHVwIHRvIG5leHQgLjA1XHJcbiAgICAgKiBtUm91bmQ6IFwiRDA1XCIgUm91bmRzIGRvd24gdG8gbmV4dCAuMDVcclxuICAgICAqL1xyXG4gICAgbVJvdW5kOiAnUycsXHJcblxyXG4gICAgLyogQ29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXHJcbiAgICAgKiBhUGFkOiB0cnVlIC0gYWx3YXlzIFBhZCBkZWNpbWFscyB3aXRoIHplcm9zXHJcbiAgICAgKiBhUGFkOiBmYWxzZSAtIGRvZXMgbm90IHBhZCB3aXRoIHplcm9zLlxyXG4gICAgICogTm90ZTogc2V0dGluZyBhUGFkIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ21EZWMnIHNldHRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogdGhhbmtzIHRvIEpvbmFzIEpvaGFuc3NvbiBmb3IgdGhlIHN1Z2dlc3Rpb25cclxuICAgICAqL1xyXG4gICAgYVBhZDogdHJ1ZSxcclxuXHJcbiAgICAvKiBBZGRzIGJyYWNrZXRzIG9uIG5lZ2F0aXZlIHZhbHVlcyAoaWUuIHRyYW5zZm9ybXMgJy0kIDk5OS45OScgdG8gJyg5OTkuOTkpJylcclxuICAgICAqIFRob3NlIGJyYWNrZXRzIGFyZSB2aXNpYmxlIG9ubHkgd2hlbiB0aGUgZmllbGQgZG9lcyBOT1QgaGF2ZSB0aGUgZm9jdXMuXHJcbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxyXG4gICAgICogbkJyYWNrZXQ6IG51bGwgLSAoZGVmYXVsdClcclxuICAgICAqIG5CcmFja2V0OiAnKCwpJywgbkJyYWNrZXQ6ICdbLF0nLCBuQnJhY2tldDogJzwsPicgb3IgbkJyYWNrZXQ6ICd7LH0nXHJcbiAgICAgKi9cclxuICAgIG5CcmFja2V0OiBudWxsLFxyXG5cclxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxyXG4gICAgICogd0VtcHR5OiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xyXG4gICAgICogd0VtcHR5OiBcInByZXNzXCIgLSBjdXJyZW5jeSBzaWduIGRpc3BsYXlzIG9uIGFueSBrZXkgYmVpbmcgcHJlc3NlZFxyXG4gICAgICogd0VtcHR5OiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcclxuICAgICAqIHdFbXB0eTogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRob3V0IGEgY3VycmVuY3kgc2lnblxyXG4gICAgICovXHJcbiAgICAvL1RPRE8gQWRkIGFuIG9wdGlvbiB0byBkaXNwbGF5IHRoZSBjdXJyZW5jeSBzaWduIG9ubHkgb24gaG92ZXIgKGlmIHRoZSBpbnB1dCBpcyBlbXB0eSlcclxuICAgIHdFbXB0eTogJ2ZvY3VzJyxcclxuXHJcbiAgICAvKiBDb250cm9scyBsZWFkaW5nIHplcm8gYmVoYXZpb3JcclxuICAgICAqIGxaZXJvOiBcImFsbG93XCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gWmVyb3Mgd2lsbCBiZSB0cnVuY2F0ZWQgd2hlbiBlbnRlcmluZyBhZGRpdGlvbmFsIGRpZ2l0cy4gT24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSBkZWxldGVkLlxyXG4gICAgICogbFplcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcclxuICAgICAqIGxaZXJvOiBcImtlZXBcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBvbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIHJldGFpbmVkLlxyXG4gICAgICovXHJcbiAgICBsWmVybzogJ2FsbG93JyxcclxuXHJcbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiB0cnVlID0gYXV0b21hdGljYWxseSBmb3JtYXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXHJcbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBhRm9ybTogdHJ1ZSxcclxuXHJcbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxyXG4gICAgICogdGhlIGNvbXBsZXRlIGlucHV0IHRleHQgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxyXG4gICAgICogaWYgdGhlIGN1cnJlbmN5IHN5bWJvbCBpcyBiZXR3ZWVuIHRoZSBudW1lcmljIHZhbHVlIGFuZCB0aGUgbmVnYXRpdmUgc2lnbiBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcclxuICAgICAqL1xyXG4gICAgc051bWJlcjogZmFsc2UsXHJcblxyXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xyXG4gICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxyXG4gICAgICogZXhhbXBsZXM6XHJcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2FuRGVmYXVsdDogXCJcIn1cclxuICAgICAqIHZhbHVlPTEyMzQuNTYge2FuRGVmYXVsdDogJzEyMzQuNTYnfVxyXG4gICAgICovXHJcbiAgICBhbkRlZmF1bHQ6IG51bGwsXHJcblxyXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxyXG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxyXG4gICAgICogcmV2aWV3IHRoZSAndW5TZXQnIG1ldGhvZCBmb3Igb3RoZXIgZm9ybWF0c1xyXG4gICAgICovXHJcbiAgICB1blNldE9uU3VibWl0OiBmYWxzZSxcclxuXHJcbiAgICAvKiBBbGxvd3MgdGhlIG91dHB1dCB0byBiZSBpbiB0aGUgbG9jYWxlIGZvcm1hdCB2aWEgdGhlIFwiZ2V0XCIsIFwiZ2V0U3RyaW5nXCIgJiBcImdldEFycmF5XCIgbWV0aG9kc1xyXG4gICAgICogbnVsbCBvciAnc3RyaW5nJyA9PiAnbm5ubi5ubicgb3IgJy1ubm5uLm5uJyBhcyB0ZXh0IHR5cGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXHJcbiAgICAgKiAnbnVtYmVyJyAgICAgICAgID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gYXMgYSBOdW1iZXIgKFdhcm5pbmc6IHRoaXMgd29ya3Mgb25seSBmb3IgaW50ZWdlcnMgaW5mZXJpb3IgdG8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXHJcbiAgICAgKiAnLCcgb3IgJy0sJyAgICAgID0+ICdubm5uLG5uJyBvciAnLW5ubm4sbm4nXHJcbiAgICAgKiAnLi0nICAgICAgICAgICAgID0+ICdubm5uLm5uJyBvciAnbm5ubi5ubi0nXHJcbiAgICAgKiAnLC0nICAgICAgICAgICAgID0+ICdubm5uLG5uJyBvciAnbm5ubixubi0nXHJcbiAgICAgKi9cclxuICAgIG91dHB1dFR5cGU6IG51bGwsXHJcblxyXG4gICAgLyogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cclxuICAgICAqIHRydWUgPT4gYWxsIGVycm9ycyBhcmUgdGhyb3duIC0gaGVscGZ1bCBpbiBzaXRlIGRldmVsb3BtZW50XHJcbiAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xyXG4gICAgICovXHJcbiAgICBkZWJ1ZzogZmFsc2UsXHJcbn07XHJcblxyXG4vKipcclxuICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXHJcbiAqL1xyXG5jb25zdCBrZXlDb2RlID0ge1xyXG4gICAgQmFja3NwYWNlOiAgICAgIDgsXHJcbiAgICBUYWI6ICAgICAgICAgICAgOSxcclxuICAgIEVudGVyOiAgICAgICAgICAxMyxcclxuICAgIFNoaWZ0OiAgICAgICAgICAxNixcclxuICAgIEN0cmw6ICAgICAgICAgICAxNyxcclxuICAgIEFsdDogICAgICAgICAgICAxOCxcclxuICAgIFBhdXNlQnJlYWs6ICAgICAxOSxcclxuICAgIENhcHNMb2NrOiAgICAgICAyMCxcclxuICAgIEVzYzogICAgICAgICAgICAyNyxcclxuICAgIFNwYWNlOiAgICAgICAgICAzMixcclxuICAgIFBhZ2VVcDogICAgICAgICAzMyxcclxuICAgIFBhZ2VEb3duOiAgICAgICAzNCxcclxuICAgIEVuZDogICAgICAgICAgICAzNSxcclxuICAgIEhvbWU6ICAgICAgICAgICAzNixcclxuICAgIExlZnRBcnJvdzogICAgICAzNyxcclxuICAgIFVwQXJyb3c6ICAgICAgICAzOCxcclxuICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcclxuICAgIERvd25BcnJvdzogICAgICA0MCxcclxuICAgIEluc2VydDogICAgICAgICA0NSxcclxuICAgIERlbGV0ZTogICAgICAgICA0NixcclxuICAgIG51bTA6ICAgICAgICAgICA0OCxcclxuICAgIG51bTE6ICAgICAgICAgICA0OSxcclxuICAgIG51bTI6ICAgICAgICAgICA1MCxcclxuICAgIG51bTM6ICAgICAgICAgICA1MSxcclxuICAgIG51bTQ6ICAgICAgICAgICA1MixcclxuICAgIG51bTU6ICAgICAgICAgICA1MyxcclxuICAgIG51bTY6ICAgICAgICAgICA1NCxcclxuICAgIG51bTc6ICAgICAgICAgICA1NSxcclxuICAgIG51bTg6ICAgICAgICAgICA1NixcclxuICAgIG51bTk6ICAgICAgICAgICA1NyxcclxuICAgIGE6ICAgICAgICAgICAgICA2NSxcclxuICAgIGI6ICAgICAgICAgICAgICA2NixcclxuICAgIGM6ICAgICAgICAgICAgICA2NyxcclxuICAgIGQ6ICAgICAgICAgICAgICA2OCxcclxuICAgIGU6ICAgICAgICAgICAgICA2OSxcclxuICAgIGY6ICAgICAgICAgICAgICA3MCxcclxuICAgIGc6ICAgICAgICAgICAgICA3MSxcclxuICAgIGg6ICAgICAgICAgICAgICA3MixcclxuICAgIGk6ICAgICAgICAgICAgICA3MyxcclxuICAgIGo6ICAgICAgICAgICAgICA3NCxcclxuICAgIGs6ICAgICAgICAgICAgICA3NSxcclxuICAgIGw6ICAgICAgICAgICAgICA3NixcclxuICAgIG06ICAgICAgICAgICAgICA3NyxcclxuICAgIG46ICAgICAgICAgICAgICA3OCxcclxuICAgIG86ICAgICAgICAgICAgICA3OSxcclxuICAgIHA6ICAgICAgICAgICAgICA4MCxcclxuICAgIHE6ICAgICAgICAgICAgICA4MSxcclxuICAgIHI6ICAgICAgICAgICAgICA4MixcclxuICAgIHM6ICAgICAgICAgICAgICA4MyxcclxuICAgIHQ6ICAgICAgICAgICAgICA4NCxcclxuICAgIHU6ICAgICAgICAgICAgICA4NSxcclxuICAgIHY6ICAgICAgICAgICAgICA4NixcclxuICAgIHc6ICAgICAgICAgICAgICA4NyxcclxuICAgIHg6ICAgICAgICAgICAgICA4OCxcclxuICAgIHk6ICAgICAgICAgICAgICA4OSxcclxuICAgIHo6ICAgICAgICAgICAgICA5MCxcclxuICAgIFdpbmRvd3M6ICAgICAgICA5MSxcclxuICAgIFJpZ2h0Q2xpY2s6ICAgICA5MyxcclxuICAgIG51bXBhZDA6ICAgICAgICA5NixcclxuICAgIG51bXBhZDE6ICAgICAgICA5NyxcclxuICAgIG51bXBhZDI6ICAgICAgICA5OCxcclxuICAgIG51bXBhZDM6ICAgICAgICA5OSxcclxuICAgIG51bXBhZDQ6ICAgICAgICAxMDAsXHJcbiAgICBudW1wYWQ1OiAgICAgICAgMTAxLFxyXG4gICAgbnVtcGFkNjogICAgICAgIDEwMixcclxuICAgIG51bXBhZDc6ICAgICAgICAxMDMsXHJcbiAgICBudW1wYWQ4OiAgICAgICAgMTA0LFxyXG4gICAgbnVtcGFkOTogICAgICAgIDEwNSxcclxuICAgIE11bHRpcGx5TnVtcGFkOiAxMDYsXHJcbiAgICBQbHVzTnVtcGFkOiAgICAgMTA3LFxyXG4gICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcclxuICAgIERvdE51bXBhZDogICAgICAxMTAsXHJcbiAgICBTbGFzaE51bXBhZDogICAgMTExLFxyXG4gICAgRjE6ICAgICAgICAgICAgIDExMixcclxuICAgIEYyOiAgICAgICAgICAgICAxMTMsXHJcbiAgICBGMzogICAgICAgICAgICAgMTE0LFxyXG4gICAgRjQ6ICAgICAgICAgICAgIDExNSxcclxuICAgIEY1OiAgICAgICAgICAgICAxMTYsXHJcbiAgICBGNjogICAgICAgICAgICAgMTE3LFxyXG4gICAgRjc6ICAgICAgICAgICAgIDExOCxcclxuICAgIEY4OiAgICAgICAgICAgICAxMTksXHJcbiAgICBGOTogICAgICAgICAgICAgMTIwLFxyXG4gICAgRjEwOiAgICAgICAgICAgIDEyMSxcclxuICAgIEYxMTogICAgICAgICAgICAxMjIsXHJcbiAgICBGMTI6ICAgICAgICAgICAgMTIzLFxyXG4gICAgTnVtTG9jazogICAgICAgIDE0NCxcclxuICAgIFNjcm9sbExvY2s6ICAgICAxNDUsXHJcbiAgICBNeUNvbXB1dGVyOiAgICAgMTgyLFxyXG4gICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcclxuICAgIFNlbWljb2xvbjogICAgICAxODYsXHJcbiAgICBFcXVhbDogICAgICAgICAgMTg3LFxyXG4gICAgQ29tbWE6ICAgICAgICAgIDE4OCxcclxuICAgIEh5cGhlbjogICAgICAgICAxODksXHJcbiAgICBEb3Q6ICAgICAgICAgICAgMTkwLFxyXG4gICAgU2xhc2g6ICAgICAgICAgIDE5MSxcclxuICAgIEJhY2txdW90ZTogICAgICAxOTIsXHJcbiAgICBMZWZ0QnJhY2tldDogICAgMjE5LFxyXG4gICAgQmFja3NsYXNoOiAgICAgIDIyMCxcclxuICAgIFJpZ2h0QnJhY2tldDogICAyMjEsXHJcbiAgICBRdW90ZTogICAgICAgICAgMjIyLFxyXG4gICAgQ29tbWFuZDogICAgICAgIDIyNCxcclxufTtcclxuXHJcblxyXG4oZnVuY3Rpb24oZmFjdG9yeSkge1xyXG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxyXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XHJcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIC8vIE5vZGUvQ29tbW9uSlNcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcbn0gZWxzZSB7XHJcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcclxuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XHJcbn1cclxufSgkID0+IHtcclxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGxcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCBudWxsIG9yIGVtcHR5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCgwKSB8fCAnJyA9PT0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyhzdHIpIHtcclxuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mKHZhbHVlKSA9PT0gJ2Jvb2xlYW4nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbnkgY2FzZXMgZm9yIHRob3NlIHN0cmluZ3MuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1RydWVPckZhbHNlU3RyaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgcmV0dXJuIGxvd2VyY2FzZVZhbHVlID09PSAndHJ1ZScgfHwgbG93ZXJjYXNlVmFsdWUgPT09ICdmYWxzZSc7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gcmVmZXJlbmNlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNPYmplY3QocmVmZXJlbmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZlcmVuY2UgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eVxyXG4gICAgICogY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjc5OTE1L2hvdy1kby1pLXRlc3QtZm9yLWFuLWVtcHR5LWphdmFzY3JpcHQtb2JqZWN0IGFuZCBodHRwOi8vanNwZXJmLmNvbS9lbXB0eS1vYmplY3QtdGVzdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvYmpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHRleHQgZ2l2ZW4gYXMgYSBwYXJhbWV0ZXIgaXMgdmFsaWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRleHRcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkUGFzdGVUZXh0KHRleHQpIHtcclxuICAgICAgICByZXR1cm4gdGV4dCAhPT0gJycgJiYgIWlzTmFOKHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBwYXN0ZWQgdGV4dCB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGV4dFxyXG4gICAgICogQHBhcmFtIGhvbGRlclxyXG4gICAgICogQHJldHVybnMge3N0cmluZ3x2b2lkfFhNTHwqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcclxuICAgICAgICByZXR1cm4gYXV0b1N0cmlwKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmFEZWMsICcuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcclxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7Kn0gbmVlZGxlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcclxuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xyXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cclxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaGFzRGVjaW1hbHMoc3RyKSB7XHJcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydC5cclxuICAgICAqIFJldHVybiBgbnVsbGAgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICAgICAqIEByZXR1cm5zIHtudWxsfGludH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhzdHIpIHtcclxuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcclxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge307XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gc2VsZWN0LnRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHRoYXQuc2VsZWN0aW9uU3RhcnQ7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3Igc2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGF0LmNyZWF0ZVRleHRSYW5nZSgpO1xyXG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcclxuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcclxuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XHJcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcclxuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aHJvdyBlcnJvciBtZXNzYWdlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhIHdhcm5pbmcgbWVzc2FnZXMsIGFjY29yZGluZyB0byB0aGUgZGVidWcgbGV2ZWwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc3VwcHJlc3NXYXJuaW5ncyBJZiBUUlVFLCB0aGVuIHRoZSB3YXJuaW5nIG1lc3NhZ2UgaXMgbm90IGRpc3BsYXllZFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHN1cHByZXNzV2FybmluZ3MgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChzdXBwcmVzc1dhcm5pbmdzKSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHttZXNzYWdlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBhdXRvTnVtZXJpYy1zcGVjaWZpYyBmdW5jdGlvbnNcclxuXHJcbiAgICAvKipcclxuICAgICAqIHJ1biBjYWxsYmFja3MgaW4gcGFyYW1ldGVycyBpZiBhbnlcclxuICAgICAqIGFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcclxuICAgICAqIC0gYSBmdW5jdGlvbiwgd2hpY2ggaW52b2tlZCB3aXRoIGpRdWVyeSBlbGVtZW50LCBwYXJhbWV0ZXJzIGFuZCB0aGlzIHBhcmFtZXRlciBuYW1lIGFuZCByZXR1cm5zIHBhcmFtZXRlciB2YWx1ZVxyXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcnVuQ2FsbGJhY2tzKCR0aGlzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIC8vIGxvb3BzIHRocm91Z2ggdGhlIHNldHRpbmdzIG9iamVjdCAob3B0aW9uIGFycmF5KSB0byBmaW5kIHRoZSBmb2xsb3dpbmdcclxuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gdmFsKCR0aGlzLCBzZXR0aW5ncywgayk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIGNhbGxzIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBmcm9tIHRoZSBodG1sNSBkYXRhIGV4YW1wbGU6IGRhdGEtYS1zaWduPVwiZnVuY3Rpb25OYW1lXCJcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tdID0gJHRoaXMuYXV0b051bWVyaWNbdmFsXSgkdGhpcywgc2V0dGluZ3MsIGspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIHZNaW4gdk1heCBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBkZWNMZW5ndGgodk1pbiwgdk1heCkge1xyXG4gICAgICAgIGxldCB2TWF4TGVuZ3RoID0gMDtcclxuICAgICAgICBsZXQgdk1pbkxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKHZNYXhbMV0pIHtcclxuICAgICAgICAgICAgdk1heExlbmd0aCA9IHZNYXhbMV0ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodk1pblsxXSkge1xyXG4gICAgICAgICAgICB2TWluTGVuZ3RoID0gdk1pblsxXS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodk1heExlbmd0aCwgdk1pbkxlbmd0aCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJpbmcgdXNlciBkZWZpbmVkIG9wdGlvbnMgZm9yIGZ1cnRoZXIgdXNhZ2VcclxuICAgICAqIG1lcmdlIHRoZW0gd2l0aCBkZWZhdWx0cyBhcHByb3ByaWF0ZWx5XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9Db2RlKCR0aGlzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIHJ1bkNhbGxiYWNrcygkdGhpcywgc2V0dGluZ3MpO1xyXG4gICAgICAgIGNvbnN0IHZNYXggPSBzZXR0aW5ncy52TWF4LnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcclxuICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcclxuICAgICAgICBzZXR0aW5ncy5hTmVnID0gc2V0dGluZ3Mudk1pbiA8IDAgPyAnLScgOiAnJztcclxuICAgICAgICB2TWF4WzBdID0gdk1heFswXS5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgIHZNaW5bMF0gPSB2TWluWzBdLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KHZNYXhbMF0ubGVuZ3RoLCAxKTtcclxuICAgICAgICBzZXR0aW5ncy5tSW50TmVnID0gTWF0aC5tYXgodk1pblswXS5sZW5ndGgsIDEpO1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBkZWNMZW5ndGgodk1pbiwgdk1heCk7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm9EZWMgPSBzZXR0aW5ncy5tRGVjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBOdW1iZXIoc2V0dGluZ3MubURlYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZXR0aW5ncy5tRGVjID0gKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcclxuXHJcbiAgICAgICAgLy8gc2V0IGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgPT09IG51bGwgJiYgc2V0dGluZ3MubURlYyA+IDApIHtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09ICcuJyAmJiBzZXR0aW5ncy5hU2VwICE9PSAnLCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsdERlYyA9ICcsJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLCcgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbHREZWMgPSAnLic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGNhY2hlIHJlZ2V4cHMgZm9yIGF1dG9TdHJpcFxyXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5hTmVnID9gKFstXFxcXCR7c2V0dGluZ3MuYU5lZ31dPylgIDonKC0/KSc7XHJcbiAgICAgICAgc2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XHJcbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7KHNldHRpbmdzLmFOZWc/YFxcXFwke3NldHRpbmdzLmFOZWd9YDonJyl9XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZF0uKj8oXFxcXGR8XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZClgKTtcclxuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmFEZWN9PylbXlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdXFxcXEQqJGApO1xyXG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5hRGVjfWA7XHJcbiAgICAgICAgc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcclxuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuYURlY30/KFxcXFxkK1xcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQrKXwoXFxcXGQqKD86XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCopPykpYCk7XHJcblxyXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHN0cmlwIGFsbCB1bndhbnRlZCBjaGFyYWN0ZXJzIGFuZCBsZWF2ZSBvbmx5IGEgbnVtYmVyIGFsZXJ0XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9TdHJpcChzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2lnbiAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIGN1cnJlbmN5IHNpZ25cclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU2lnbiwgJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0dGluZ3MuYVN1ZmZpeCkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgc3VmZml4XHJcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5hU3VmZml4KSkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hU3VmZml4LCAnJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpcnN0IHJlcGxhY2UgYW55dGhpbmcgYmVmb3JlIGRpZ2l0c1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xyXG5cclxuICAgICAgICBpZiAoKHNldHRpbmdzLnBOZWcgPT09ICdzJyB8fCAoc2V0dGluZ3MucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5ncy5wTmVnICE9PSAncCcpKSAmJiBjb250YWlucyhzLCAnLScpICYmIHMgIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xyXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAsICckMScpO1xyXG5cclxuICAgICAgICAvLyB0aGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGVkIGNoYXJhY3RlcnNcclxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYWx0RGVjKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWx0RGVjLCBzZXR0aW5ncy5hRGVjKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGdldCBvbmx5IG51bWJlciBzdHJpbmdcclxuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xyXG4gICAgICAgIHMgPSBtID8gW21bMV0sIG1bMl0sIG1bM11dLmpvaW4oJycpIDogJyc7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxaZXJvID09PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5hRGVjKTtcclxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKG1vZGlmaWVkSW50ZWdlclBhcnQsIHNldHRpbmdzLmFOZWcpKSB7XHJcbiAgICAgICAgICAgICAgICBuU2lnbiA9IHNldHRpbmdzLmFOZWc7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcclxuICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBtb2RpZmllZEludGVnZXJQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1JbnRQb3MgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5jaGFyQXQoMCkgPT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0fWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3MubFplcm8gPT09ICdkZW55JykgfHwgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnICYmIHNldHRpbmdzLm9uT2ZmID09PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxyXG4gICAgICAgICAgICBsZXQgc3RyaXBSZWcgPSBgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKihcXFxcZClgO1xyXG4gICAgICAgICAgICBzdHJpcFJlZyA9IG5ldyBSZWdFeHAoc3RyaXBSZWcpO1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHN0cmlwUmVnLCAnJDEkMicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGFjZXMgb3IgcmVtb3ZlcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzLnBOZWcgPT09ICdsJykgfHwgKHNldHRpbmdzLnBTaWduID09PSAncycgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3AnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBbZmlyc3RCcmFja2V0LCBsYXN0QnJhY2tldF0gPSBzZXR0aW5ncy5uQnJhY2tldC5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmKSB7XHJcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcclxuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub25PZmYgJiYgcy5jaGFyQXQoMCkgPT09IGZpcnN0QnJhY2tldCkge1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLmFOZWcpO1xyXG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNvbnZlcnQgbG9jYWxlIGZvcm1hdCB0byBKYXZhc2NyaXB0IG51bWVyaWMgc3RyaW5nXHJcbiAgICAgKiBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWQgb2YgY3VycmVuY3kgc2lnbnMgYWxsb3dlZFxyXG4gICAgICogJzEyMzQuNTYnICAgIE9LXHJcbiAgICAgKiAnLTEyMzQuNTYnICAgT0tcclxuICAgICAqICcxMjM0LjU2LScgICBPS1xyXG4gICAgICogJzEyMzQsNTYnICAgIE9LXHJcbiAgICAgKiAnLTEyMzQsNTYnICAgT0tcclxuICAgICAqICcxMjM0LDU2LScgICBPS1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tTG9jYWxlKHMpIHtcclxuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICBpZiAoY29udGFpbnMocywgJy0nKSAmJiBzLmxhc3RJbmRleE9mKCctJykgPT09IHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgICAgICBzID0gJy0nICsgcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50LlxyXG4gICAgICogU2VlIHRoZSBcIm91dHB1dFR5cGVcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XHJcbiAgICAgICAgaWYgKGlzTnVsbChsb2NhbGUpIHx8IGxvY2FsZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKGxvY2FsZSkge1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcuLSc6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICcsJzpcclxuICAgICAgICAgICAgY2FzZSAnLSwnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnLC0nOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjb250YWlucyhyZXN1bHQsICctJykgPyByZXN1bHQucmVwbGFjZSgnLScsICcnKSArICctJyA6IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjYXNlXHJcbiAgICAgICAgICAgIGNhc2UgJy4nOlxyXG4gICAgICAgICAgICBjYXNlICctLic6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBnaXZlbiBvdXRwdXRUeXBlIFske2xvY2FsZX1dIG9wdGlvbiBpcyBub3QgcmVjb2duaXplZC5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlIG51bWJlciBzdHJpbmcgdG8gYmUgY29udmVydGVkIHRvIHJlYWwgbnVtYmVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZpeE51bWJlcihzLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hRGVjLCAnLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2V0dGluZ3MuYU5lZyAhPT0gJy0nKSB7XHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYU5lZywgJy0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xyXG4gICAgICAgICAgICBzICs9ICcwJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZSByZWFsIG51bWJlciB0byBiZSBjb252ZXJ0ZWQgdG8gb3VyIGZvcm1hdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFOZWcgIT09ICctJykge1xyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MuYU5lZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICE9PSAnLicpIHtcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmFEZWMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2lnbk9uRW1wdHlcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCBzaWduT25FbXB0eSkge1xyXG4gICAgICAgIGlmIChpbnB1dFZhbHVlID09PSAnJyB8fCBpbnB1dFZhbHVlID09PSBzZXR0aW5ncy5hTmVnKSB7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLnBOZWcgPT09ICdsJykgPyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hU3VmZml4IDogc2V0dGluZ3MuYVNpZ24gKyBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVN1ZmZpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFByaXZhdGUgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIG91ciBudW1iZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRWYWx1ZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b0dyb3VwKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBhdXRvU3RyaXAoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGlucHV0VmFsdWUsICctJykpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9ICctJyArIGlucHV0VmFsdWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xyXG4gICAgICAgIGNvbnN0IGlzTmVnID0gY29udGFpbnMoaW5wdXRWYWx1ZSwgJy0nKTtcclxuICAgICAgICBpZiAoaXNOZWcpIHtcclxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChlbXB0eSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwID0gJyc7XHJcbiAgICAgICAgc2V0dGluZ3MuZEdyb3VwID0gc2V0dGluZ3MuZEdyb3VwLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzInKSB7XHJcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICcycycpIHtcclxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XHJcbiAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5kR3JvdXAgPT09ICc0Jykge1xyXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHszfT8pKykkLztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHNwbGl0cyB0aGUgc3RyaW5nIGF0IHRoZSBkZWNpbWFsIHN0cmluZ1xyXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuYURlYyk7XHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsdERlYyAmJiBpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcclxuICAgICAgICAgICAgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBpbnB1dFZhbHVlLnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MuYVNlcCAhPT0gJycpIHtcclxuICAgICAgICAgICAgLy8gcmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxyXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnRlZ2VyUGFydCA9IGludGVnZXJQYXJ0LnJlcGxhY2UoZGlnaXRhbEdyb3VwLCBgJDEke3NldHRpbmdzLmFTZXB9JDJgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgIT09IDAgJiYgIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xyXG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MubURlYykge1xyXG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MubURlYyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGpvaW5zIHRoZSB3aG9sZSBudW1iZXIgd2l0aCB0aGUgZGVjaW1hbCB2YWx1ZVxyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5hRGVjICsgZGVjaW1hbFBhcnQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgd2hvbGUgbnVtYmVycyBvbmx5XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIHNldHRpbmdzLmFOZWcgKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5hTmVnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOZWcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hU2lnbiArIGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ24gKyBzZXR0aW5ncy5hTmVnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5hTmVnICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLmFTaWduO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNOZWcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVNpZ247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xyXG4gICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBuZWdhdGl2ZUJyYWNrZXQoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlICsgc2V0dGluZ3MuYVN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydW5jYXRlIG5vdCBuZWVkZWQgemVyb3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91bmRlZElucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSByRGVjXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZHxYTUx8c3RyaW5nfCp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHJEZWMpIHtcclxuICAgICAgICBsZXQgcmVnZXg7XHJcbiAgICAgICAgc3dpdGNoIChyRGVjKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHVudGlsIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdCBpcyBlbmNvdW50ZXJlZFxyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIHBhZGRpbmcgd2hlbiBtRGVjIGVxdWFscyBvbmUgLSBsZWF2ZXMgb25lIHplcm8gdHJhaWxpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBtRGVjIGxlbmd0aCB3aGVuIGFQYWQgaXMgc2V0IHRvIHRydWVcclxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcclxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xyXG4gICAgICAgIGlmIChyRGVjID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJvdW5kZWRJbnB1dFZhbHVlID0gcm91bmRlZElucHV0VmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZGVkSW5wdXRWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHJvdW5kIG51bWJlciBhZnRlciBzZXR0aW5nIGJ5IHBhc3Rpbmcgb3IgJCgpLmF1dG9OdW1lcmljU2V0KClcclxuICAgICAqIHByaXZhdGUgZnVuY3Rpb24gZm9yIHJvdW5kIHRoZSBudW1iZXJcclxuICAgICAqIHBsZWFzZSBub3RlIHRoaXMgaGFuZGxlZCBhcyB0ZXh0IC0gSmF2YVNjcmlwdCBtYXRoIGZ1bmN0aW9uIGNhbiByZXR1cm4gaW5hY2N1cmF0ZSB2YWx1ZXNcclxuICAgICAqIGFsc28gdGhpcyBvZmZlcnMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcyB0aGF0IGFyZSBub3QgZWFzaWx5IGFjY29tcGxpc2hlZCBpbiBKYXZhU2NyaXB0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9Sb3VuZChpbnB1dFZhbHVlLCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcclxuICAgICAgICBpbnB1dFZhbHVlID0gKGlucHV0VmFsdWUgPT09ICcnKSA/ICcwJyA6IGlucHV0VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoc2V0dGluZ3MubVJvdW5kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdDSEYnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnRDA1Jykge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1Sb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGgucm91bmQoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguY2VpbChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gKE1hdGguZmxvb3IoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGlucHV0VmFsdWUsICcuJykpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnLjAwJztcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dFZhbHVlLmxlbmd0aCAtIGlucHV0VmFsdWUuaW5kZXhPZignLicpIDwgMykge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcwJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XHJcbiAgICAgICAgbGV0IHJEZWM7XHJcblxyXG4gICAgICAgIC8vIHNldHMgdGhlIHRydW5jYXRlIHplcm8gbWV0aG9kXHJcbiAgICAgICAgaWYgKHNldHRpbmdzLmFQYWQpIHtcclxuICAgICAgICAgICAgckRlYyA9IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgckRlYyA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGlucHV0VmFsdWUgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXHJcbiAgICAgICAgaWYgKGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgblNpZ24gPSAnLSc7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoJy0nLCAnJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBcHBlbmQgYSB6ZXJvIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90KVxyXG4gICAgICAgIGlmICghaW5wdXRWYWx1ZS5tYXRjaCgvXlxcZC8pKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnMCcgKyBpbnB1dFZhbHVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxyXG4gICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIE51bWJlcihpbnB1dFZhbHVlKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBuU2lnbiA9ICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVHJpbXMgbGVhZGluZyB6ZXJvJ3MgYXMgbmVlZGVkXHJcbiAgICAgICAgaWYgKChOdW1iZXIoaW5wdXRWYWx1ZSkgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpbnB1dFZhbHVlLmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycpKSB7XHJcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkUG9zID0gaW5wdXRWYWx1ZS5sYXN0SW5kZXhPZignLicpO1xyXG5cclxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cclxuICAgICAgICBjb25zdCB2ZFBvcyA9IChkUG9zID09PSAtMSkgPyBpbnB1dFZhbHVlLmxlbmd0aCAtIDEgOiBkUG9zO1xyXG5cclxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcclxuICAgICAgICAvLyBDaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxyXG4gICAgICAgIGxldCBjRGVjID0gKGlucHV0VmFsdWUubGVuZ3RoIC0gMSkgLSB2ZFBvcztcclxuXHJcbiAgICAgICAgaWYgKGNEZWMgPD0gc2V0dGluZ3MubURlYykge1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXHJcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGlucHV0VmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRQb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHNldHRpbmdzLmFEZWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHJEZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCByRGVjIC0gY0RlYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xyXG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgckRlYyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiByRGVjID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcclxuICAgICAgICBjb25zdCByTGVuZ3RoID0gZFBvcyArIHNldHRpbmdzLm1EZWM7IC8vVE9ETyBNb2RpZnkgYGRQb3NgIGhlcmUgaWYgaXQncyBub3QgaW50ZW5kZWQgdGhhdCBpdCBjYW4gYmUgZXF1YWwgdG8gJy0xJ1xyXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xyXG4gICAgICAgIGxldCBpdkFycmF5ID0gaW5wdXRWYWx1ZS5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcclxuXHJcbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXHJcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ2EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xyXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdhJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcclxuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxyXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0InICYmIG9kZCA9PT0gMSkgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXHJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0MnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIHRvIGNlaWxpbmcgdG93YXJkIHBvc2l0aXZlIGluZmluaXRlXHJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxyXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdVJykpIHsgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCBhd2F5IGZyb20gemVyb1xyXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldICE9PSAnLicpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXHJcbiAgICAgICAgaXZBcnJheSA9IGl2QXJyYXkuc2xpY2UoMCwgckxlbmd0aCArIDEpO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcclxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHJEZWMpO1xyXG5cclxuICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzdGVcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XHJcbiAgICAgICAgY29uc3QgYURlYyA9IHNldHRpbmdzLmFEZWM7XHJcbiAgICAgICAgY29uc3QgbURlYyA9IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcclxuXHJcbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xyXG4gICAgICAgICAgICBjb25zdCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IHMuc3BsaXQoYURlYyk7XHJcblxyXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XHJcbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGFydCAmJiBkZWNpbWFsUGFydC5sZW5ndGggPiBtRGVjKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobURlYyA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBgJHtpbnRlZ2VyUGFydH0ke2FEZWN9JHttb2RpZmllZERlY2ltYWxQYXJ0fWA7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiB2TWluOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cclxuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcGFyc2VTdHIobikge1xyXG4gICAgICAgIGNvbnN0IHggPSB7fTtcclxuICAgICAgICBsZXQgZTtcclxuICAgICAgICBsZXQgaTtcclxuICAgICAgICBsZXQgbkw7XHJcbiAgICAgICAgbGV0IGo7XHJcblxyXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XHJcbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XHJcbiAgICAgICAgICAgIG4gPSAnLTAnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHNpZ24uIDEgcG9zaXRpdmUsIC0xIG5lZ2F0aXZlXHJcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAobi5jaGFyQXQoMCkgPT09ICctJykge1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZSgxKTtcclxuICAgICAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeC5zID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xyXG4gICAgICAgIGlmIChlID4gLTEpIHtcclxuICAgICAgICAgICAgbiA9IG4ucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGxlbmd0aCBvZiBzdHJpbmcgaWYgbm8gZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICBpZiAoZSA8IDApIHtcclxuICAgICAgICAgICAgLy8gSW50ZWdlclxyXG4gICAgICAgICAgICBlID0gbi5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvc1xyXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcclxuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xyXG4gICAgICAgIGlmIChpID09PSBuTCkge1xyXG4gICAgICAgICAgICAvLyBaZXJvXHJcbiAgICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICAgIHguYyA9IFswXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcclxuICAgICAgICAgICAgZm9yIChqID0gbkwgLSAxOyBuLmNoYXJBdChqKSA9PT0gJzAnOyBqIC09IDEpIHtcclxuICAgICAgICAgICAgICAgIG5MIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbkwgLT0gMTtcclxuXHJcbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cclxuICAgICAgICAgICAgeC5lID0gZSAtIGkgLSAxO1xyXG4gICAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGFycmF5IG9mIGRpZ2l0cyB3aXRob3V0IGxlYWRpbmcvdHJhaWxpbmcgemVyb3NcclxuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XHJcbiAgICAgICAgICAgICAgICBlICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzXHJcbiAgICAgKiBUaGlzIHVzZXMgdGhlIHBhcnNlZCBzdHJpbmdzIGZvciB0aGUgYWJvdmUgcGFyc2VTdHIgZnVuY3Rpb25cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXHJcbiAgICAgKiBNYW55IHRoYW5rcyB0byBNaWtlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xyXG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xyXG4gICAgICAgIGNvbnN0IHljID0geS5jO1xyXG4gICAgICAgIGxldCBpID0geC5zO1xyXG4gICAgICAgIGxldCBqID0geS5zO1xyXG4gICAgICAgIGxldCBrID0geC5lO1xyXG4gICAgICAgIGxldCBsID0geS5lO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgICAgICBpZiAoIXhjWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICBpZiAoaSAhPT0gaikge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeE5lZyA9IGkgPCAwO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xyXG4gICAgICAgIGlmIChrICE9PSBsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcclxuICAgICAgICBsID0geWMubGVuZ3RoO1xyXG4gICAgICAgIGogPSAoayA8IGwpID8gayA6IGw7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcclxuICAgICAgICBmb3IgKGkgKz0gMTsgaSA8IGo7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHNcclxuICAgICAgICBsZXQgcmVzdWx0O1xyXG4gICAgICAgIGlmIChrID09PSBsKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBudW1iZXIgc2F0aXNmeSB0aGUgZm9ybWF0IGNvbmRpdGlvbnNcclxuICAgICAqIGFuZCBsYXlzIGJldHdlZW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxyXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gYXV0b0NoZWNrKHMsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgcyA9IHMudG9TdHJpbmcoKTtcclxuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLnZNaW4pO1xyXG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3Mudk1heCk7XHJcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcclxuXHJcbiAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGF1dG9HZXQob2JqKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xyXG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBibG9jayBpcyBhcHBhcmVudGx5IG5ldmVyIGVudGVyZWQuIFdlIHNob3VsZCByZW1vdmUgaXQgYWZ0ZXIgbWFraW5nIHN1cmUgdGhhdCdzIDEwMCUgdGhlIGNhc2VcclxuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xyXG4gICAgICAgICAgICBvYmogPSAnIycgKyBvYmoucmVwbGFjZSgvKDp8XFwuKS9nLCAnXFxcXCQxJyk7XHJcbiAgICAgICAgICAgIC8vIHBvc3NpYmxlIG1vZGlmaWNhdGlvbiB0byByZXBsYWNlIHRoZSBhYm92ZSAyIGxpbmVzXHJcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gJChvYmopO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRnVuY3Rpb24gdG8gYXR0YWNoIGRhdGEgdG8gdGhlIGVsZW1lbnQgYW5kIGltaXRhdGUgdGhlIGhvbGRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAkdGhhdFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgbGV0IGRhdGEgPSAkdGhhdC5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICBkYXRhID0ge307XHJcbiAgICAgICAgICAgICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJywgZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XHJcbiAgICAgICAgaWYgKChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSB8fCB1cGRhdGUpIHtcclxuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGF0LmdldCgwKSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYyAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZC5cclxuICAgICAqIFRob3NlIG9yaWdpbmFsIHNldHRpbmdzIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IGluIHRoZSBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnQgaGFuZGxlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKSB7XHJcbiAgICAgICAgc2V0dGluZ3Mub0RlYyAgICAgPSBzZXR0aW5ncy5tRGVjO1xyXG4gICAgICAgIHNldHRpbmdzLm9QYWQgICAgID0gc2V0dGluZ3MuYVBhZDtcclxuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5CcmFja2V0O1xyXG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuYVNlcDtcclxuICAgICAgICBzZXR0aW5ncy5vU2lnbiAgICA9IHNldHRpbmdzLmFTaWduO1xyXG4gICAgICAgIHNldHRpbmdzLm9TdWZmaXggID0gc2V0dGluZ3MuYVN1ZmZpeDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXHJcbiAgICAgKiB0YWtlbiBmcm9tIFF1aXJrc21vZGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcclxuICAgICAgICBjb25zdCBjYSA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xyXG4gICAgICAgIGxldCBjID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBjID0gY2FbaV07XHJcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZCAtIHRha2VuIGZyb20gbW9kZXJuaXpyXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHN0b3JhZ2VUZXN0KCkge1xyXG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0obW9kLCBtb2QpO1xyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZXMgb3IgcmVtb3ZlcyBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsIHRvRG8pIHtcclxuICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9ICgkdGhpc1swXS5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoJHRoaXNbMF0ubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudCgkdGhpc1swXS5uYW1lKX1gIDpgQVVUT18keyR0aGlzWzBdLmlkfWA7XHJcbiAgICAgICAgICAgIGxldCBkYXRlO1xyXG4gICAgICAgICAgICBsZXQgZXhwaXJlcztcclxuXHJcbiAgICAgICAgICAgIC8vIHNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcclxuICAgICAgICAgICAgaWYgKHN0b3JhZ2VUZXN0KCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0ke3NldHRpbmdzLnJhd1ZhbHVlfTsgZXhwaXJlcz0gOyBwYXRoPS9gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3aXBlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9VVENTdHJpbmcoKTsgLy8gTm90ZSA6IGB0b0dNVFN0cmluZygpYCBoYXMgYmVlbiBkZXByZWNhdGVkIChjZi4gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS90b0dNVFN0cmluZylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2dldCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKHN0b3JlZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0b0RvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShzdG9yZWROYW1lLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JlZE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShzdG9yZWROYW1lKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvbGRlciBvYmplY3QgZm9yIGZpZWxkIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGhhdFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQXV0b051bWVyaWNIb2xkZXIodGhhdCwgc2V0dGluZ3MpIHtcclxuICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XHJcbiAgICAgICAgdGhpcy50aGF0ID0gdGhhdDtcclxuICAgICAgICB0aGlzLiR0aGF0ID0gJCh0aGF0KTtcclxuICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGF0LnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIEF1dG9OdW1lcmljSG9sZGVyLnByb3RvdHlwZSA9IHtcclxuICAgICAgICBpbml0KGUpIHtcclxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gYXV0b0NvZGUodGhpcy4kdGhhdCwgdGhpcy5zZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3RybEtleSA9IGUuY3RybEtleTtcclxuICAgICAgICAgICAgdGhpcy5jbWRLZXkgPSBlLm1ldGFLZXk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hpZnRLZXkgPSBlLnNoaWZ0S2V5O1xyXG5cclxuICAgICAgICAgICAgLy8ga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZVxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcclxuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXVwJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPSBlLmtleUNvZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53aGljaCA9IGUud2hpY2g7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0U2VsZWN0aW9uKHN0YXJ0LCBlbmQsIHNldFJlYWwpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1heChzdGFydCwgMCk7XHJcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQsXHJcbiAgICAgICAgICAgICAgICBlbmQsXHJcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0UG9zaXRpb24ocG9zLCBzZXRSZWFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXRCZWZvcmVBZnRlcigpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHRoaXMuc2VsZWN0aW9uLnN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBsZXQgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcclxuICAgICAgICAgICAgbGVmdCA9IGF1dG9TdHJpcChsZWZ0LCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzdHJpcCBwYXJ0cyBmcm9tIGV4Y2VzcyBjaGFyYWN0ZXJzIGFuZCBsZWFkaW5nIHplcm9lc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcblxyXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxyXG4gICAgICAgICAgICBsZWZ0ID0gYXV0b1N0cmlwKGxlZnQsIHNldHRpbmdzQ2xvbmUpO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgcmlnaHQgaXMgbm90IGVtcHR5IGFuZCBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGFEZWMsXHJcbiAgICAgICAgICAgIHJpZ2h0ID0gYXV0b1N0cmlwKHJpZ2h0LCBzZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKGxlZnQgPT09ICcnIHx8IGxlZnQgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgc2V0dGluZ3NDbG9uZS5sWmVybyA9PT0gJ2RlbnknKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPiAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaW5zZXJ0IHplcm8gaWYgaGFzIGxlYWRpbmcgZG90XHJcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFEZWMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLm5ld1ZhbHVlLm1hdGNoKG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzQ2xvbmUuYU5lZ1JlZ0F1dG9TdHJpcH1cXFxcJHtzZXR0aW5nc0Nsb25lLmFEZWN9YCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSBrZWVwaW5nIHBvc2l0aW9uIG9mIGN1cnNvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIGFkdmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMubm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSk7XHJcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcclxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHBhcnRzLmpvaW4oJycpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IHRydW5jYXRlRGVjaW1hbCh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lLCBhZHZlbnQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVzdFZhbHVlID09PSAnJyB8fCB0ZXN0VmFsdWUgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IHRlc3RWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIGV4cGFuZFNlbGVjdGlvbk9uU2lnblxyXG4gICAgICAgICAqIHJldHVybnMgc2lnbiBwb3NpdGlvbiBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNpZ25Qb3NpdGlvbigpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgYVNpZ24gPSBzZXR0aW5nc0Nsb25lLmFTaWduO1xyXG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xyXG5cclxuICAgICAgICAgICAgaWYgKGFTaWduKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IGFTaWduLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLmFOZWcgJiYgdGhhdC52YWx1ZSAmJiB0aGF0LnZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNOZWcgPyBbMSwgYVNpZ25MZW4gKyAxXSA6IFswLCBhU2lnbkxlbl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt2YWx1ZUxlbiAtIGFTaWduTGVuLCB2YWx1ZUxlbl07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBbMTAwMCwgLTFdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cclxuICAgICAgICAgKiBwcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5zaWduUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3Rpb24gY2F0Y2hlcyBzb21ldGhpbmcgZXhjZXB0IHNpZ24gYW5kIGNhdGNoZXMgb25seSBzcGFjZSBmcm9tIHNpZ25cclxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblsxXSAmJiBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSB8fCBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzFdKSAmJiB0aGlzLnZhbHVlLnN1YnN0cmluZyhNYXRoLm1heChzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWluKHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSkpLm1hdGNoKC9eXFxzKiQvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHNpZ25Qb3NpdGlvblsxXSwgc2VsZWN0aW9uLmVuZCwgc2V0UmVhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHNlbGVjdCB3aXRoIHdob2xlIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcclxuICAgICAgICAgKi9cclxuICAgICAgICBjaGVja1Bhc3RlKCkge1xyXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkUGFydHMgPSB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBhdXRvU3RyaXAobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXRWYWx1ZVBhcnRzKG1vZGlmaWVkTGVmdFBhcnQsIHJpZ2h0LCAncGFzdGUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvbGRQYXJ0cy5qb2luKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5c1xyXG4gICAgICAgICAqIGlmIHJldHVybnMgdHJ1ZSwgZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBza2lwQWx3YXlzKGUpIHtcclxuICAgICAgICAgICAgY29uc3Qga2RDb2RlID0gdGhpcy5rZENvZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHdoaWNoID0gdGhpcy53aGljaDtcclxuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcclxuICAgICAgICAgICAgY29uc3QgY21kS2V5ID0gdGhpcy5jbWRLZXk7XHJcblxyXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcclxuICAgICAgICAgICAgY29uc3Qgc2hpZnRLZXkgPSB0aGlzLnNoaWZ0S2V5O1xyXG4gICAgICAgICAgICBpZiAoKChjdHJsS2V5IHx8IGNtZEtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8IChzaGlmdEtleSAmJiBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNraXAgRngga2V5cywgd2luZG93cyBrZXlzLCBvdGhlciBzcGVjaWFsIGtleXNcclxuICAgICAgICAgICAgaWYgKChrZENvZGUgPj0ga2V5Q29kZS5GMSAmJiBrZENvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XHJcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiBrZENvZGUgPD0ga2V5Q29kZS5SaWdodENsaWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgKGtkQ29kZSA+PSBrZXlDb2RlLlRhYiAmJiBrZENvZGUgPCBrZXlDb2RlLlNwYWNlKSB8fFxyXG4gICAgICAgICAgICAgICAgKGtkQ29kZSA8IGtleUNvZGUuQmFja3NwYWNlICYmXHJcbiAgICAgICAgICAgICAgICAod2hpY2ggPT09IDAgfHwgd2hpY2ggPT09IGtkQ29kZSkpIHx8XHJcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuTnVtTG9jayB8fFxyXG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLlNjcm9sbExvY2sgfHxcclxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQgfHxcclxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5Db21tYW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGFsbCAoYSlcclxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYga2RDb2RlID09PSBrZXlDb2RlLmEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNOdW1iZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gdGhpcy5zZXR0aW5ncy5hU2lnbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVnTGVuID0gKCFjb250YWlucyh0aGlzLnRoYXQudmFsdWUsICctJykpPzA6MTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU3VmZml4TGVuID0gdGhpcy5zZXR0aW5ncy5hU3VmZml4Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwU2lnbiA9IHRoaXMuc2V0dGluZ3MucFNpZ247XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcE5lZyA9IHRoaXMuc2V0dGluZ3MucE5lZztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2lnbiA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChwTmVnID09PSAnbCcgJiYgbmVnTGVuID09PSAxICYmIGFTaWduTGVuID4gMCk/YVNpZ25MZW4gKyAxOmFTaWduTGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIGFTdWZmaXhMZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwTmVnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChhU3VmZml4TGVuICsgYVNpZ25MZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKGFTaWduTGVuID4gMCk/dmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBuZWdMZW4gKyBhU3VmZml4TGVuKTp2YWx1ZUxlbiAtIChhU2lnbkxlbiArIGFTdWZmaXhMZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoYVNpZ25MZW4gKyBhU3VmZml4TGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGNvcHkgKGMpXHJcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIChrZENvZGUgPT09IGtleUNvZGUuYyB8fCBrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUueCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU2VsZWN0aW9uT25TaWduKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIHByZXZlbnQgd3JvbmcgcGFzdGVcclxuICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXN0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwga2RDb2RlID09PSBrZXlDb2RlLmM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjdHJsS2V5IHx8IGNtZEtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGp1bXAgb3ZlciB0aG91c2FuZCBzZXBhcmF0b3JcclxuICAgICAgICAgICAgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5MZWZ0QXJyb3cgfHwga2RDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFTZXAgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNlcDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFEZWMgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYURlYztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IHRoaXMuc2VsZWN0aW9uLnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIXRoaXMuc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgLSAyKSA9PT0gYURlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhRGVjKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHN0YXJ0SnVtcCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ga2RDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYga2RDb2RlIDw9IGtleUNvZGUuRG93bkFycm93O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc1RyYWlsaW5nKFtsZWZ0LCByaWdodF0pIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSAmJiBzZXR0aW5nc0Nsb25lLmFTdWZmaXggIT09ICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAxKSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5hU3VmZml4Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFTaWduKSArIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCkgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgKCh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRbMF0gPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0gOCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hTmVnKSAtIHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICcnICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICogcmV0dXJucyB0cnVlIGlmIHByb2Nlc3NpbmcgcGVyZm9ybWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnIHx8IHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSkpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLnByb2Nlc3NUcmFpbGluZyhbbGVmdCwgcmlnaHRdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByb2Nlc3MgaW5zZXJ0aW9uIG9mIGNoYXJhY3RlcnNcclxuICAgICAgICAgKiByZXR1cm5zIHRydWUgaWYgcHJvY2Vzc2luZyBwZXJmb3JtZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICBwcm9jZXNzS2V5cHJlc3MoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgLy8gc3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXHJcbiAgICAgICAgICAgIC8vIGRvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBpZiBubyBkZWNpbWFsIHBhcnQgYWxsb3dlZFxyXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lLm1EZWMgfHwgIXNldHRpbmdzQ2xvbmUuYURlYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBhbGxvdyBkZWNpbWFsIGNoYXJhY3RlciBiZWZvcmUgYU5lZyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuYURlYykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFEZWMpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCArIHNldHRpbmdzQ2xvbmUuYURlYywgcmlnaHQsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IG1pbnVzIGlmIG5vdCBhbGxvd2VkXHJcbiAgICAgICAgICAgIGlmICgoY0NvZGUgPT09ICctJyB8fCBjQ29kZSA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgPT09ICctJykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FyZXQgaXMgYWx3YXlzIGFmdGVyIG1pbnVzXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgIT09ICdwJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBzaWduIG9mIG51bWJlciwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoY0NvZGUgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0IDogbGVmdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB0cnkgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51c1xyXG4gICAgICAgICAgICBpZiAoY0NvZGUgPj0gJzAnICYmIGNDb2RlIDw9ICc5Jykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnZNYXggPD0gMCAmJiBzZXR0aW5nc0Nsb25lLnZNaW4gPCBzZXR0aW5nc0Nsb25lLnZNYXggJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykgJiYgY0NvZGUgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWcgKyBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQgKyBjQ29kZSwgcmlnaHQsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHByZXZlbnQgYW55IG90aGVyIGNoYXJhY3RlclxyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2l0aCBrZWVwaW5nIG9mIGN1cnNvciBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZvcm1hdFF1aWNrKGUpIHtcclxuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcclxuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XHJcbiAgICAgICAgICAgIGNvbnN0IGt1Q29kZSA9IGUua2V5Q29kZTtcclxuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBubyBncm91cGluZyBzZXBhcmF0b3IgYW5kIG5vIGN1cnJlbmN5IHNpZ25cclxuICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmFTZXAgID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2VwICE9PSAnJyAgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNlcCkpKSAmJlxyXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuYVNpZ24gPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmFTaWduICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5hU2lnbikpKSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IFtzdWJQYXJ0c10gPSBsZWZ0TGVuZ3RoLnNwbGl0KHNldHRpbmdzQ2xvbmUuYURlYyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhzdWJQYXJ0cywgJy0nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5TaWduID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YlBhcnRzID0gc3ViUGFydHMucmVwbGFjZSgnLScsICcnKTtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXHJcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcclxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJy0nICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludE5lZyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF1dG9Hcm91cCh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSB2YWx1ZS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdEFyID0gbGVmdC5zcGxpdCgnJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gZml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXHJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnICE9PSAncCcpKSAmJiBsZWZ0QXJbMF0gPT09ICctJyAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdsJyAmJiAoa3VDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwga3VDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5EZWxldGUpICYmIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goJy0nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnICYmIChrdUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCBrdUNvZGUgPT09IGtleUNvZGUuRGVsZXRlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkgJiYgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gZS50eXBlID09PSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25QYXJ0cyA9IHNldHRpbmdzQ2xvbmUuYVNpZ24uc3BsaXQoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNpZ25QYXJ0cywgKGksIG1pbmlQYXJ0cykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnXFxcXCcgKyBtaW5pUGFydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnB1c2goZXNjYXBlZFBhcnRzLmpvaW4oJycpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlZnRBci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFJlZyA9IG5ldyBSZWdFeHAoJ14uKj8nICsgbGVmdEFyLmpvaW4oJy4qPycpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TGVmdCA9IHZhbHVlLm1hdGNoKGxlZnRSZWcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUganVzdCBiZWZvcmUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHNldHRpbmdzQ2xvbmUuYU5lZykgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSkgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAmJiBzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoICsgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nID8gMSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVNpZ24gJiYgc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU3VmZml4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLnRoYXQudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gZmFjdG9yaXNlIHRoZSBgZ2V0U3RyaW5nKClgIGFuZCBgZ2V0QXJyYXkoKWAgZnVuY3Rpb25zIHNpbmNlIHRoZXkgc2hhcmUgcXVpdGUgYSBsb3Qgb2YgY29kZS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxyXG4gICAgICogVGhlIFwiZ2V0QXJyYXlcIiBtZXRob2Qgb24gdGhlIG90aGVyIGhhbmQgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplQXJyYXkoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGFycmF5IG9yIG9iamVjdHMgdGhhdCBjYW4gYmUgZW5jb2RlZCBhcyBhIEpTT04gc3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxyXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dFR5cGVcIiBmb3IgbW9yZSBkZXRhaWxzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcclxuICAgICAqIEBwYXJhbSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFN0cmluZ09yQXJyYXkoZ2V0QXJyYXlCZWhhdmlvciA9IHRydWUsIHRoYXQpIHtcclxuICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhhdCk7XHJcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcclxuICAgICAgICBjb25zdCBhbGxGb3JtRWxlbWVudHMgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSlgKVswXTtcclxuICAgICAgICBjb25zdCBhaUluZGV4ID0gW107XHJcblxyXG4gICAgICAgIC8vIGFsbCBpbnB1dCBpbmRleFxyXG4gICAgICAgIGNvbnN0IHNjSW5kZXggPSBbXTtcclxuXHJcbiAgICAgICAgLy8gc3VjY2Vzc2Z1bCBjb250cm9sIGluZGV4XHJcbiAgICAgICAgY29uc3QgclN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pO1xyXG5cclxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXHJcbiAgICAgICAgY29uc3QgclN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xyXG5cclxuICAgICAgICAvLyBmcm9tIGpRdWVyeSBzZXJpYWxpemUgbWV0aG9kXHJcbiAgICAgICAgY29uc3QgckNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcclxuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xyXG5cclxuICAgICAgICBsZXQgY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvLyBpbmRleCBvZiBzdWNjZXNzZnVsIGVsZW1lbnRzXHJcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goY291bnQpO1xyXG4gICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaCgtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gaW5kZXggb2YgYWxsIGlucHV0cyB0YWdzIGV4Y2VwdCBjaGVja2JveFxyXG4gICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiAoZmllbGQudHlwZSA9PT0gJycgfHwgZmllbGQudHlwZSA9PT0gJ3RleHQnIHx8IGZpZWxkLnR5cGUgPT09ICdoaWRkZW4nIHx8IGZpZWxkLnR5cGUgPT09ICd0ZWwnKSkge1xyXG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcclxuICAgICAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiByTm9uQXV0b051bWVyaWNUeXBlcy50ZXN0KGZpZWxkLnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoZ2V0QXJyYXlCZWhhdmlvcikge1xyXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcclxuXHJcbiAgICAgICAgICAgICQuZWFjaChmb3JtRmllbGRzLCAoaSwgZmllbGQpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXHJcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xyXG5cclxuICAgICAgICAgICAgJC5lYWNoKGZvcm1QYXJ0cywgaSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtUGFydHNbaV0gPSBgJHtpbnB1dE5hbWV9PSR7bW9kaWZpZWRJbnB1dFZhbHVlfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1QYXJ0cy5qb2luKCcmJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3VzaW4nIGV2ZW50c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAkdGhpc1xyXG4gICAgICogQHBhcmFtIGhvbGRlclxyXG4gICAgICogQHJldHVybnMgeyp9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlcikge1xyXG4gICAgICAgICR0aGlzLm9uKCdmb2N1c2luLmF1dG9OdW1lcmljIG1vdXNlZW50ZXIuYXV0b051bWVyaWMnLCBlID0+IHtcclxuICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcclxuICAgICAgICAgICAgY29uc3QgJHNldHRpbmdzID0gaG9sZGVyLnNldHRpbmdzQ2xvbmU7XHJcbiAgICAgICAgICAgIGlmICggZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiAkc2V0dGluZ3Mud0VtcHR5ID09PSAnZm9jdXMnKSB7XHJcbiAgICAgICAgICAgICAgICAkc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgJHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKG5lZ2F0aXZlQnJhY2tldCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MuZURlYykge1xyXG4gICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLmVEZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCRzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkc2V0dGluZ3MucmF3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgkc2V0dGluZ3MublNlcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2VwID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTaWduID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTdWZmaXggPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHJlc3VsdCA9IGF1dG9TdHJpcCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSkgIT09ICRzZXR0aW5ncy5yYXdWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGhvbGRlci5pblZhbCA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIuaW5WYWw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvbkVtcHR5ID0gY2hlY2tFbXB0eShob2xkZXIuaW5WYWwsICRzZXR0aW5ncywgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKG9uRW1wdHkgIT09IG51bGwgJiYgb25FbXB0eSAhPT0gJycpICYmICRzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlkb3duJyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gJHRoaXNcclxuICAgICAqIEBwYXJhbSBob2xkZXJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbktleWRvd24oJHRoaXMsIGhvbGRlcikge1xyXG4gICAgICAgICR0aGlzLm9uKCdrZXlkb3duLmF1dG9OdW1lcmljJywgZSA9PiB7XHJcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIudGhhdC5yZWFkT25seSkge1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogLy8gVGhlIGNvZGUgYmVsb3cgYWxsb3dzIHRoZSBcImVudGVyXCIga2V5ZG93biB0byB0aHJvdyBhIGNoYW5nZSgpIGV2ZW50XHJcbiAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci5pblZhbCAhPT0gJHRoaXMudmFsKCkpIHtcclxuICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XHJcbiAgICAgICAgICAgICB9ICovXHJcbiAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xyXG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcclxuICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChob2xkZXIucHJvY2Vzc0Fsd2F5cygpKSB7XHJcbiAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50VmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IGluIGRlbGV0aW9uIGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICR0aGlzXHJcbiAgICAgKiBAcGFyYW0gaG9sZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25LZXlwcmVzcygkdGhpcywgaG9sZGVyKSB7XHJcbiAgICAgICAgJHRoaXMub24oJ2tleXByZXNzLmF1dG9OdW1lcmljJywgZSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggZml4IGZvciBTaGlmdCAmJiBpbnNlcnQgcGFzdGUgZXZlbnRcclxuICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGhvbGRlci5wcm9jZXNzZWQ7XHJcbiAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkgfHwgaG9sZGVyLnByb2Nlc3NLZXlwcmVzcygpKSB7XHJcbiAgICAgICAgICAgICAgICBob2xkZXIuZm9ybWF0UXVpY2soZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcclxuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRocm93cyBpbnB1dCBldmVudCBvbiBhZGRpbmcgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdrZXl1cCcgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICR0aGlzXHJcbiAgICAgKiBAcGFyYW0gaG9sZGVyXHJcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3NcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvbktleXVwKCR0aGlzLCBob2xkZXIsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgJHRoaXMub24oJ2tleXVwLmF1dG9OdW1lcmljJywgZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xyXG4gICAgICAgICAgICBob2xkZXIuaW5pdChlKTtcclxuICAgICAgICAgICAgY29uc3Qgc2tpcCA9IGhvbGRlci5za2lwQWx3YXlzKGUpO1xyXG4gICAgICAgICAgICBjb25zdCB0YWIgPSBob2xkZXIua2RDb2RlO1xyXG4gICAgICAgICAgICBob2xkZXIua2RDb2RlID0gMDtcclxuICAgICAgICAgICAgZGVsZXRlIGhvbGRlci52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XHJcblxyXG5cdFx0XHQvLyBhZGRlZCB0byBwcm9wZXJseSBwbGFjZSB0aGUgY2FyZXQgd2hlbiBvbmx5IHRoZSBjdXJyZW5jeSBzaWduIGlzIHByZXNlbnRcclxuICAgICAgICAgICAgaWYgKCR0aGlzWzBdLnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0YWIgPT09IGtleUNvZGUuVGFiKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsICR0aGlzLnZhbCgpLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICgkdGhpc1swXS52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xyXG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcywgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHNhdmVzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHRvIHByZXNlcnZlIHRoZSBkYXRhIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2VcclxuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmVEZWMgIT09IG51bGwgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChza2lwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c291dCcgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICR0aGlzXHJcbiAgICAgKiBAcGFyYW0gaG9sZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlcikge1xyXG4gICAgICAgICR0aGlzLm9uKCdmb2N1c291dC5hdXRvTnVtZXJpYyBtb3VzZWxlYXZlLmF1dG9OdW1lcmljJywgKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoISR0aGlzLmlzKCc6Zm9jdXMnKSkge1xyXG4gICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcclxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3Rvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYVNlcCA9IHNldHRpbmdzLm9TZXA7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYVNpZ24gPSBzZXR0aW5ncy5vU2lnbjtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hU3VmZml4ID0gc2V0dGluZ3Mub1N1ZmZpeDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBzZXR0aW5ncy5vRGVjO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFQYWQgPSBzZXR0aW5ncy5vUGFkO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5CcmFja2V0ID0gc2V0dGluZ3Mub0JyYWNrZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICctJyArIHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKSA9PT0gbnVsbCAmJiBtaW5UZXN0ICYmIG1heFRlc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyArc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5UZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF4VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQoJzAnLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwZWRWYWx1ZSA9IGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKHNldHRpbmdzLnNjYWxlU3ltYm9sKSA/IGdyb3VwZWRWYWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sIDogZ3JvdXBlZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChncm91cGVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci5pblZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNoYW5nZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBob2xkZXIuaW5WYWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICR0aGlzXHJcbiAgICAgKiBAcGFyYW0gaG9sZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25QYXN0ZSgkdGhpcywgaG9sZGVyKSB7XHJcbiAgICAgICAgJHRoaXMub24oJ3Bhc3RlJywgZnVuY3Rpb24oZSkge1xyXG5cdFx0XHQvL0ZJWE1FIEFmdGVyIGEgcGFzdGUsIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIGZhciByaWdodCBvZiB0aGUgaW5wdXQsIGl0IHNob3VsZCBiZSBzZXQgdG8gc29tZXRoaW5nIGxpa2UgYG5ld0NhcmV0UG9zaXRpb24gPSBvbGRDYXJldFBvc2l0aW9uICsgcGFzdGVUZXh0Lmxlbmd0aDtgLCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2xkUmF3VmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMudmFsdWUgfHwgJyc7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSB0aGlzLnNlbGVjdGlvbkVuZCB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQsIGN1cnJlbnRWYWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICBjb25zdCBwYXN0ZWRUZXh0ID0gcHJlcGFyZVBhc3RlZFRleHQoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpLmhvbGRlcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoaXNWYWxpZFBhc3RlVGV4dChwYXN0ZWRUZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlUGFzdGVkVGV4dChwcmVmaXggKyBOdW1iZXIocGFzdGVkVGV4dCkudmFsdWVPZigpICsgc3VmZml4LCBob2xkZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUGFzdGVUZXh0KG5ld1ZhbHVlKSAmJiBOdW1iZXIob2xkUmF3VmFsdWUpLnZhbHVlT2YoKSAhPT0gTnVtYmVyKG5ld1ZhbHVlKS52YWx1ZU9mKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgbmV3VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2lucHV0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXJ0ID0gc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBob2xkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gJHRoaXNcclxuICAgICAqIEBwYXJhbSBob2xkZXJcclxuICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XHJcbiAgICAgICAgJHRoaXMuY2xvc2VzdCgnZm9ybScpLm9uKCdzdWJtaXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoaG9sZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuU2V0T25TdWJtaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHNldHRpbmdzLnJhd1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gaG9sZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBqUXVlcnkgc2VsZWN0ZWQgaW5wdXQgaWYgdGhlIHRhZyBhbmQgdHlwZSBhcmUgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAkdGhpc1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW58Kn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcclxuICAgICAgICAvLyBTdXBwb3J0ZWQgaW5wdXQgdHlwZVxyXG4gICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXHJcbiAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRFbGVtZW50VGFnID0gJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtZW50VGFnICE9PSAnaW5wdXQnICYmICFpc0luQXJyYXkoY3VycmVudEVsZW1lbnRUYWcsIGFsbG93ZWRUYWdMaXN0KSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICRpbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdXRpbmUgdG8gZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlIG9uIHBhZ2UgbG9hZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZXR0aW5nc1xyXG4gICAgICogQHBhcmFtICRpbnB1dFxyXG4gICAgICogQHBhcmFtICR0aGlzXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpIHtcclxuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xyXG5cclxuICAgICAgICBpZiAoJGlucHV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgKiBJZiB0aGUgaW5wdXQgdmFsdWUgaGFzIGJlZW4gc2V0IGJ5IHRoZSBkZXYsIGJ1dCBub3QgZGlyZWN0bHkgYXMgYW4gYXR0cmlidXRlIGluIHRoZSBodG1sLCB0aGVuIGl0IHRha2VzXHJcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXHJcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5hRm9ybWApKS5cclxuICAgICAgICAgICAgICogTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXIgaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxyXG4gICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xyXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cclxuICAgICAgICAgICAgICogSGVuY2UsIGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXHJcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBpZ25vcmUgYGFuRGVmYXVsdGAgYWx0b2dldGhlci5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRm9ybSAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGB2YWx1ZWAgaXMgdmFsaWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKHRlc3RlZEN1cnJlbnRWYWx1ZSkgJiYgSW5maW5pdHkgIT09IHRlc3RlZEN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLyogQ2hlY2tzIGZvciA6XHJcbiAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxyXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIFRoZSBmb2xsb3dpbmcgSFRNTCBkYXRhIGF0dHJpYnV0ZSBpcyBSRVFVSVJFRCAoZGF0YS1hbi1kZWZhdWx0PVwic2FtZSB2YWx1ZSBhcyB0aGUgdmFsdWUgYXR0cmlidXRlXCIpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBSZXBsYWNlIHdoYXRldmVyIGxvY2FsZSBjaGFyYWN0ZXIgaXMgdXNlZCBieSBhICcuJywgYW5kIG5vdCBvbmx5IHRoZSBjb21tYSAnLCcsIGJhc2VkIG9uIHRoZSBsb2NhbGUgdXNlZCBieSB0aGUgdXNlclxyXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwgJiYgc2V0dGluZ3MuYW5EZWZhdWx0LnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChjdXJyZW50VmFsdWUgIT09ICcnICYmICR0aGlzLmF0dHIoJ3R5cGUnKSA9PT0gJ2hpZGRlbicgJiYgISQuaXNOdW1lcmljKGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5lRGVjICE9PSBudWxsICYmIHNldHRpbmdzLmFTdG9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLmFTdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVEZWMgdmFsdWUgc2hvdWxkIE5PVCBiZSBzYXZlZCBpbiBzZXNzaW9uU3RvcmFnZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYVN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRvU3RyaXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgc2V0dGluZ3MuYU5lZyAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIHNldHRpbmdzLmFOZWcgIT09ICcnICYmIGNvbnRhaW5zKGN1cnJlbnRWYWx1ZSwgJy0nKSk/Jy0nICsgYXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzKTphdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mud0VtcHR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZm9jdXMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhbHdheXMnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoc2V0dGluZ3MuYVNpZ24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICcwJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxyXG4gICAgICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0VmFsdWUgJiYgY3VycmVudFZhbHVlID09PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xyXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYW5EZWZhdWx0ID09PSAkdGhpcy50ZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRW5oYW5jZSB0aGUgdXNlciBleHBlcmllbmNlIGJ5IG1vZGlmeWluZyB0aGUgZGVmYXVsdCBgcE5lZ2Agb3B0aW9uIGRlcGVuZGluZyBvbiBgYVNpZ25gIGFuZCBgcFNpZ25gLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gKGBwTmVnYCksIGJ1dCBoYXMgc2V0IGEgY3VycmVuY3kgc3ltYm9sIChgYVNpZ25gKSxcclxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBwTmVnYCBpbiBvcmRlciB0byBrZWVwIHRoZSByZXN1bHRpbmcgb3V0cHV0IGxvZ2ljYWwgYnkgZGVmYXVsdCA6XHJcbiAgICAgKiAtIFwiJC0xLDIzNC41NlwiIGluc3RlYWQgb2YgXCItJDEsMjM0LjU2XCIgKHthU2lnbjogXCIkXCIsIHBOZWc6IFwiclwifSlcclxuICAgICAqIC0gXCItMSwyMzQuNTYkXCIgaW5zdGVhZCBvZiBcIjEsMjM0LjU2LSRcIiAoe2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInBcIn0pXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBjb3JyZWN0UE5lZ09wdGlvbihvcHRpb25zLCBzZXR0aW5ncykge1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQob3B0aW9ucykgJiYgaXNVbmRlZmluZWRPck51bGxPckVtcHR5KG9wdGlvbnMucE5lZykgJiYgb3B0aW9ucy5hU2lnbiAhPT0gJycpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5wU2lnbikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncyc6XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucE5lZyA9ICdwJztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnBOZWcgPSAncic7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbmFseXNlIHRoZSBzZXR0aW5ncy9vcHRpb25zIHBhc3NlZCBieSB0aGUgdXNlciwgdmFsaWRhdGUgYW5kIGNsZWFuIHRoZW0sIHRoZW4gcmV0dXJuIHRoZW0uXHJcbiAgICAgKiBOb3RlOiBUaGlzIHJldHVybnMgYG51bGxgIGlmIHNvbWVob3cgdGhlIHNldHRpbmdzIHJldHVybmVkIGJ5IGpRdWVyeSBpcyBub3QgYW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gJHRoaXNcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzKSB7XHJcbiAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIFwiYXV0b051bWVyaWNcIiBzZXR0aW5ncy4gSWYgdGhleSBkbyBub3QgZXhpc3QsIGl0IHJldHVybnMgXCJ1bmRlZmluZWRcIi5cclxuICAgICAgICBsZXQgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG5cclxuICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcclxuICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgSFRNTDUgZGF0YSwgaWYgaXQgZG9lc24ndCBleGlzdCwgd2UnbGwgZ2V0IFwidW5kZWZpbmVkXCJcclxuICAgICAgICAgICAgY29uc3QgdGFnRGF0YSA9ICR0aGlzLmRhdGEoKTtcclxuXHJcbiAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdGFnRGF0YSwgb3B0aW9ucywge1xyXG4gICAgICAgICAgICAgICAgb25PZmYgICAgICAgICAgIDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICA6ICcnLFxyXG4gICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHRocm93SW5wdXQgICAgICA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgIDogYWxsb3dlZFRhZ0xpc3QsXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnXHJcbiAgICAgICAgICAgICQuZWFjaChzZXR0aW5ncywgKGtleSwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyAndHJ1ZScgYW5kICdmYWxzZScgdG8gcmVhbCBCb29sZWFuXHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZSA9PT0gJ3RydWUnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgbnVtYmVycyBpbiBvcHRpb25zIHRvIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgIC8vVE9ETyBpZiBhIHZhbHVlIGlzIG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbXByb3ZlIHRoZSBgcE5lZ2Agb3B0aW9uIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICBjb3JyZWN0UE5lZ09wdGlvbihvcHRpb25zLCBzZXR0aW5ncyk7XHJcblxyXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3NcclxuICAgICAgICAgICAgdmFsaWRhdGUoc2V0dGluZ3MsIGZhbHNlKTsgLy8gVGhyb3dzIGlmIG5lY2Vzc2FyeVxyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgbmV3IHNldHRpbmdzXHJcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1ldGhvZHMgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IG1ldGhvZHMgPSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIGluaXRpYXRlIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXHJcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnKTsgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCk7ICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyh7b3B0aW9uc30pOyAgICAgICAgIC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluaXQob3B0aW9ucykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc051bGwoc2V0dGluZ3MpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMsIHNjYWxlRGl2aXNvciAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxyXG4gICAgICAgICAgICAgICAga2VlcE9yaWdpbmFsU2V0dGluZ3Moc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGhvbGRlciA9IGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3QgdGhlIG5leHQgbGluZSBiZSBpbiB0aGUgYGdldEluaXRpYWxTZXR0aW5ncygpYCBmdW5jdGlvbj9cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbCkgPyBzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiBzZXR0aW5ncy5tRGVjO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlID09PSBmYWxzZSAmJiBzZXR0aW5ncy5hRm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdERlZmF1bHRWYWx1ZU9uUGFnZUxvYWQoc2V0dGluZ3MsICRpbnB1dCwgJHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnJ1bk9uY2UgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxyXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25LZXlkb3duKCR0aGlzLCBob2xkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IG9uS2V5cHJlc3MoJHRoaXMsIGhvbGRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25LZXl1cCgkdGhpcywgaG9sZGVyLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gb25QYXN0ZSgkdGhpcywgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWV0aG9kIHRvIHJlbW92ZSBzZXR0aW5ncyBhbmQgc3RvcCBhdXRvTnVtZXJpYygpIC0gZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gZGVzdHJveXMgYXV0b051bWVyaWNcclxuICAgICAgICAgKiBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZGVzdHJveSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMucmVtb3ZlRGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGFuZCBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHNcclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyByZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxyXG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB3aXBlKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNZXRob2QgdGhhdCB1cGRhdGVzIHRoZSBhdXRvTnVtZXJpYyBzZXR0aW5nc1xyXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICogVGhlIG9wdGlvbnMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzZXR0aW5ncyAoaWUuIHthU2VwOiBcIi5cIiwgYURlYzogXCIsXCIsIGFTaWduOiAn4oKsICd9KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyB1cGRhdGVzIHRoZSBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHVwZGF0ZShvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSBhbGwgdGhpcyBkdXBsaWNhdGVkIGNvZGUgd2l0aCBhIGNhbGwgdG8gYGdldEluaXRpYWxTZXR0aW5ncygpYFxyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcInVwZGF0ZVwiIG1ldGhvZGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9ICQuZXh0ZW5kKHNldHRpbmdzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IChzZXR0aW5ncy5zY2FsZURlY2ltYWwpID8gc2V0dGluZ3Muc2NhbGVEZWNpbWFsIDogc2V0dGluZ3MubURlYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGtlZXBPcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgIGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSBzZXR0aW5ncy5hU2VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYURlYzogXCIke3NldHRpbmdzLmFEZWN9XCIgYW5kIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwOiBcIiR7c2V0dGluZ3MuYVNlcH1cIiBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW1wcm92ZSB0aGUgYHBOZWdgIG9wdGlvbiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGNvcnJlY3RQTmVnT3B0aW9uKG9wdGlvbnMsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoJHRoaXMudmFsKCkgIT09ICcnIHx8ICR0aGlzLnRleHQoKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnc2V0JywgJ3ZhbHVlJyk7IC8vIGZvcm1hdHMgdGhlIHZhbHVlIGJlaW5nIHBhc3NlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxyXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSBpcyBwYXNzZWQgYXMgYSBzdHJpbmcsIGl0IGNhbiBiZSBhbiBpbnRlZ2VyICcxMjM0JyBvciBhIGRvdWJsZSAnMTIzNC41Njc4OSdcclxuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0geyp9IG5ld1ZhbHVlXHJcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHNldChuZXdWYWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBudWxsIHx8IGlzVW5kZWZpbmVkKG5ld1ZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWRcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBiZWluZyBzZXQgaXMgbm90IG51bWVyaWNcclxuICAgICAgICAgICAgICAgIGlmICghJC5pc051bWVyaWMoTnVtYmVyKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkaW5wdXQgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2tzIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiBtYXggcmFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmICFzZXR0aW5ncy5vbk9mZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbCA6IHNldHRpbmdzLm1EZWM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lRGVjID09PSBudWxsICYmIHNldHRpbmdzLnNjYWxlRGl2aXNvciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9Hcm91cCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVN0b3IgJiYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub25PZmYgJiYgc2V0dGluZ3Muc2NhbGVTeW1ib2wpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2w7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnRleHQodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygndW5TZXQnKTsgLy8gbm8gcGFyYW1ldGVyIGFjY2VwdGVkXHJcbiAgICAgICAgICogYnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXHJcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dFR5cGVcIiBmb3IgbW9yZSBkZXRhaWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdW5TZXQoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXHJcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpOyAvLyBubyBwYXJhbWV0ZXJzIGFjY2VwdGVkXHJcbiAgICAgICAgICogdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlICd1blNldCcgbWV0aG9kIHRvIHJlZm9ybWF0IHRoZSBpbnB1dFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlU2V0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlIGFzIGEgc3RyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgLy9UT0RPIFdoeSB3b3VsZCB3ZSBuZWVkIHRvIGdldCBhIG5ldyByZWZlcmVuY2UgdG8gJHRoaXMgc2luY2UgaXQgaGFzIGJlZW4gZG9uZSBpbiBgaW5pdCgpYD9cclxuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBsb29rcyBhIGxvdCBsaWtlIGBnZXRJbnB1dElmU3VwcG9ydGVkVGFnQW5kVHlwZSgpYC4gSXMgdGhhdCBuZWNlc3Nhcnk/IENhbiB0aGUgaW5wdXQgZWxlbWVudCBiZSBjaGFuZ2VkIHNpbmNlIGF1dG9OdW1lcmljIGhhcyBiZWVuIGluaXRpYWxpemVkP1xyXG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZGApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIGVsZW1lbnQgdHlwZSB0aGVuIHVzZSAuZXEoMCkgc2VsZWN0b3IgdG8gZ3JhYiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW4gc2VsZWN0b3JcclxuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNJbkFycmF5KCR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpLCBzZXR0aW5ncy50YWdMaXN0KSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS50ZXh0KCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgXCI8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+XCIgdGFnIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgfHwgc2V0dGluZ3Muc2NhbGVEaXZpc29yKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoKC9cXGQvKS50ZXN0KHZhbHVlKSB8fCBOdW1iZXIodmFsdWUpID09PSAwKSAmJiBzZXR0aW5ncy53RW1wdHkgPT09ICdmb2N1cycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnICYmIHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGF1dG9TdHJpcCh2YWx1ZSwgc2V0dGluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBhIG51bWVyaWMgc3RyaW5nXHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSwgYnV0IGZvbGxvd2luZyB0aGUgYG91dHB1dFR5cGVgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XHJcbiAgICAgICAgICogLSBhIHN0cmluZyAodGhhdCBjb3VsZCBvciBjb3VsZCBub3QgcmVwcmVzZW50IGEgbnVtYmVyIChpZS4gXCIxMjM0NSw2Ny1cIikpLCBvclxyXG4gICAgICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGUgcmV0dXJuZWQgdmFsdWVzIGFyZSBhbiBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cclxuICAgICAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRUeXBlXCIgb3B0aW9uIGRlZmluaXRpb24gZm9yIG1vcmUgZGV0YWlscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldExvY2FsaXplZCgpIHtcclxuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KHRoaXMpO1xyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChOdW1iZXIodmFsdWUpID09PSAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dFR5cGUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXHJcbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XHJcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJzAnKSB8fCAhKCd2YWx1ZScgaW4gdGhpc1swXSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0VHlwZVwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U3RyaW5nKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cclxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcclxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0VHlwZVwiIGZvciBkZXRhaWxzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0QXJyYXkoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIHRoZSBvYmplY3Qgd2l0aCBhdXRvTnVtZXJpYyBzZXR0aW5ncyBmb3IgdGhvc2Ugd2hvIG5lZWQgdG8gbG9vayB1bmRlciB0aGUgaG9vZFxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxyXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKS5hRGVjOyAvLyByZXR1cm4gdGhlIGFEZWMgc2V0dGluZyBhcyBhIHN0cmluZyAtIGFudCB2YWxpZCBzZXR0aW5nIGNhbiBiZSB1c2VkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCh0aGlzKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cclxuICAgICAqIEl0IGluaXRpYWxpemUgYXV0b051bWVyaWMgb24gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgfHwgIW1ldGhvZCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXHJcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZGVmYXVsdCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XHJcblxyXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IGRlZmF1bHRTZXR0aW5nczsgLy8gTWFrZSB0aG9zZSBzZXR0aW5ncyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlclxyXG4gICAgICovXHJcbiAgICBhdXRvRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPCAwKSB7XHJcbiAgICAgICAgICAgIHNldHRpbmdzLmFOZWcgPSAnLSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdCB2TWF4ID0gc2V0dGluZ3Mudk1heC50b1N0cmluZygpLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZNaW4gPSAoIXNldHRpbmdzLnZNaW4gJiYgc2V0dGluZ3Mudk1pbiAhPT0gMCkgPyBbXSA6IHNldHRpbmdzLnZNaW4udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBhdXRvQ2hlY2sodmFsdWUsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgaWYgKCFtaW5UZXN0IHx8ICFtYXhUZXN0KSB7XHJcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XHJcbiAgICAgICAgICAgIHNlbmRDdXN0b21FdmVudCgnYXV0b0Zvcm1hdC5hdXRvTnVtZXJpYycsIGBSYW5nZSB0ZXN0IGZhaWxlZGApO1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgdk1pbiBbJHtzZXR0aW5ncy52TWlufV0gYW5kIHZNYXggWyR7c2V0dGluZ3Mudk1heH1dIHJhbmdlIHNldCBmb3IgdGhpcyBlbGVtZW50YCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmFEZWN9YDtcclxuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcclxuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcclxuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xyXG4gICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoYXV0b1N0cmlwLCAnJyk7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcclxuICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5vdXRwdXRUeXBlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLmF1dG9VbmZvcm1hdCA9IGF1dG9VbkZvcm1hdDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiBvcHRpb24gb2JqZWN0LlxyXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cclxuICAgICAqXHJcbiAgICAgKiBUaGlzIHRlc3RzIGlmIHRoZSBvcHRpb25zIGFyZSBub3QgY29uZmxpY3RpbmcgYW5kIGFyZSB3ZWxsIGZvcm1hdHRlZC5cclxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHVzZXJPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXHJcbiAgICAgKiBAdGhyb3dzIEVycm9yXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcclxuICAgICAgICBjb25zdCBkZWJ1ZyA9IHRydWU7IC8vIFRoZSBlcnJvciBoZXJlIG11c3QgYWx3YXlzIGJlIHRocm93biwgc2luY2UgYSBiYWRseSBjb25maWd1cmVkIG9wdGlvbnMgb2JqZWN0IHdpbGwgbGVhZCB0byB3cm9uZyByZXN1bHRzLCBpZiBhbnkuXHJcblxyXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XHJcbiAgICAgICAgbGV0IG9wdGlvbnM7XHJcbiAgICAgICAgaWYgKHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlSW50ZWdlciA9IC9eWzAtOV0rJC87XHJcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcclxuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcclxuICAgICAgICBjb25zdCB0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKyk/JC87XHJcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcclxuXHJcbiAgICAgICAgLy8gVGhlbiB0ZXN0cyB0aGUgb3B0aW9ucyBpbmRpdmlkdWFsbHlcclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFTZXAsIFsnLCcsICcuJywgJyAnLCAnJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnYVNlcCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJyAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuYVNlcH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMublNlcCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5TZXApKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnblNlcCcgb3B0aW9uIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLm5TZXB9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZEdyb3VwKSkgeyAvLyBpc05hTihwYXJzZUludChvcHRpb25zLmRHcm91cCkpIC8vREVCVUdcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RHcm91cCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZEdyb3VwfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmFEZWMsIFsnLCcsICcuJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdhRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJyBvciAnLCcsIFske29wdGlvbnMuYURlY31dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxyXG4gICAgICAgIGlmIChvcHRpb25zLmFEZWMgPT09IG9wdGlvbnMuYVNlcCkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAnYURlYycgWyR7b3B0aW9ucy5hRGVjfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgJ2FTZXAnIFske29wdGlvbnMuYVNlcH1dIGFyZSB0aGUgc2FtZSBjaGFyYWN0ZXIuYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmFsdERlYykgJiYgIWlzU3RyaW5nKG9wdGlvbnMuYWx0RGVjKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2FsdERlYycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5hbHREZWN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLmFTaWduICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hU2lnbikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGN1cnJlbmN5IHN5bWJvbCBvcHRpb24gJ2FTaWduJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLmFTaWdufV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnBTaWduLCBbJ3AnLCAncyddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBjdXJyZW5jeSBzaWduIG9wdGlvbiAncFNpZ24nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSBvciAncycgKHN1ZmZpeCksIFske29wdGlvbnMucFNpZ259XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucE5lZywgWydwJywgJ3MnLCAnbCcsICdyJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIG5lZ2F0aXZlIHNpZ24gb3B0aW9uICdwTmVnJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAncCcgKHByZWZpeCksICdzJyAoc3VmZml4KSwgJ2wnIChsZWZ0KSBvciAncicgKHJpZ2h0KSwgWyR7b3B0aW9ucy5wTmVnfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuYVN1ZmZpeCkgfHwgKG9wdGlvbnMuYVN1ZmZpeCAhPT0gJycgJiYgKGNvbnRhaW5zKG9wdGlvbnMuYVN1ZmZpeCwgJy0nKSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuYVN1ZmZpeCkpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWRkaXRpb25hbCBzdWZmaXggb3B0aW9uICdhU3VmZml4JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIG5vdCBjb250YWlucyB0aGUgbmVnYXRpdmUgc2lnbiAnLScgbm9yIGFueSBudW1lcmljYWwgY2hhcmFjdGVycywgWyR7b3B0aW9ucy5hU3VmZml4fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm9MaW1pdHMpICYmICFpc0luQXJyYXkob3B0aW9ucy5vTGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBvdmVycmlkZSBtaW4gJiBtYXggbGltaXRzIG9wdGlvbiAnb0xpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm9MaW1pdHN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy52TWF4KSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLnZNYXgpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAndk1heCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMudk1heH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnZNaW4pIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMudk1pbikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICd2TWluJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy52TWlufV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLnZNaW4pID4gcGFyc2VGbG9hdChvcHRpb25zLnZNYXgpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ3ZNaW4nIFske29wdGlvbnMudk1pbn1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5tRGVjKSAmJiAoIWlzU3RyaW5nKG9wdGlvbnMubURlYykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLm1EZWMpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdtRGVjJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5tRGVjfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIW9wdGlvbnMuYVBhZCAmJiAhaXNOdWxsKG9wdGlvbnMubURlYykpIHtcclxuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnYVBhZCcgdG8gW2ZhbHNlXSB3aWxsIG92ZXJyaWRlIHRoZSBjdXJyZW50ICdtRGVjJyBzZXR0aW5nIFske29wdGlvbnMubURlY31dLmAsIGRlYnVnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlIGluIHRoZSBjb25zb2xlIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBpbiB2TWluL3ZNYXggaXMgb3ZlcnJpZGRlbiBieSBtRGVjIChhbmQgbm90IGlmIG1EZWMgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBkZWNpbWFsIHVzZWQgaW4gdk1pbi92TWF4KVxyXG4gICAgICAgIGxldCBkcFZNaW4gPSBkZWNpbWFsUGxhY2VzKG9wdGlvbnMudk1pbik7XHJcbiAgICAgICAgbGV0IGRwVk1heCA9IGRlY2ltYWxQbGFjZXMob3B0aW9ucy52TWF4KTtcclxuICAgICAgICBkcFZNaW4gPSBpc051bGwoZHBWTWluKT8wOmRwVk1pbjtcclxuICAgICAgICBkcFZNYXggPSBpc051bGwoZHBWTWF4KT8wOmRwVk1heDtcclxuICAgICAgICBjb25zdCB2TWluTWF4RGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KGRwVk1pbiwgZHBWTWF4KTtcclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm1EZWMpICYmXHJcbiAgICAgICAgICAgICgoaGFzRGVjaW1hbHMob3B0aW9ucy52TWluKSB8fCBoYXNEZWNpbWFscyhvcHRpb25zLnZNYXgpKSAmJiB2TWluTWF4RGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMubURlYykpKSB7XHJcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ21EZWMnIHRvIFske29wdGlvbnMubURlY31dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICd2TWluJyBbJHtvcHRpb25zLnZNaW59XSBhbmQgJ3ZNYXgnIFske29wdGlvbnMudk1heH1dLmAsIGRlYnVnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZURlYykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmVEZWMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5lRGVjKSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2VEZWMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmVEZWN9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJlRGVjXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJtRGVjXCJcclxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmVEZWMpICYmICFpc051bGwob3B0aW9ucy5tRGVjKSAmJiBOdW1iZXIob3B0aW9ucy5tRGVjKSA8IE51bWJlcihvcHRpb25zLmVEZWMpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdlRGVjJyBbJHtvcHRpb25zLmVEZWN9XSBpcyBncmVhdGVyIHRoYW4gdGhlICdtRGVjJyBbJHtvcHRpb25zLm1EZWN9XSB2YWx1ZS5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIGRpdmlzb3Igb3B0aW9uICdzY2FsZURpdmlzb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIsIHByZWZlcmFibHkgYW4gaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURpdmlzb3J9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEZWNpbWFsKSAmJiAhdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuc2NhbGVEZWNpbWFsKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWx9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgc3ltYm9sIG9wdGlvbiAnc2NhbGVTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc2NhbGVTeW1ib2x9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFTdG9yKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYVN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzYXZlIHRvIHNlc3Npb24gc3RvcmFnZSBvcHRpb24gJ2FTdG9yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5hU3Rvcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5tUm91bmQsIFtcclxuICAgICAgICAgICAgJ1MnLFxyXG4gICAgICAgICAgICAnQScsXHJcbiAgICAgICAgICAgICdzJyxcclxuICAgICAgICAgICAgJ2EnLFxyXG4gICAgICAgICAgICAnQicsXHJcbiAgICAgICAgICAgICdVJyxcclxuICAgICAgICAgICAgJ0QnLFxyXG4gICAgICAgICAgICAnQycsXHJcbiAgICAgICAgICAgICdGJyxcclxuICAgICAgICAgICAgJ04wNScsXHJcbiAgICAgICAgICAgICdDSEYnLFxyXG4gICAgICAgICAgICAnVTA1JyxcclxuICAgICAgICAgICAgJ0QwNScsXHJcbiAgICAgICAgXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ21Sb3VuZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ1MnLCAnQScsICdzJywgJ2EnLCAnQicsICdVJywgJ0QnLCAnQycsICdGJywgJ04wNScsICdDSEYnLCAnVTA1JyBvciAnRDA1JyAoY2YuIGRvY3VtZW50YXRpb24pLCBbJHtvcHRpb25zLm1Sb3VuZH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuYVBhZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmFQYWQpKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FQYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFQYWR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubkJyYWNrZXQpICYmICFpc0luQXJyYXkob3B0aW9ucy5uQnJhY2tldCwgWycoLCknLCAnWyxdJywgJzwsPicsICd7LH0nXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduQnJhY2tldCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uQnJhY2tldH1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy53RW1wdHksIFsnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJywgJ3plcm8nXSkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpc3BsYXkgb24gZW1wdHkgc3RyaW5nIG9wdGlvbiAnd0VtcHR5JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJyBvciAnemVybycsIFske29wdGlvbnMud0VtcHR5fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmxaZXJvLCBbJ2FsbG93JywgJ2RlbnknLCAna2VlcCddKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbGVhZGluZyB6ZXJvIGJlaGF2aW9yIG9wdGlvbiAnbFplcm8nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdhbGxvdycsICdkZW55JyBvciAna2VlcCcsIFske29wdGlvbnMubFplcm99XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFGb3JtKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYUZvcm0pKSB7XHJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBmb3JtYXQgb24gaW5pdGlhbGl6YXRpb24gb3B0aW9uICdhRm9ybScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYUZvcm19XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNOdW1iZXIpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zTnVtYmVyKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc051bWJlcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc051bWJlcn1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5hbkRlZmF1bHQpICYmIChvcHRpb25zLmFuRGVmYXVsdCAhPT0gJycgJiYgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5hbkRlZmF1bHQpKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZSBvcHRpb24gJ2FuRGVmYXVsdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuYW5EZWZhdWx0fV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy51blNldE9uU3VibWl0KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMudW5TZXRPblN1Ym1pdCkpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuU2V0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuU2V0T25TdWJtaXR9XSBnaXZlbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3V0cHV0VHlwZSkgJiYgIWlzSW5BcnJheShvcHRpb25zLm91dHB1dFR5cGUsIFtcclxuICAgICAgICAgICAgJ3N0cmluZycsXHJcbiAgICAgICAgICAgICdudW1iZXInLFxyXG4gICAgICAgICAgICAnLicsXHJcbiAgICAgICAgICAgICctLicsXHJcbiAgICAgICAgICAgICcsJyxcclxuICAgICAgICAgICAgJy0sJyxcclxuICAgICAgICAgICAgJy4tJyxcclxuICAgICAgICAgICAgJywtJyxcclxuICAgICAgICBdKSkge1xyXG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VzdG9tIGxvY2FsZSBmb3JtYXQgb3B0aW9uICdvdXRwdXRUeXBlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSBudWxsLCAnc3RyaW5nJywgJ251bWJlcicsICcuJywgJy0uJywgJywnLCAnLSwnLCAnLi0nIG9yICcsLScsIFske29wdGlvbnMub3V0cHV0VHlwZX1dIGdpdmVuLmApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZGVidWcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5kZWJ1ZykpIHtcclxuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZGVidWcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmRlYnVnfV0gZ2l2ZW4uYCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAkLmZuLnZhbGlkYXRlID0gdmFsaWRhdGU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxyXG4gICAgICogY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gZGV0YWlsXHJcbiAgICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gZGV0YWlsXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb2x5ZmlsbCBmcm9tIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DdXN0b21FdmVudC9DdXN0b21FdmVudCBmb3Igb2Jzb2xldGUgYnJvd3NlcnMgKElFKVxyXG4gICAgICovXHJcbiAgICAoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xyXG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xyXG4gICAgICAgICAgICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcclxuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XHJcbiAgICAgICAgd2luZG93LkN1c3RvbUV2ZW50ID0gQ3VzdG9tRXZlbnQ7XHJcbiAgICB9KSgpO1xyXG59KSk7XHJcblxyXG4vKipcclxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxyXG4gICAgdW5Gb3JtYXQ6IGF1dG9VbkZvcm1hdCxcclxuICAgIGdldERlZmF1bHRDb25maWcsXHJcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XHJcbiAgICBhcmVTZXR0aW5nc1ZhbGlkLCAvL2FuLmFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgOiByZXR1cm4gdHJ1ZSBvciBmYWxzZSAvL1RPRE8gSXMgdGhpcyByZWR1bmRhbnQ/IFNob3VsZCB3ZSBsZXQgdGhlIGRldmVsb3BlcnMgd3JhcCBlYWNoIGF1dG9OdW1lcmljLnZhbGlkYXRlKCkgY2FsbHMgaW4gdHJ5L2NhdGNoIGJsb2NrPyBPciBzaG91bGQgd2UganVzdCBmYWNpbGl0YXRlIHRoZWlyIGxpZmUgYnkgZG9pbmcgaXQgYWxyZWFkeT9cclxuXHJcbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcclxuICAgIC8vaW5pdCAgICAgICAgIDogYW4uaW5pdChvcHRpb25zLCBpbnB1dClcclxuICAgIC8vZ2V0ICAgICAgICAgIDogYW4uZ2V0KGlucHV0KVxyXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxyXG4gICAgLy9mb3JtU3RyaW5nICAgOiBhbi5mb3JtU3RyaW5nKGZvcm0pXHJcbiAgICAvL2Zvcm1BcnJheSAgICA6IGFuLmZvcm1BcnJheShmb3JtKVxyXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXHJcbiAgICAvL3Vuc2V0ICAgICAgICA6IGFuLnVuc2V0KGlucHV0KSAvL3RvIHJlbmFtZSB0byAndW5mb3JtYXQnPyAoYW5kIG1lcmdlIHdpdGggYXV0b1VuRm9ybWF0L3VuRm9ybWF0PylcclxuICAgIC8vcmVmb3JtYXQgICAgIDogYW4ucmVmb3JtYXQoaW5wdXQpIC8vICdyZVNldCcgaXMgdmVyeSB0byBjbG9zZSB0byAncmVzZXQnIGFuZCB0aGVyZWZvcmUgc2hvdWxkIGJlIHJlbmFtZWQuIFdlIGNvdWxkIHN0aWxsIGV4cG9zZSAncmVTZXQnLCBidXQgYWRkIGEgQGRlcHJlY2F0ZWQgdGFnIG9uIGl0cyBkZWNsYXJhdGlvbi5cclxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXHJcbiAgICAvL3VwZGF0ZSAgICAgICA6IGFuLnVwZGF0ZShvcHRpb25zLCBpbnB1dClcclxuICAgIC8vd2lwZSAgICAgICAgIDogYW4ud2lwZShpbnB1dClcclxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vQzovVXNlcnMvYm9ia24vRG9jdW1lbnRzL0dpdEh1Yi9hdXRvTnVtZXJpYy9zcmMvYXV0b051bWVyaWMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;