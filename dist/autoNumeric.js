(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *               autoNumeric.js\n *\n * @version      2.0-beta.14\n * @date         2016-12-23 UTC 14:00\n *\n * @author       Bob Knothe\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users, cf. AUTHORS.md.\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n * @since        2009-08-09\n *\n * @summary      autoNumeric is a jQuery plugin that automatically formats currency\n * (money) and numbers as-you-type in a form inputs. It supports most\n * international numeric formats and currency signs including those used in\n * Europe, North and South America, Asia, as well as India's' lakhs.\n *\n *               Note : Some functions are borrowed from big.js\n * @link         https://github.com/MikeMcl/big.js/\n *\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n *\n * @license      Released under the MIT License\n * @link         http://www.opensource.org/licenses/mit-license.php\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following:\n * - HTML5 data attributes\n * - Options passed by the 'init' or 'update' methods\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand separator characters\n     * comma = \",\"\n     * period \"full stop\" = \".\"\n     * apostrophe is escaped = \"\\\"\"\n     * space = \" \"\n     * none = \"\"\n     * NOTE: do not use numeric characters\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* When true => removes the thousand separator, currency symbol & suffix \"focusin\"\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters\n     * period \"full stop\" = \".\"\n     * comma = \",\"\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare alternative decimal separator which is automatically replaced by decimalCharacter\n     * developed for countries the use a comma \",\" as the decimal character\n     * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"}\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"}\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    negativePositiveSignPlacement: 'l',\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /*\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    roundingMethod: 'S',\n\n    /* Controls decimal padding\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * negativeBracketsTypeOnBlur: null - (default)\n     * negativeBracketsTypeOnBlur: '(,)', negativeBracketsTypeOnBlur: '[,]', negativeBracketsTypeOnBlur: '<,>' or negativeBracketsTypeOnBlur: '{,}'\n     * Deprecated older option name : nBracket\n     */\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value on initialization\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thrown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true,\n\n    /*\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n     */\n    failOnUnknownOption: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param {string} value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param {string} text\n     * @param {AutoNumericHolder} holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {*} needle\n     * @param {Array} array\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param {Event} event\n     * @returns {string|Number}\n     */\n    function key(event) {\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n     *\n     * @param {string} value\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n     * @returns {boolean}\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign on the first character.\n     *\n     * @param {string} string A number represented by a string\n     * @returns {boolean}\n     */\n    function isNegative(string) {\n        return string.charAt(0) === '-';\n    }\n\n    /**\n     * Return the negative version of the value (represented as a string) given as a parameter.\n     *\n     * @param {string} value\n     * @returns {*}\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegative(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\n     * Insert a character or a string at the index given (0 being the far left side).\n     *\n     * @param {string} str\n     * @param {string} char\n     * @param {int} caretPosition\n     * @returns {string}\n     */\n    function insertCharAtPosition(str, char, caretPosition) {\n        return '' + str.slice(0, caretPosition) + char + str.slice(caretPosition);\n    }\n\n    /**\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n     *\n     * @param {string} string\n     * @param {int} index\n     * @param {string} newCharacter\n     * @returns {string}\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n     *\n     * @param {string|number} value\n     * @param {object} settings\n     * @returns {number}\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n     *\n     * @param {string} formattedNumberString\n     * @param {int} caretPosition This must be a positive integer\n     * @param {string} decimalCharacter\n     * @returns {number}\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n     *\n     * @example\n     * 1234567|89.01   : position 7 (rawNumberString)\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\n     *\n     * @param {string} rawNumberString\n     * @param {int} caretPositionInRawValue\n     * @param {string} formattedNumberString\n     * @param {string} decimalCharacter\n     * @returns {*}\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\n     * Return the number of dot '.' in the given text.\n     *\n     * @param {string} text\n     * @returns {number}\n     */\n    function countDotsInText(text) {\n        return countCharInText('.', text);\n    }\n\n    /**\n     * Count the number of occurrence of the given character, in the given text.\n     *\n     * @param {string} character\n     * @param {string} text\n     * @returns {number}\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\n     * Return the index that can be used to set the caret position.\n     * This takes into account that the position is starting at '0', not 1.\n     *\n     * @param {int} characterCount\n     * @returns {number}\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @returns {{}}\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @param {int} start\n     * @param {int|null} end\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     *\n     * @param {string} minimumValue\n     * @param {string} maximumValue\n     * @returns {number}\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted non-number characters and leave only a number alert\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} leftOrAll\n     * @returns {string|*}\n     */\n\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.onOff && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Sets or removes brackets on negative values, depending on the focus state.\n     * The focus state is 'stored' in the settings object under the `settings.onOff` attribute. //TODO Use another object to keep track of internal data that are not settings\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Convert locale format to Javascript numeric string\n     * Allows locale decimal separator to be a period or a comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     *\n     * @param {string} s\n     * @returns {string|void|XML|*}\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     *\n     * @param {string|null} value\n     * @param {string} locale\n     * @returns {*}\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = contains(value, '-') ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = contains(result, '-') ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is formatted with decimals\n            s += '0.00';\n        }\n\n        return s;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character to use those defined in the settings.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Modify the input value by adding the group separators, as defined in the settings.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        if (settings.trailingNegative && !contains(inputValue, '-')) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isNegative = contains(inputValue, '-');\n        if (isNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || inputValue.charAt(0) === '-')) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n        settings.trailingNegative = false;\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param {int} temporaryDecimalPlacesOverride\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * Round the input value using the rounding method defined in the settings.\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\n     *\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (inputValue.charAt(0) === '-') {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (nSign === '-' && Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} isPaste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {number|string} n A numeric value.\n     * @returns {{}}\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings.\n     * This uses the parsed strings for the above parseStr function.\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {object} y Big number instance\n     * @param {object} x Big number instance\n     * @returns {*}\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * Thanks to Anthony & Evan C\n     *\n     * @param {Element|string} element\n     * @returns {*|jQuery|HTMLElement}\n     */\n    function getCurrentElement(element) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n     * This is taken from Quirksmode.\n     *\n     * @param {string} name\n     * @returns {*}\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported.\n     * This is taken from Modernizr.\n     *\n     * @returns {boolean}\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n     *\n     * @param {Element|EventTarget} element\n     * @param {object} settings\n     * @param {string} action\n     * @returns {*}\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\n         * Update the current value, key states (Ctrl, Shift and Command keys), selection and some other keycodes.\n         *\n         * @param {Event} e\n         * @private\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateFieldProperties',\n            value: function _updateFieldProperties(e) {\n                this.value = this.that.value;\n                this.ctrlKey = e.ctrlKey;\n                this.cmdKey = e.metaKey;\n                this.shiftKey = e.shiftKey;\n\n                // Keypress event overwrites meaningful value of e.keyCode\n                this.selection = getElementSelection(this.that);\n                if (e.type === 'keydown' || e.type === 'keyup') {\n                    this.kdCode = e.keyCode;\n                }\n                this.which = e.which;\n            }\n\n            /**\n             * Set the text selection inside the input with the given start and end position.\n             *\n             * @param {int} start\n             * @param {int} end\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\n             * Set the caret position inside the input at the given position.\n             *\n             * @param {int} pos\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\n             * @private\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                //FIXME `this.selection` can sometimes be undefined, found why and fix it\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are unformatted (stripped) of any non-numbers characters.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n             * @private\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n\n\n                var stripZeros = this.kdCode === keyCode.Hyphen && Number(left) === 0 ? false : true;\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                }\n\n                settingsClone.trailingNegative = false;\n\n                return [left, right];\n            }\n\n            /**\n             * Strip parts from excess characters and leading zeros.\n             *\n             * @param {string} left\n             * @param {string} right\n             * @returns {[*,*]}\n             * @private\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = this.kdCode === keyCode.Hyphen && Number(left) === 0 ? false : true;\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && this.kdCode === 48 && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !contains(left, '-')) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n             *\n             * @param {string} left\n             * @param {string} right\n             * @param {boolean} isPaste\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = '';\n                    } else {\n                        settingsClone.rawValue = testValue;\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * Helper function for `_expandSelectionOnSign()`.\n             *\n             * @returns {*} Sign position of a formatted value\n             * @private\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             *\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * Try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // try to strip pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys.\n             * If this function returns TRUE, then further processing is not performed.\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((this.ctrlKey || this.cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || this.shiftKey && this.kdCode === keyCode.Insert) {\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.kdCode >= keyCode.F1 && this.kdCode <= keyCode.F12 || this.kdCode >= keyCode.Windows && this.kdCode <= keyCode.RightClick || this.kdCode >= keyCode.Tab && this.kdCode < keyCode.Space || this.kdCode < keyCode.Backspace && (this.which === 0 || this.which === this.kdCode) || this.kdCode === keyCode.NumLock || this.kdCode === keyCode.ScrollLock || this.kdCode === keyCode.Insert || this.kdCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((this.ctrlKey || this.cmdKey) && this.kdCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((this.ctrlKey || this.cmdKey) && (this.kdCode === keyCode.c || this.kdCode === keyCode.v || this.kdCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // try to prevent wrong paste\n                    if (this.kdCode === keyCode.v || this.kdCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.kdCode === keyCode.c;\n                }\n\n                if (this.ctrlKey || this.cmdKey) {\n                    return true;\n                }\n\n                // jump over thousand separator\n                if (this.kdCode === keyCode.LeftArrow || this.kdCode === keyCode.RightArrow) {\n                    var digitGroupSeparator = this.settingsClone.digitGroupSeparator;\n                    var decimalCharacter = this.settingsClone.decimalCharacter;\n                    var startJump = this.selection.start;\n                    var value = this.that.value;\n                    if (e.type === 'keydown' && !this.shiftKey) {\n                        if (this.kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === digitGroupSeparator || value.charAt(startJump - 2) === decimalCharacter)) {\n                            this._setCaretPosition(startJump - 1);\n                        } else if (this.kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === digitGroupSeparator || value.charAt(startJump + 1) === decimalCharacter)) {\n                            this._setCaretPosition(startJump + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.kdCode >= keyCode.PageDown && this.kdCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\n             *\n             * @param {string} left The part on the left of the caret or selection\n             * @param {string} right The part on the right of the caret or selection\n             * @returns {[string, string]}\n             * @private\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.kdCode === 8) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.kdCode === 8) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && contains(this.value, '-')) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]);\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.kdCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if the keycode is allowed.\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n             *\n             * @returns {boolean}\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion() {\n                var settingsClone = this.settingsClone;\n                var cCode = String.fromCharCode(this.which);\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                settingsClone.throwInput = true;\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (cCode === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && cCode === settingsClone.decimalCharacterAlternative || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((cCode === '-' || cCode === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === '-' || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = cCode === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If try to insert digit before minus\n                if (cCode >= '0' && cCode <= '9') {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && cCode !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + cCode, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n                var eventKeyCode = e.keyCode;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (contains(subParts, '-')) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((eventKeyCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || eventKeyCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (eventKeyCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            position = this.settingsClone.currencySymbol.length + (value.charAt(0) === '-' ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && eventKeyCode === keyCode.num0) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param {HTMLElement} that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.onOff = true;\n            //TODO Fix issue #303 : if (e.type === 'focusin' && no mouse click && fromTabKey) { setElementSelection(e.target, 0); }\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(toggleNegativeBracket(e.target.value, settings));\n            }\n\n            var result = void 0;\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if ((result = stripAllNonNumberCharacters(e.target.value, settings, true)) !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        var currentKeyCode = key(e); // The key being used\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (e.keyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (currentKeyCode === keyCode.Backspace || currentKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeypress(holder, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        // Firefox fix for Shift && insert paste event\n        if (e.shiftKey && currentKeyCode === keyCode.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion();\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                // If the value has not changed, we do not allow the input event to be sent\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     */\n    function onKeyup(holder, settings, e) {\n        var currentKeyCode = key(e); // The key being used\n\n        holder._updateFieldProperties(e); //FIXME This is called 2 to 3 times\n        holder.processed = false;\n        holder.formatted = false;\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (currentKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.onOff = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = value;\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegative(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n        var rawPastedTextSize = rawPastedText.length; // This use the 'cleaned' paste text\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var pastedText = preparePastedText(rawPastedText, holder);\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (!isNumber(pastedText) || pastedText === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = $this.autoNumeric('get');\n        var isInitialValueNegative = isNegative(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n             * Otherwise paste all the numbers in the clipboard.\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n             *\n             * 4b. Replace paste behavior:\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // Test if there is a selection in the input\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, and this is the caret position : Insert the paste into the element.value at that caret position\n                    var indexWhereToInsertThePastedText = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        indexWhereToInsertThePastedText++;\n                    }\n\n                    result = insertCharAtPosition(initialUnformattedNumber, pastedText, indexWhereToInsertThePastedText);\n\n                    caretPositionOnInitialTextAfterPasting = indexWhereToInsertThePastedText + rawPastedTextSize - countDotsInText(rawPastedText); // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    // There is a selection : replace the selection with the paste content\n                    var firstPart = e.target.value.slice(0, selectionStart);\n                    var lastPart = e.target.value.slice(selectionEnd, e.target.value.length);\n                    result = firstPart + pastedText + lastPart;\n\n                    // Finally, remove any unwanted non-number characters\n                    if (firstPart !== '' || lastPart !== '') {\n                        // If the whole input has been selected prior to pasting, then firstPart and lastPart are empty, hence we only use the pastedText variable, otherwise we remove the potential decimal character in the result variable\n                        result = preparePastedText(result, holder);\n                    }\n\n                    // Add back the negative sign if needed\n                    if (isInitialValueNegative) {\n                        result = setRawNegativeSign(result);\n                    }\n\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        if (isPasteNegativeAndInitialValueIsPositive) {\n                            // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                            indexSelectionEndInRawValue++;\n                        }\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + rawPastedTextSize - countDotsInText(rawPastedText);\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\n         * If 'error' (this is the default) :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, then throw an error in the console.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'ignore' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, do nothing more.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'clamp' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n         *        paste result.\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n         * If 'truncate' :\n         *      - Truncate paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         * If 'replace' :\n         *      - Replace paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n          *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Routine to format the default value on page load\n     *\n     * @param {object} settings\n     * @param {object} $input jQuery-selected <input> element\n     * @param {object} $this jQuery-selected DOM element\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                var testedCurrentValue = parseFloat(currentValue.replace(',', '.'));\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                    $this.autoNumeric('set', testedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.onOff = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        settings.rawValue = (settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && settings.negativeSignCharacter !== '' && contains(currentValue, '-') ? '-' + stripAllNonNumberCharacters(toStrip, settings, true) : stripAllNonNumberCharacters(toStrip, settings, true);\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} options\n     * @param {object} settings\n     */\n    function correctPNegOption(options, settings) {\n        //TODO Merge the options and settings parameter to use only `settings`\n        if (!isUndefined(options) && isUndefinedOrNullOrEmpty(options.negativePositiveSignPlacement) && options.currencySymbol !== '') {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p';\n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'r';\n                    break;\n                default:\n                //\n            }\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctMDecOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n        } else if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for stripAllNonNumberCharacters\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.negativeSignCharacter ? '\\\\' + settings.negativeSignCharacter : '') + '\\\\' + settings.decimalCharacter + '\\\\d].*?(\\\\d|\\\\' + settings.decimalCharacter + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + '\\\\d]\\\\D*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(\\\\d+\\\\' + settings.decimalCharacter + '\\\\d+)|(\\\\d*(?:\\\\' + settings.decimalCharacter + '\\\\d*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(\\\\d)');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            onOff: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param {object} $this jQuery-selected DOM element\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // Attempt to grab HTML5 data, if it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    onOff: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctPNegOption(options, settings);\n\n            // Set the negative sign if needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctMDecOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n         *\n         * @param {object} options\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('focusout', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * Method to stop and remove autoNumeric for the current element.\n         * Note: this does not remove the formatting.\n         *\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n         *\n         * @returns {*|jQuery}\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n         *\n         * @returns {*|jQuery}\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\n         *\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n         *\n         * @param {object} options\n         * @returns {*|jQuery}\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @example $(someSelector).autoNumeric('set', 'value'); // Formats the value being passed as the second parameter\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = newValue.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method');\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                settings.decimalPlacesOverride = settings.scaleDecimalPlaces ? settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                            }\n\n                            value = roundValue(value, settings);\n                            if (settings.decimalPlacesShownOnFocus === null && settings.scaleDivisor === null) {\n                                settings.rawValue = value;\n                            }\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * Method to un-format inputs.\n         * This is handy to use right before form submission.\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Please see option \"outputFormat\" for more details\n         *\n         * @example $(someSelector).autoNumeric('unSet');\n         *\n         * @returns {*|jQuery}\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * Method to re-format inputs.\n         * This is handy to use right after form submission.\n         *\n         * This is called after the 'unSet' method to reformat the input\n         *\n         * @example $(someSelector).autoNumeric('reSet');\n         *\n         * @returns {*|jQuery}\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.onOff = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                }\n\n                value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n            }\n\n            // Always return a numeric string\n            return value;\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {string}\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {{}|[]}\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n         *\n         * @example\n         * $(someSelector).autoNumeric('getSettings');\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     *\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\n     * @param {*} args\n     * @returns {*}\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @returns {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger.\n     *\n     * @param {number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Check the validity of the `value` parameter\n        if (!isNumber(value)) {\n            throwError('A number is needed to be able to format it, [' + value + '] given.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n        var valueString = value.toString();\n        valueString = fromLocale(valueString);\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element.\n     *\n     * @param {string|number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        if (value.charAt(0) === '-') {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.onOff = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', '.', ' ', ''])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\' \\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            // isNaN(parseInt(options.digitalGroupSpacing)) //DEBUG\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', '.'])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\' or \\',\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r'])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left) or \\'r\\' (right), [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (contains(options.suffixText, '-') || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.validate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9DOi9Vc2Vycy9ib2Jrbi9Eb2N1bWVudHMvR2l0SHViL2F1dG9OdW1lcmljL3NyYy9hdXRvTnVtZXJpYy5qcz81OTRhIl0sIm5hbWVzIjpbImF1dG9Gb3JtYXQiLCJhdXRvVW5Gb3JtYXQiLCJnZXREZWZhdWx0Q29uZmlnIiwidmFsaWRhdGUiLCJhcmVTZXR0aW5nc1ZhbGlkIiwiYWxsb3dlZFRhZ0xpc3QiLCJkZWZhdWx0U2V0dGluZ3MiLCJkaWdpdEdyb3VwU2VwYXJhdG9yIiwibm9TZXBhcmF0b3JPbkZvY3VzIiwiZGlnaXRhbEdyb3VwU3BhY2luZyIsImRlY2ltYWxDaGFyYWN0ZXIiLCJkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUiLCJjdXJyZW5jeVN5bWJvbCIsImN1cnJlbmN5U3ltYm9sUGxhY2VtZW50IiwibmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQiLCJzdWZmaXhUZXh0Iiwib3ZlcnJpZGVNaW5NYXhMaW1pdHMiLCJtYXhpbXVtVmFsdWUiLCJtaW5pbXVtVmFsdWUiLCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIiwic2NhbGVEaXZpc29yIiwic2NhbGVEZWNpbWFsUGxhY2VzIiwic2NhbGVTeW1ib2wiLCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlIiwib25JbnZhbGlkUGFzdGUiLCJyb3VuZGluZ01ldGhvZCIsImFsbG93RGVjaW1hbFBhZGRpbmciLCJuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciIsImVtcHR5SW5wdXRCZWhhdmlvciIsImxlYWRpbmdaZXJvIiwiZm9ybWF0T25QYWdlTG9hZCIsInNlbGVjdE51bWJlck9ubHkiLCJkZWZhdWx0VmFsdWVPdmVycmlkZSIsInVuZm9ybWF0T25TdWJtaXQiLCJvdXRwdXRGb3JtYXQiLCJzaG93V2FybmluZ3MiLCJmYWlsT25Vbmtub3duT3B0aW9uIiwia2V5Q29kZSIsIkJhY2tzcGFjZSIsIlRhYiIsIkVudGVyIiwiU2hpZnQiLCJDdHJsIiwiQWx0IiwiUGF1c2VCcmVhayIsIkNhcHNMb2NrIiwiRXNjIiwiU3BhY2UiLCJQYWdlVXAiLCJQYWdlRG93biIsIkVuZCIsIkhvbWUiLCJMZWZ0QXJyb3ciLCJVcEFycm93IiwiUmlnaHRBcnJvdyIsIkRvd25BcnJvdyIsIkluc2VydCIsIkRlbGV0ZSIsIm51bTAiLCJudW0xIiwibnVtMiIsIm51bTMiLCJudW00IiwibnVtNSIsIm51bTYiLCJudW03IiwibnVtOCIsIm51bTkiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImkiLCJqIiwiayIsImwiLCJtIiwibiIsIm8iLCJwIiwicSIsInIiLCJzIiwidCIsInUiLCJ2IiwidyIsIngiLCJ5IiwieiIsIldpbmRvd3MiLCJSaWdodENsaWNrIiwibnVtcGFkMCIsIm51bXBhZDEiLCJudW1wYWQyIiwibnVtcGFkMyIsIm51bXBhZDQiLCJudW1wYWQ1IiwibnVtcGFkNiIsIm51bXBhZDciLCJudW1wYWQ4IiwibnVtcGFkOSIsIk11bHRpcGx5TnVtcGFkIiwiUGx1c051bXBhZCIsIk1pbnVzTnVtcGFkIiwiRG90TnVtcGFkIiwiU2xhc2hOdW1wYWQiLCJGMSIsIkYyIiwiRjMiLCJGNCIsIkY1IiwiRjYiLCJGNyIsIkY4IiwiRjkiLCJGMTAiLCJGMTEiLCJGMTIiLCJOdW1Mb2NrIiwiU2Nyb2xsTG9jayIsIk15Q29tcHV0ZXIiLCJNeUNhbGN1bGF0b3IiLCJTZW1pY29sb24iLCJFcXVhbCIsIkNvbW1hIiwiSHlwaGVuIiwiRG90IiwiU2xhc2giLCJCYWNrcXVvdGUiLCJMZWZ0QnJhY2tldCIsIkJhY2tzbGFzaCIsIlJpZ2h0QnJhY2tldCIsIlF1b3RlIiwiQ29tbWFuZCIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJwcmVwYXJlUGFzdGVkVGV4dCIsInRleHQiLCJob2xkZXIiLCJzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJkZWNpbWFsUGxhY2VzIiwic3BsaXQiLCJkZWNpbWFsUGFydCIsImxlbmd0aCIsImtleSIsImV2ZW50Iiwid2hpY2giLCJjaGVja0lmSW5SYW5nZSIsInBhcnNlZE1pblZhbHVlIiwicGFyc2VkTWF4VmFsdWUiLCJwYXJzZWRWYWx1ZSIsInBhcnNlU3RyIiwidGVzdE1pbk1heCIsImlzTmVnYXRpdmUiLCJzdHJpbmciLCJjaGFyQXQiLCJzZXRSYXdOZWdhdGl2ZVNpZ24iLCJpbnNlcnRDaGFyQXRQb3NpdGlvbiIsImNoYXIiLCJjYXJldFBvc2l0aW9uIiwic2xpY2UiLCJyZXBsYWNlQ2hhckF0IiwiaW5kZXgiLCJuZXdDaGFyYWN0ZXIiLCJzdWJzdHIiLCJjbGFtcFRvUmFuZ2VMaW1pdHMiLCJzZXR0aW5ncyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmciLCJudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiIsIlJlZ0V4cCIsIm51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50IiwidGVzdCIsImZpbmRDYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJyYXdOdW1iZXJTdHJpbmciLCJjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUiLCJyYXdOdW1iZXJTdHJpbmdTaXplIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXgiLCJyYXdOdW1iZXJTdHJpbmdJbmRleCIsImNvdW50RG90c0luVGV4dCIsImNvdW50Q2hhckluVGV4dCIsImNoYXJhY3RlciIsImNoYXJDb3VudGVyIiwiY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uIiwiY2hhcmFjdGVyQ291bnQiLCJnZXRFbGVtZW50U2VsZWN0aW9uIiwidGhhdCIsInBvc2l0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJmb2N1cyIsInNlbGVjdCIsImRvY3VtZW50Iiwic2VsZWN0aW9uIiwiY3JlYXRlUmFuZ2UiLCJtb3ZlU3RhcnQiLCJlbmQiLCJzdGFydCIsInNlbGVjdGlvbkVuZCIsInNldEVsZW1lbnRTZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwibW92ZUVuZCIsInRocm93RXJyb3IiLCJtZXNzYWdlIiwid2FybmluZyIsInNob3dXYXJuaW5nIiwiY29uc29sZSIsIndhcm4iLCJydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QiLCIkdGhpcyIsIiQiLCJlYWNoIiwidmFsIiwiYXV0b051bWVyaWMiLCJtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoIiwibGVmdE9yQWxsIiwic2tpcEZpcnN0QXV0b1N0cmlwIiwidHJhaWxpbmdOZWdhdGl2ZSIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZEF1dG9TdHJpcCIsIm1hdGNoIiwibnVtUmVnQXV0b1N0cmlwIiwiam9pbiIsIm5TaWduIiwiaW50ZWdlclBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwibmVnYXRpdmVTaWduQ2hhcmFjdGVyIiwibUludFBvcyIsIm1JbnROZWciLCJvbk9mZiIsInN0cmlwUmVnIiwidG9nZ2xlTmVnYXRpdmVCcmFja2V0IiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJmcm9tTG9jYWxlIiwibGFzdEluZGV4T2YiLCJ0b0xvY2FsZSIsImxvY2FsZSIsInJlc3VsdCIsIk51bWJlciIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSIsImNoZWNrRW1wdHkiLCJpbnB1dFZhbHVlIiwic2lnbk9uRW1wdHkiLCJhZGRHcm91cFNlcGFyYXRvcnMiLCJzdHJpcCIsImVtcHR5IiwiZGlnaXRhbEdyb3VwIiwic3Vic3RyaW5nIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwicm91bmRlZElucHV0VmFsdWUiLCJ0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJyZWdleCIsInJvdW5kVmFsdWUiLCJyb3VuZCIsImNlaWwiLCJmbG9vciIsIml2Um91bmRlZCIsImRQb3MiLCJpbnB1dFZhbHVlSGFzQURvdCIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJpc1Bhc3RlIiwibW9kaWZpZWREZWNpbWFsUGFydCIsIm5MIiwic2VhcmNoIiwieGMiLCJ5YyIsInhOZWciLCJjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbiIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsImdldEN1cnJlbnRFbGVtZW50IiwiZWxlbWVudCIsImdldEF1dG9OdW1lcmljSG9sZGVyIiwidXBkYXRlIiwiZGF0YSIsIkF1dG9OdW1lcmljSG9sZGVyIiwiZ2V0Iiwia2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkiLCJvRGVjIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwib1N1ZmZpeCIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlIiwiYWN0aW9uIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCIkdGhhdCIsImZvcm1hdHRlZCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwic2V0UmVhbCIsInBvcyIsIl9zZXRTZWxlY3Rpb24iLCJsZWZ0IiwicmlnaHQiLCJfZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInN0cmlwWmVyb3MiLCJuZXdWYWx1ZSIsImFOZWdSZWdBdXRvU3RyaXAiLCJwYXJ0cyIsIl9ub3JtYWxpemVQYXJ0cyIsIm1pblRlc3QiLCJtYXhUZXN0IiwidGVzdFZhbHVlIiwiX3NldENhcmV0UG9zaXRpb24iLCJ0cmlnZ2VyIiwiY3VycmVuY3lTeW1ib2xMZW4iLCJoYXNOZWciLCJ2YWx1ZUxlbiIsInNpZ25Qb3NpdGlvbiIsIl9nZXRTaWduUG9zaXRpb24iLCJ2YWx1ZVBhcnRzQmVmb3JlUGFzdGUiLCJvbGRQYXJ0cyIsIm1vZGlmaWVkTGVmdFBhcnQiLCJfc2V0VmFsdWVQYXJ0cyIsIl9jaGVja1Bhc3RlIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJzdWZmaXhUZXh0TGVuIiwiX2V4cGFuZFNlbGVjdGlvbk9uU2lnbiIsInN0YXJ0SnVtcCIsImNhcmV0Rml4IiwiX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInRocm93SW5wdXQiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbiIsImNDb2RlIiwiZnJvbUNoYXJDb2RlIiwibGVmdExlbmd0aCIsImV2ZW50S2V5Q29kZSIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJfZ2V0U3RyaW5nT3JBcnJheSIsImdldEFycmF5QmVoYXZpb3IiLCJmb3JtSW5kZXgiLCJhbGxGb3JtRWxlbWVudHMiLCJhaUluZGV4Iiwic2NJbmRleCIsInJTdWJtaXR0ZXJUeXBlcyIsInJTdWJtaXR0YWJsZSIsInJDaGVja2FibGVUeXBlIiwick5vbkF1dG9OdW1lcmljVHlwZXMiLCJjb3VudCIsImZpZWxkIiwibG9jYWxOYW1lIiwiZGlzYWJsZWQiLCJjaGVja2VkIiwiZm9ybUZpZWxkcyIsInNlcmlhbGl6ZUFycmF5Iiwic2NFbGVtZW50IiwiaW5BcnJheSIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJpcyIsInRhcmdldCIsInZhbHVlT25Gb2N1cyIsImxhc3RWYWwiLCJvbkVtcHR5Iiwib25LZXlkb3duIiwiY3VycmVudEtleUNvZGUiLCJyZWFkT25seSIsInByb2Nlc3NlZCIsInRyaWdnZXJFdmVudCIsIl91cGRhdGVGaWVsZFByb3BlcnRpZXMiLCJfc2tpcEFsd2F5cyIsIl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24iLCJfZm9ybWF0VmFsdWUiLCJvbktleXByZXNzIiwiaXNDaGFyYWN0ZXJJbnNlcnRpb25BbGxvd2VkIiwiX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24iLCJvbktleXVwIiwic2tpcCIsIm9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlIiwib3JpZ1ZhbHVlIiwiZ3JvdXBlZFZhbHVlIiwiY2hhbmdlIiwib25QYXN0ZSIsInJhd1Bhc3RlZFRleHQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RGF0YSIsImluaXRpYWxGb3JtYXR0ZWRWYWx1ZSIsInNlbGVjdGlvblNpemUiLCJpc0FsbElucHV0VGV4dFNlbGVjdGVkIiwiaXNQYXN0ZU5lZ2F0aXZlIiwicmF3UGFzdGVkVGV4dFNpemUiLCJwYXN0ZWRUZXh0IiwiY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmciLCJpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIiLCJpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlIiwiaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSIsImxlZnRGb3JtYXR0ZWRQYXJ0IiwicmlnaHRGb3JtYXR0ZWRQYXJ0IiwibGVmdFBhcnQiLCJyaWdodFBhcnQiLCJsYXN0R29vZEtub3duUmVzdWx0IiwicGFzdGVkVGV4dEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdFNpemUiLCJpbmRleFdoZXJlVG9JbnNlcnRUaGVQYXN0ZWRUZXh0IiwiZmlyc3RQYXJ0IiwibGFzdFBhcnQiLCJpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUiLCJzZWxlY3RlZFRleHQiLCJ2YWx1ZUhhc0JlZW5TZXQiLCJ2YWx1ZUhhc0JlZW5DbGFtcGVkIiwiZXJyb3IiLCJjbGFtcGVkVmFsdWUiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJvbkJsdXIiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJvbiIsIiRzZXR0aW5ncyIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJhdHRyIiwidGVzdGVkQ3VycmVudFZhbHVlIiwiSW5maW5pdHkiLCJpc051bWVyaWMiLCJ0b1N0cmlwIiwidGFnTGlzdCIsImNvcnJlY3RQTmVnT3B0aW9uIiwib3B0aW9ucyIsImNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzIiwibWF4aW11bVZhbHVlSW50ZWdlclBhcnQiLCJtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCIsImNvcnJlY3RNRGVjT3B0aW9uIiwic2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlciIsImNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zIiwiYU5lZ1JlZyIsImFsbG93ZWQiLCJ0cmFuc2Zvcm1PcHRpb25zVmFsdWVzVG9EZWZhdWx0VHlwZXMiLCJjb252ZXJ0T2xkT3B0aW9uc1RvTmV3T25lcyIsIm9sZE9wdGlvbnNDb252ZXJ0ZXIiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGVjaW1hbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwicnVuT25jZSIsIm9wdGlvbiIsImdldEluaXRpYWxTZXR0aW5ncyIsImV4dGVuZCIsInRhZ0RhdGEiLCJtZXRob2RzIiwiaW5pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJmbiIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwidmFsdWVTdHJpbmciLCJhdXRvU3RyaXAiLCJhdXRvVW5mb3JtYXQiLCJ1c2VyT3B0aW9ucyIsInNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIiwidGVzdFBvc2l0aXZlSW50ZWdlciIsInRlc3ROdW1lcmljYWxDaGFyYWN0ZXJzIiwidGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24iLCJ0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciIsInZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMiLCJpc1ZhbGlkIiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInBhcmFtcyIsImV2dCIsIkV2ZW50IiwiZm9ybWF0IiwidW5Gb3JtYXQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStDQTs7QUFFQTtBQUNBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjtBQUNBLElBQUlDLGlCQUFKO0FBQ0EsSUFBSUMseUJBQUo7O0FBRUE7QUFDQTs7O0FBR0EsSUFBTUMsaUJBQWlCLENBQ25CLEdBRG1CLEVBRW5CLFNBRm1CLEVBR25CLE1BSG1CLEVBSW5CLE1BSm1CLEVBS25CLE9BTG1CLEVBTW5CLElBTm1CLEVBT25CLEtBUG1CLEVBUW5CLEtBUm1CLEVBU25CLEtBVG1CLEVBVW5CLElBVm1CLEVBV25CLElBWG1CLEVBWW5CLElBWm1CLEVBYW5CLElBYm1CLEVBY25CLElBZG1CLEVBZW5CLElBZm1CLEVBZ0JuQixJQWhCbUIsRUFpQm5CLElBakJtQixFQWtCbkIsS0FsQm1CLEVBbUJuQixLQW5CbUIsRUFvQm5CLE9BcEJtQixFQXFCbkIsSUFyQm1CLEVBc0JuQixRQXRCbUIsRUF1Qm5CLFFBdkJtQixFQXdCbkIsR0F4Qm1CLEVBeUJuQixHQXpCbUIsRUEwQm5CLEdBMUJtQixFQTJCbkIsUUEzQm1CLEVBNEJu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UzRXLFdBQVQsQ0FBcUIsYUFBckIsQ0FBUjtBQUNBOVosa0JBQU0rWixlQUFOLENBQXNCTixTQUF0QixFQUFpQyxJQUFqQyxFQUF1QyxJQUF2QyxFQUE2QyxFQUFFQyxjQUFGLEVBQTdDO0FBQ0g7O0FBRUQ1USxnQkFBUWtSLGFBQVIsQ0FBc0JoYSxLQUF0QjtBQUNIOztBQUVEOzs7QUFHQSxLQUFDLFlBQVc7QUFDUixZQUFJLE9BQU9qRCxPQUFPNGMsV0FBZCxLQUE4QixVQUFsQyxFQUE4QztBQUMxQyxtQkFBTyxLQUFQO0FBQ0g7O0FBRUQsaUJBQVNBLFdBQVQsQ0FBcUIzWixLQUFyQixFQUE0QmlhLE1BQTVCLEVBQW9DO0FBQ2hDQSxxQkFBU0EsVUFBVSxFQUFFTCxTQUFTLEtBQVgsRUFBa0JDLFlBQVksS0FBOUIsRUFBcUNILFFBQVEsS0FBSyxDQUFsRCxFQUFuQjtBQUNBLGdCQUFNUSxNQUFNaFgsU0FBUzRXLFdBQVQsQ0FBcUIsYUFBckIsQ0FBWjtBQUNBSSxnQkFBSUgsZUFBSixDQUFvQi9aLEtBQXBCLEVBQTJCaWEsT0FBT0wsT0FBbEMsRUFBMkNLLE9BQU9KLFVBQWxELEVBQThESSxPQUFPUCxNQUFyRTtBQUNBLG1CQUFPUSxHQUFQO0FBQ0g7O0FBRURQLG9CQUFZcGEsU0FBWixHQUF3QnhDLE9BQU9vZCxLQUFQLENBQWE1YSxTQUFyQztBQUNBeEMsZUFBTzRjLFdBQVAsR0FBcUJBLFdBQXJCO0FBQ0gsS0FkRDtBQWVILENBaGdJQSxDQUFEOztBQWtnSUE7OztrQkFHZTtBQUNYUyxZQUFVdG1CLFVBREM7QUFFWHVtQixjQUFVdG1CLFlBRkM7QUFHWEMsc0NBSFc7QUFJWEMsc0JBSlcsRUFJRDtBQUNWQyxzQ0FMVyxFIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqICAgICAgICAgICAgICAgYXV0b051bWVyaWMuanNcbiAqXG4gKiBAdmVyc2lvbiAgICAgIDIuMC1iZXRhLjE0XG4gKiBAZGF0ZSAgICAgICAgIDIwMTYtMTItMjMgVVRDIDE0OjAwXG4gKlxuICogQGF1dGhvciAgICAgICBCb2IgS25vdGhlXG4gKiBAY29udHJpYnV0b3JzIEFsZXhhbmRyZSBCb25uZWF1LCBTb2tvbG92IFl1cmEgYW5kIG90aGVyIEdpdGh1YiB1c2VycywgY2YuIEFVVEhPUlMubWQuXG4gKiBAY29weXJpZ2h0ICAgIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4gKiBAc2luY2UgICAgICAgIDIwMDktMDgtMDlcbiAqXG4gKiBAc3VtbWFyeSAgICAgIGF1dG9OdW1lcmljIGlzIGEgalF1ZXJ5IHBsdWdpbiB0aGF0IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyBjdXJyZW5jeVxuICogKG1vbmV5KSBhbmQgbnVtYmVycyBhcy15b3UtdHlwZSBpbiBhIGZvcm0gaW5wdXRzLiBJdCBzdXBwb3J0cyBtb3N0XG4gKiBpbnRlcm5hdGlvbmFsIG51bWVyaWMgZm9ybWF0cyBhbmQgY3VycmVuY3kgc2lnbnMgaW5jbHVkaW5nIHRob3NlIHVzZWQgaW5cbiAqIEV1cm9wZSwgTm9ydGggYW5kIFNvdXRoIEFtZXJpY2EsIEFzaWEsIGFzIHdlbGwgYXMgSW5kaWEncycgbGFraHMuXG4gKlxuICogICAgICAgICAgICAgICBOb3RlIDogU29tZSBmdW5jdGlvbnMgYXJlIGJvcnJvd2VkIGZyb20gYmlnLmpzXG4gKiBAbGluayAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAqXG4gKiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbiAqXG4gKiBAbGljZW5zZSAgICAgIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogQGxpbmsgICAgICAgICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xubGV0IHZhbGlkYXRlO1xubGV0IGFyZVNldHRpbmdzVmFsaWQ7XG5cbi8vIEF1dG9OdW1lcmljIGRlZmF1bHQgc2V0dGluZ3Ncbi8qKlxuICogTGlzdCBvZiBhbGxvd2VkIHRhZyBvbiB3aGljaCBhdXRvTnVtZXJpYyBjYW4gYmUgdXNlZC5cbiAqL1xuY29uc3QgYWxsb3dlZFRhZ0xpc3QgPSBbXG4gICAgJ2InLFxuICAgICdjYXB0aW9uJyxcbiAgICAnY2l0ZScsXG4gICAgJ2NvZGUnLFxuICAgICdjb25zdCcsXG4gICAgJ2RkJyxcbiAgICAnZGVsJyxcbiAgICAnZGl2JyxcbiAgICAnZGZuJyxcbiAgICAnZHQnLFxuICAgICdlbScsXG4gICAgJ2gxJyxcbiAgICAnaDInLFxuICAgICdoMycsXG4gICAgJ2g0JyxcbiAgICAnaDUnLFxuICAgICdoNicsXG4gICAgJ2lucycsXG4gICAgJ2tkYicsXG4gICAgJ2xhYmVsJyxcbiAgICAnbGknLFxuICAgICdvcHRpb24nLFxuICAgICdvdXRwdXQnLFxuICAgICdwJyxcbiAgICAncScsXG4gICAgJ3MnLFxuICAgICdzYW1wbGUnLFxuICAgICdzcGFuJyxcbiAgICAnc3Ryb25nJyxcbiAgICAndGQnLFxuICAgICd0aCcsXG4gICAgJ3UnLFxuXTtcblxuLyoqXG4gKiBEZWZhdWx0cyBvcHRpb25zIGFyZSBwdWJsaWMgLSB0aGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgZm9sbG93aW5nOlxuICogLSBIVE1MNSBkYXRhIGF0dHJpYnV0ZXNcbiAqIC0gT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAqL1xuY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogcGVyaW9kIFwiZnVsbCBzdG9wXCIgPSBcIi5cIlxuICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXG4gICAgICogc3BhY2UgPSBcIiBcIlxuICAgICAqIG5vbmUgPSBcIlwiXG4gICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNlcFxuICAgICAqL1xuICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3I6ICcsJyxcblxuICAgIC8qIFdoZW4gdHJ1ZSA9PiByZW1vdmVzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IsIGN1cnJlbmN5IHN5bWJvbCAmIHN1ZmZpeCBcImZvY3VzaW5cIlxuICAgICAqIGV4YW1wbGUgaWYgdGhlIGlucHV0IHZhbHVlIFwiJCAxLDk5OS44OCBzdWZmaXhcIlxuICAgICAqIG9uIFwiZm9jdXNpblwiIGl0IGJlY29tZXMgXCIxOTk5Ljg4XCIgYW5kIGJhY2sgdG8gXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiIG9uIGZvY3VzIG91dC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogblNlcFxuICAgICAqL1xuICAgIG5vU2VwYXJhdG9yT25Gb2N1czogZmFsc2UsXG5cbiAgICAvKiBEaWdpdGFsIGdyb3VwaW5nIGZvciB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHVzZWQgaW4gRm9ybWF0XG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIyXCIsIHJlc3VsdHMgaW4gOTksOTksOTksOTk5IEluZGlhJ3MgbGFraHNcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJzXCIsIHJlc3VsdHMgaW4gOTksOTk5LDk5LDk5LDk5OSBJbmRpYSdzIGxha2hzIHNjYWxlZFxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiM1wiLCByZXN1bHRzIGluIDk5OSw5OTksOTk5IGRlZmF1bHRcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjRcIiwgcmVzdWx0cyBpbiA5OTk5LDk5OTksOTk5OSB1c2VkIGluIHNvbWUgQXNpYW4gY291bnRyaWVzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGRHcm91cFxuICAgICAqL1xuICAgIGRpZ2l0YWxHcm91cFNwYWNpbmc6ICczJyxcblxuICAgIC8qIEFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAqIHBlcmlvZCBcImZ1bGwgc3RvcFwiID0gXCIuXCJcbiAgICAgKiBjb21tYSA9IFwiLFwiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFEZWNcbiAgICAgKi9cbiAgICBkZWNpbWFsQ2hhcmFjdGVyOiAnLicsXG5cbiAgICAvKiBBbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgZGVjaW1hbENoYXJhY3RlclxuICAgICAqIGRldmVsb3BlZCBmb3IgY291bnRyaWVzIHRoZSB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgKiBhbmQgaGF2ZSBrZXlib2FyZHNcXG51bWVyaWMgcGFkcyB0aGF0IGhhdmUgYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoU3BhaW4gaXMgYW4gZXhhbXBsZSlcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYWx0RGVjXG4gICAgICovXG4gICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlOiBudWxsLFxuXG4gICAgLyogY3VycmVuY3lTeW1ib2wgPSBhbGxvd2VkIGN1cnJlbmN5IHN5bWJvbFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIGN1cnJlbmN5U3ltYm9sOiBcIiRcIlxuICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGN1cnJlbmN5U3ltYm9sOiAnJCAnXG4gICAgICogc3BhY2UgdG8gdGhlIGxlZnQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyAkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2lnblxuICAgICAqL1xuICAgIGN1cnJlbmN5U3ltYm9sOiAnJyxcblxuICAgIC8qIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID0gcGxhY2VtZW50IG9mIGN1cnJlbmN5IHNpZ24gYXMgYSBwPXByZWZpeCBvciBzPXN1ZmZpeFxuICAgICAqIGZvciBwcmVmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwicFwiIChkZWZhdWx0KVxuICAgICAqIGZvciBzdWZmaXggY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHBTaWduXG4gICAgICovXG4gICAgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6ICdwJyxcblxuICAgIC8qIFBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW5jeVN5bWJvbCBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICogLTEsMjM0LjU2ICA9PiBkZWZhdWx0IG5vIG9wdGlvbnMgcmVxdWlyZWRcbiAgICAgKiAtJDEsMjM0LjU2ID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XG4gICAgICogLTEsMjM0LjU2JCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInBcIn1cbiAgICAgKiAxLDIzNC41Ni0gID0+IHtuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogJDEsMjM0LjU2LSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYtJCA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCJ9XG4gICAgICogMSwyMzQuNTYkLSA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogXCJzXCIsIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiBcInJcIn1cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogcE5lZ1xuICAgICAqL1xuICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiAnbCcsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIHN1ZmZpeFRleHQ6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBzdWZmaXhUZXh0OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3VmZml4XG4gICAgICovXG4gICAgc3VmZml4VGV4dDogJycsXG5cbiAgICAvKiBPdmVycmlkZSBtaW4gbWF4IGxpbWl0c1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gbWluaW11bVZhbHVlIGFuZCBpZ25vcmVzIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xuICAgICAqL1xuICAgIG92ZXJyaWRlTWluTWF4TGltaXRzOiBudWxsLFxuXG4gICAgLyogTWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWF4XG4gICAgICovXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIHZhbHVlIG11c3QgYmUgc21hbGxlciB0aGFuIG1heGltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWluXG4gICAgICovXG4gICAgbWluaW11bVZhbHVlOiAnLTk5OTk5OTk5OTk5OTkuOTknLCAvLyAtOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcblxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcblxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IG51bGwsXG5cbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlXCIgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxuICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAqL1xuXG4gICAgLyogVGhlIGBzY2FsZURpdmlzb3JgIGRlY2lkZXMgdGhlIG9uIGZvY3VzIHZhbHVlIGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgb24gZm9jdXNvdXRcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAqIFRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlICdoaWRkZW4nIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgOyBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyB0aGUgZm9jdXMuXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNjYWxlRGVjaW1hbFxuICAgICAqL1xuICAgIHNjYWxlRGVjaW1hbFBsYWNlczogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbDogbnVsbCxcblxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3RvclxuICAgICAqL1xuICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2U6IGZhbHNlLFxuXG4gICAgLypcbiAgICAgKiBNYW5hZ2UgaG93IGF1dG9OdW1lcmljIHJlYWN0IHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYW4gaW52YWxpZCBudW1iZXIuXG4gICAgICogLSAnZXJyb3InICAgIDogKFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpIFRoZSBpbnB1dCB2YWx1ZSBpcyBub3QgY2hhbmdlZCBhbmQgYW4gZXJyb3IgaXMgb3V0cHV0IGluIHRoZSBjb25zb2xlLlxuICAgICAqIC0gJ2lnbm9yZScgICA6IGlkZW0gdGhhbiAnZXJyb3InLCBidXQgZmFpbCBzaWxlbnRseSB3aXRob3V0IG91dHB1dHRpbmcgYW55IGVycm9yL3dhcm5pbmcgaW4gdGhlIGNvbnNvbGUuXG4gICAgICogLSAnY2xhbXAnICAgIDogaWYgdGhlIHBhc3RlZCB2YWx1ZSBpcyBlaXRoZXIgdG9vIHNtYWxsIG9yIHRvbyBiaWcgcmVnYXJkaW5nIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSByYW5nZSwgdGhlbiB0aGUgcmVzdWx0IGlzIGNsYW1wZWQgdG8gdGhvc2UgbGltaXRzLlxuICAgICAqIC0gJ3RydW5jYXRlJyA6IGF1dG9OdW1lcmljIHdpbGwgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdW50aWwgZXZlcnl0aGluZyBpcyBwYXN0ZWQsIG9yIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQuXG4gICAgICogICAgICAgICAgICAgICAgVGhlIG5vbi1wYXN0ZWQgbnVtYmVycyBhcmUgZHJvcHBlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkIGF0IGFsbC5cbiAgICAgKiAtICdyZXBsYWNlJyAgOiBhdXRvTnVtZXJpYyB3aWxsIGZpcnN0IGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHRoZW4gaWYgdGhlIHJhbmdlIGxpbWl0IGlzIGhpdCwgaXQgd2lsbCB0cnlcbiAgICAgKiAgICAgICAgICAgICAgICB0byByZXBsYWNlIG9uZSBieSBvbmUgdGhlIHJlbWFpbmluZyBpbml0aWFsIG51bWJlcnMgKG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldCkgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFzdGVkIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlIDEgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG5lZ2F0aXZlIHNpZ24gJy0nIHdpbGwgYmUgYWNjZXB0ZWQgYW55d2hlcmUgaW4gdGhlIGlucHV0LCBhbmQgd2lsbCBzZXQgdGhlIHJlc3VsdGluZyB2YWx1ZSBhcyBhIG5lZ2F0aXZlIG51bWJlclxuICAgICAqIE5vdGUgMiA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbnVtYmVyIHdpbGwgYmUgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlIHJlc3QgaXMgZ2liYmVyaXNoIChpZS4gJzEyM2Zvb2JhcjQ1NicpLlxuICAgICAqICAgICAgICAgIE9ubHkgdGhlIGZpcnN0IG51bWJlciB3aWxsIGJlIHVzZWQgKGhlcmUgJzEyMycpLlxuICAgICAqIE5vdGUgMyA6IFRoZSBwYXN0ZSBldmVudCB3b3JrcyB3aXRoIHRoZSBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2Agb3B0aW9uIHRvby5cbiAgICAgKi9cbiAgICAvL1RPRE8gU2hvdWxkbid0IHdlIHVzZSBgdHJ1bmNhdGVgIGFzIHRoZSBkZWZhdWx0IHZhbHVlP1xuICAgIG9uSW52YWxpZFBhc3RlOiAnZXJyb3InLFxuXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtUm91bmRcbiAgICAgKi9cbiAgICByb3VuZGluZ01ldGhvZDogJ1MnLFxuXG4gICAgLyogQ29udHJvbHMgZGVjaW1hbCBwYWRkaW5nXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICogTm90ZTogc2V0dGluZyBhbGxvd0RlY2ltYWxQYWRkaW5nIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFQYWRcbiAgICAgKi9cbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICogbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI6ICcoLCknLCBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ1ssXScsIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiAnPCw+JyBvciBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogJ3ssfSdcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbkJyYWNrZXRcbiAgICAgKi9cbiAgICBuZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cjogbnVsbCxcblxuICAgIC8qIERpc3BsYXllZCBvbiBlbXB0eSBzdHJpbmcgXCJcIlxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJmb2N1c1wiIC0gKGRlZmF1bHQpIGN1cnJlbmN5IHNpZ24gZGlzcGxheWVkIGFuZCB0aGUgaW5wdXQgcmVjZWl2ZXMgZm9jdXNcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImFsd2F5c1wiIC0gYWx3YXlzIGRpc3BsYXlzIHRoZSBjdXJyZW5jeSBzaWduIG9ubHlcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiemVyb1wiIC0gaWYgdGhlIGlucHV0IGhhcyBubyB2YWx1ZSBvbiBmb2N1cyBvdXQgZGlzcGxheXMgYSB6ZXJvIFwicm91bmRlZFwiIHdpdGggb3Igd2l0aG91dCBhIGN1cnJlbmN5IHNpZ25cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogd0VtcHR5XG4gICAgICovXG4gICAgZW1wdHlJbnB1dEJlaGF2aW9yOiAnZm9jdXMnLFxuXG4gICAgLyogQ29udHJvbHMgbGVhZGluZyB6ZXJvIGJlaGF2aW9yXG4gICAgICogbGVhZGluZ1plcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICogbGVhZGluZ1plcm86IFwiZGVueVwiLCAtIGFsbG93cyBvbmx5IG9uZSBsZWFkaW5nIHplcm8gb24gdmFsdWVzIGxlc3MgdGhhbiBvbmVcbiAgICAgKiBsZWFkaW5nWmVybzogXCJrZWVwXCIsIC0gYWxsb3dzIGxlYWRpbmcgemVyb3MgdG8gYmUgZW50ZXJlZC4gb24gZm9jdXNvdXQgemVyb3Mgd2lsbCBiZSByZXRhaW5lZC5cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbFplcm9cbiAgICAgKi9cbiAgICBsZWFkaW5nWmVybzogJ2RlbnknLFxuXG4gICAgLyogRGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAqIHRydWUgPSBhdXRvbWF0aWNhbGx5IGZvcm1hdHMgdGhlIGRlZmF1bHQgdmFsdWUgb24gaW5pdGlhbGl6YXRpb25cbiAgICAgKiBmYWxzZSA9IHdpbGwgbm90IGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhRm9ybVxuICAgICAqL1xuICAgIGZvcm1hdE9uUGFnZUxvYWQ6IHRydWUsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdCB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCwgb3Igb25seSB0aGUgaW5wdXQgbnVtZXJpYyB2YWx1ZVxuICAgICAqIE5vdGUgOiBJZiB0aGUgY3VycmVuY3kgc3ltYm9sIGlzIGJldHdlZW4gdGhlIG51bWVyaWMgdmFsdWUgYW5kIHRoZSBuZWdhdGl2ZSBzaWduLCBvbmx5IHRoZSBudW1lcmljIHZhbHVlIHdpbGwgc2VsZWN0ZWRcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogc051bWJlclxuICAgICAqL1xuICAgIHNlbGVjdE51bWJlck9ubHk6IGZhbHNlLFxuXG4gICAgLyogSGVscGVyIG9wdGlvbiBmb3IgQVNQLk5FVCBwb3N0YmFja1xuICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgKiBleGFtcGxlczpcbiAgICAgKiBubyBkZWZhdWx0IHZhbHVlPVwiXCIge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiBcIlwifVxuICAgICAqIHZhbHVlPTEyMzQuNTYge2RlZmF1bHRWYWx1ZU92ZXJyaWRlOiAnMTIzNC41Nid9XG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFuRGVmYXVsdFxuICAgICAqL1xuICAgIGRlZmF1bHRWYWx1ZU92ZXJyaWRlOiBudWxsLFxuXG4gICAgLyogUmVtb3ZlcyBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBldmVudFxuICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgKiByZXZpZXcgdGhlICd1blNldCcgbWV0aG9kIGZvciBvdGhlciBmb3JtYXRzXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHVuU2V0T25TdWJtaXRcbiAgICAgKi9cbiAgICB1bmZvcm1hdE9uU3VibWl0OiBmYWxzZSxcblxuICAgIC8qIEFsbG93cyB0aGUgb3V0cHV0IHRvIGJlIGluIHRoZSBsb2NhbGUgZm9ybWF0IHZpYSB0aGUgXCJnZXRcIiwgXCJnZXRTdHJpbmdcIiAmIFwiZ2V0QXJyYXlcIiBtZXRob2RzXG4gICAgICogbnVsbCBvciAnc3RyaW5nJyA9PiAnbm5ubi5ubicgb3IgJy1ubm5uLm5uJyBhcyB0ZXh0IHR5cGUuIFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogJ251bWJlcicgICAgICAgICA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGFzIGEgTnVtYmVyIChXYXJuaW5nOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGludGVnZXJzIGluZmVyaW9yIHRvIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKVxuICAgICAqICcsJyBvciAnLSwnICAgICAgPT4gJ25ubm4sbm4nIG9yICctbm5ubixubidcbiAgICAgKiAnLi0nICAgICAgICAgICAgID0+ICdubm5uLm5uJyBvciAnbm5ubi5ubi0nXG4gICAgICogJywtJyAgICAgICAgICAgICA9PiAnbm5ubixubicgb3IgJ25ubm4sbm4tJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBvdXRwdXRUeXBlXG4gICAgICovXG4gICAgb3V0cHV0Rm9ybWF0OiBudWxsLFxuXG4gICAgLyogRXJyb3IgaGFuZGxpbmcgZnVuY3Rpb25cbiAgICAgKiB0cnVlID0+IGFsbCB3YXJuaW5nIGFyZSBzaG93blxuICAgICAqIGZhbHNlID0+IG5vIHdhcm5pbmdzIGFyZSBzaG93biwgb25seSB0aGUgdGhyb3duIGVycm9yc1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBkZWJ1Z1xuICAgICAqL1xuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcblxuICAgIC8qXG4gICAgICogVGhpcyBvcHRpb24gaXMgdGhlICdzdHJpY3QgbW9kZScgKGFrYSAnZGVidWcnIG1vZGUpLCB3aGljaCBhbGxvd3MgYXV0b051bWVyaWMgdG8gc3RyaWN0bHkgYW5hbHlzZSB0aGUgb3B0aW9ucyBwYXNzZWQsIGFuZCBmYWlscyBpZiBhbiB1bmtub3duIG9wdGlvbnMgaXMgdXNlZCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0LlxuICAgICAqIFlvdSBzaG91bGQgc2V0IHRoYXQgdG8gJ1RSVUUnIGlmIHlvdSB3YW50IHRvIG1ha2Ugc3VyZSB5b3UgYXJlIG9ubHkgdXNpbmcgJ3B1cmUnIGF1dG9OdW1lcmljIHNldHRpbmdzIG9iamVjdHMgaW4geW91ciBjb2RlLlxuICAgICAqIElmIHlvdSBzZWUgdW5jYXVnaHQgZXJyb3JzIGluIHRoZSBjb25zb2xlIGFuZCB5b3VyIGNvZGUgc3RhcnRzIHRvIGZhaWwsIHRoaXMgbWVhbnMgc29tZWhvdyB0aG9zZSBvcHRpb25zIGdldHMgY29ycnVwdGVkIGJ5IGFub3RoZXIgcHJvZ3JhbS5cbiAgICAgKi9cbiAgICBmYWlsT25Vbmtub3duT3B0aW9uOiBmYWxzZSxcbn07XG5cbi8qKlxuICogV3JhcHBlciB2YXJpYWJsZSB0aGF0IGhvbGQgbmFtZWQga2V5Ym9hcmQga2V5cyB3aXRoIHRoZWlyIHJlc3BlY3RpdmUga2V5Q29kZSBhcyBzZWVuIGluIERPTSBldmVudHMuXG4gKi9cbmNvbnN0IGtleUNvZGUgPSB7XG4gICAgQmFja3NwYWNlOiAgICAgIDgsXG4gICAgVGFiOiAgICAgICAgICAgIDksXG4gICAgRW50ZXI6ICAgICAgICAgIDEzLFxuICAgIFNoaWZ0OiAgICAgICAgICAxNixcbiAgICBDdHJsOiAgICAgICAgICAgMTcsXG4gICAgQWx0OiAgICAgICAgICAgIDE4LFxuICAgIFBhdXNlQnJlYWs6ICAgICAxOSxcbiAgICBDYXBzTG9jazogICAgICAgMjAsXG4gICAgRXNjOiAgICAgICAgICAgIDI3LFxuICAgIFNwYWNlOiAgICAgICAgICAzMixcbiAgICBQYWdlVXA6ICAgICAgICAgMzMsXG4gICAgUGFnZURvd246ICAgICAgIDM0LFxuICAgIEVuZDogICAgICAgICAgICAzNSxcbiAgICBIb21lOiAgICAgICAgICAgMzYsXG4gICAgTGVmdEFycm93OiAgICAgIDM3LFxuICAgIFVwQXJyb3c6ICAgICAgICAzOCxcbiAgICBSaWdodEFycm93OiAgICAgMzksXG4gICAgRG93bkFycm93OiAgICAgIDQwLFxuICAgIEluc2VydDogICAgICAgICA0NSxcbiAgICBEZWxldGU6ICAgICAgICAgNDYsXG4gICAgbnVtMDogICAgICAgICAgIDQ4LFxuICAgIG51bTE6ICAgICAgICAgICA0OSxcbiAgICBudW0yOiAgICAgICAgICAgNTAsXG4gICAgbnVtMzogICAgICAgICAgIDUxLFxuICAgIG51bTQ6ICAgICAgICAgICA1MixcbiAgICBudW01OiAgICAgICAgICAgNTMsXG4gICAgbnVtNjogICAgICAgICAgIDU0LFxuICAgIG51bTc6ICAgICAgICAgICA1NSxcbiAgICBudW04OiAgICAgICAgICAgNTYsXG4gICAgbnVtOTogICAgICAgICAgIDU3LFxuICAgIGE6ICAgICAgICAgICAgICA2NSxcbiAgICBiOiAgICAgICAgICAgICAgNjYsXG4gICAgYzogICAgICAgICAgICAgIDY3LFxuICAgIGQ6ICAgICAgICAgICAgICA2OCxcbiAgICBlOiAgICAgICAgICAgICAgNjksXG4gICAgZjogICAgICAgICAgICAgIDcwLFxuICAgIGc6ICAgICAgICAgICAgICA3MSxcbiAgICBoOiAgICAgICAgICAgICAgNzIsXG4gICAgaTogICAgICAgICAgICAgIDczLFxuICAgIGo6ICAgICAgICAgICAgICA3NCxcbiAgICBrOiAgICAgICAgICAgICAgNzUsXG4gICAgbDogICAgICAgICAgICAgIDc2LFxuICAgIG06ICAgICAgICAgICAgICA3NyxcbiAgICBuOiAgICAgICAgICAgICAgNzgsXG4gICAgbzogICAgICAgICAgICAgIDc5LFxuICAgIHA6ICAgICAgICAgICAgICA4MCxcbiAgICBxOiAgICAgICAgICAgICAgODEsXG4gICAgcjogICAgICAgICAgICAgIDgyLFxuICAgIHM6ICAgICAgICAgICAgICA4MyxcbiAgICB0OiAgICAgICAgICAgICAgODQsXG4gICAgdTogICAgICAgICAgICAgIDg1LFxuICAgIHY6ICAgICAgICAgICAgICA4NixcbiAgICB3OiAgICAgICAgICAgICAgODcsXG4gICAgeDogICAgICAgICAgICAgIDg4LFxuICAgIHk6ICAgICAgICAgICAgICA4OSxcbiAgICB6OiAgICAgICAgICAgICAgOTAsXG4gICAgV2luZG93czogICAgICAgIDkxLFxuICAgIFJpZ2h0Q2xpY2s6ICAgICA5MyxcbiAgICBudW1wYWQwOiAgICAgICAgOTYsXG4gICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgIG51bXBhZDI6ICAgICAgICA5OCxcbiAgICBudW1wYWQzOiAgICAgICAgOTksXG4gICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICBudW1wYWQ1OiAgICAgICAgMTAxLFxuICAgIG51bXBhZDY6ICAgICAgICAxMDIsXG4gICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICBudW1wYWQ4OiAgICAgICAgMTA0LFxuICAgIG51bXBhZDk6ICAgICAgICAxMDUsXG4gICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICBQbHVzTnVtcGFkOiAgICAgMTA3LFxuICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXG4gICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICBTbGFzaE51bXBhZDogICAgMTExLFxuICAgIEYxOiAgICAgICAgICAgICAxMTIsXG4gICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICBGMzogICAgICAgICAgICAgMTE0LFxuICAgIEY0OiAgICAgICAgICAgICAxMTUsXG4gICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICBGNjogICAgICAgICAgICAgMTE3LFxuICAgIEY3OiAgICAgICAgICAgICAxMTgsXG4gICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICBGOTogICAgICAgICAgICAgMTIwLFxuICAgIEYxMDogICAgICAgICAgICAxMjEsXG4gICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICBGMTI6ICAgICAgICAgICAgMTIzLFxuICAgIE51bUxvY2s6ICAgICAgICAxNDQsXG4gICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICBNeUNvbXB1dGVyOiAgICAgMTgyLFxuICAgIE15Q2FsY3VsYXRvcjogICAxODMsXG4gICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICBFcXVhbDogICAgICAgICAgMTg3LFxuICAgIENvbW1hOiAgICAgICAgICAxODgsXG4gICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICBEb3Q6ICAgICAgICAgICAgMTkwLFxuICAgIFNsYXNoOiAgICAgICAgICAxOTEsXG4gICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICBMZWZ0QnJhY2tldDogICAgMjE5LFxuICAgIEJhY2tzbGFzaDogICAgICAyMjAsXG4gICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICBRdW90ZTogICAgICAgICAgMjIyLFxuICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXG59O1xuXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS9Db21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG59IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG59XG59KCQgPT4ge1xuICAgIC8vIEhlbHBlciBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGxcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIG51bGwsIEZBTFNFIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gdGVzdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIEZBTFNFIG90aGVyd2lzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIG51bGwgb3IgZW1wdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkKDApIHx8ICcnID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIGEgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIGJvb2xlYW5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YodmFsdWUpID09PSAnYm9vbGVhbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyAndHJ1ZScgb3IgJ2ZhbHNlJ1xuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFueSBjYXNlcyBmb3IgdGhvc2Ugc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1RydWVPckZhbHNlU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGxvd2VyY2FzZVZhbHVlID0gU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gbG93ZXJjYXNlVmFsdWUgPT09ICd0cnVlJyB8fCBsb3dlcmNhc2VWYWx1ZSA9PT0gJ2ZhbHNlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSByZWZlcmVuY2VcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc09iamVjdChyZWZlcmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZlcmVuY2UgPT09ICdvYmplY3QnICYmIHJlZmVyZW5jZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShyZWZlcmVuY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgZW1wdHlcbiAgICAgKiBjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82Nzk5MTUvaG93LWRvLWktdGVzdC1mb3ItYW4tZW1wdHktamF2YXNjcmlwdC1vYmplY3QgYW5kIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5LW9iamVjdC10ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbXB0eU9iaihvYmopIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgbnVtYmVyIChvciBhIG51bWJlciB3cml0dGVuIGFzIGEgc3RyaW5nKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc0FycmF5KG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIGludGVnZXIgKGFuZCBub3QgYSBmbG9hdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludChuKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbiA9PT0gJ251bWJlcicgJiYgcGFyc2VGbG9hdChuKSA9PT0gcGFyc2VJbnQobiwgMTApICYmICFpc05hTihuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBhc3RlZCB0ZXh0IHRoYXQgd2lsbCBiZSB1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJlcGFyZVBhc3RlZFRleHQodGV4dCwgaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModGV4dCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUsIHRydWUpLnJlcGxhY2UoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc3RyaW5nIGBzdHJgIGNvbnRhaW5zIHRoZSBzdHJpbmcgYG5lZWRsZWBcbiAgICAgKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNvZXJjZSB0aGUgcGFyYW1ldGVycyB0eXBlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb250YWlucyhzdHIsIG5lZWRsZSkge1xuICAgICAgICBpZiAoIWlzU3RyaW5nKHN0cikgfHwgIWlzU3RyaW5nKG5lZWRsZSkgfHwgc3RyID09PSAnJyB8fCBuZWVkbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGBuZWVkbGVgIGlzIGluIHRoZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW5BcnJheShuZWVkbGUsIGFycmF5KSB7XG4gICAgICAgIGlmICghaXNBcnJheShhcnJheSkgfHwgYXJyYXkgPT09IFtdIHx8IGlzVW5kZWZpbmVkKG5lZWRsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gQXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gYXJyXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqIEByZXR1cm5zIHsqfGJvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheShhcnIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChbXSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHsgLy8gTWFrZSBzdXJlIGFuIGFycmF5IGhhcyBhIGNsYXNzIGF0dHJpYnV0ZSBvZiBbb2JqZWN0IEFycmF5XVxuICAgICAgICAgICAgLy8gVGVzdCBwYXNzZWQsIG5vdyBjaGVjayBpZiBpcyBhbiBBcnJheVxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSB8fCAodHlwZW9mIGFyciA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT09ICdbb2JqZWN0IEFycmF5XScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0b1N0cmluZyBtZXNzYWdlIGNoYW5nZWQgZm9yIE9iamVjdCBBcnJheScpOyAvLyBWZXJpZnkgdGhhdCB0aGUgc3RyaW5nIHJldHVybmVkIGJ5IGB0b1N0cmluZ2AgZG9lcyBub3QgY2hhbmdlIGluIHRoZSBmdXR1cmUgKGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84MzY1MjE1KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAvLyBmdW5jdGlvbiBoYXNEZWNpbWFscyhzdHIpIHtcbiAgICAvLyAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgLy8gICAgIHJldHVybiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpO1xuICAgIC8vIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgZmxvYXQgbnVtYmVyLCBhbmQgdGhhdCBudW1iZXIgaGFzIGEgZGVjaW1hbCBwYXJ0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtpbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjaW1hbFBsYWNlcyhzdHIpIHtcbiAgICAgICAgY29uc3QgWywgZGVjaW1hbFBhcnRdID0gc3RyLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjaW1hbFBhcnQubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb2RlIGZvciB0aGUga2V5IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfE51bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZXkoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiB2YWx1ZSAoYSBudW1iZXIgYXMgYSBzdHJpbmcpIGlzIHdpdGhpbiB0aGUgcmFuZ2Ugc2V0IGluIHRoZSBzZXR0aW5ncyBgbWluaW11bVZhbHVlYCBhbmQgYG1heGltdW1WYWx1ZWAsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNaW5WYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWF4VmFsdWUgUGFyc2VkIHZpYSB0aGUgYHBhcnNlU3RyKClgIGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tJZkluUmFuZ2UodmFsdWUsIHBhcnNlZE1pblZhbHVlLCBwYXJzZWRNYXhWYWx1ZSkge1xuICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlU3RyKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRlc3RNaW5NYXgocGFyc2VkTWluVmFsdWUsIHBhcnNlZFZhbHVlKSA+IC0xICYmIHRlc3RNaW5NYXgocGFyc2VkTWF4VmFsdWUsIHBhcnNlZFZhbHVlKSA8IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIG5lZ2F0aXZlIHNpZ24gb24gdGhlIGZpcnN0IGNoYXJhY3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgQSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgYSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05lZ2F0aXZlKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKSA9PT0gJy0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbmVnYXRpdmUgdmVyc2lvbiBvZiB0aGUgdmFsdWUgKHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nKSBnaXZlbiBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFJhd05lZ2F0aXZlU2lnbih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzTmVnYXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYC0ke3ZhbHVlfWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgY2hhcmFjdGVyIG9yIGEgc3RyaW5nIGF0IHRoZSBpbmRleCBnaXZlbiAoMCBiZWluZyB0aGUgZmFyIGxlZnQgc2lkZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zZXJ0Q2hhckF0UG9zaXRpb24oc3RyLCBjaGFyLCBjYXJldFBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBgJHtzdHIuc2xpY2UoMCwgY2FyZXRQb3NpdGlvbil9JHtjaGFyfSR7c3RyLnNsaWNlKGNhcmV0UG9zaXRpb24pfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgY2hhcmFjdGVyIGF0IHRoZSBwb3NpdGlvbiBgaW5kZXhgIGluIHRoZSBzdHJpbmcgYHN0cmluZ2AgYnkgdGhlIGNoYXJhY3RlcihzKSBgbmV3Q2hhcmFjdGVyYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gaW5kZXhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlQ2hhckF0KHN0cmluZywgaW5kZXgsIG5ld0NoYXJhY3Rlcikge1xuICAgICAgICByZXR1cm4gYCR7c3RyaW5nLnN1YnN0cigwLCBpbmRleCl9JHtuZXdDaGFyYWN0ZXJ9JHtzdHJpbmcuc3Vic3RyKGluZGV4ICsgbmV3Q2hhcmFjdGVyLmxlbmd0aCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIGNsYW1wZWQgdG8gdGhlIG5lYXJlc3QgbWluaW11bS9tYXhpbXVtIHZhbHVlLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wVG9SYW5nZUxpbWl0cyh2YWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgLy9YWFggVGhpcyBmdW5jdGlvbiBhbHdheXMgYXNzdW1lIGBzZXR0aW5ncy5taW5pbXVtVmFsdWVgIGlzIGxvd2VyIHRoYW4gYHNldHRpbmdzLm1heGltdW1WYWx1ZWBcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgTWF0aC5taW4oc2V0dGluZ3MubWF4aW11bVZhbHVlLCB2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIG51bWJlciBvciBkb3QgY2hhcmFjdGVycyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBjYXJldCwgaW4gYSBmb3JtYXR0ZWQgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZE51bWJlclN0cmluZ1xuICAgICAqIEBwYXJhbSB7aW50fSBjYXJldFBvc2l0aW9uIFRoaXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbENoYXJhY3RlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGZvcm1hdHRlZE51bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbiwgZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAvLyBIZXJlIHdlIGNvdW50IHRoZSBkb3QgYW5kIHJlcG9ydCBpdCBhcyBhIG51bWJlciBjaGFyYWN0ZXIgdG9vLCBzaW5jZSBpdCB3aWxsICdzdGF5JyBpbiB0aGUgSmF2YXNjcmlwdCBudW1iZXIgd2hlbiB1bmZvcm1hdHRlZFxuICAgICAgICBjb25zdCBudW1iZXJEb3RPck5lZ2F0aXZlU2lnbiA9IG5ldyBSZWdFeHAoYFswLTkke2RlY2ltYWxDaGFyYWN0ZXJ9LV1gKTsgLy8gTm8gbmVlZCB0byBlc2NhcGUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGhlcmUsIHNpbmNlIGl0J3MgaW4gYFtdYFxuXG4gICAgICAgIGxldCBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FyZXRQb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSBjaGFyYWN0ZXIgaXMgYSBudW1iZXIsIGEgZG90IG9yIGFuIGh5cGhlbi4gSWYgaXQgaXMsIGNvdW50IGl0LCBvdGhlcndpc2UgaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAobnVtYmVyRG90T3JOZWdhdGl2ZVNpZ24udGVzdChmb3JtYXR0ZWROdW1iZXJTdHJpbmdbaV0pKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWxrIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nYCBmcm9tIGxlZnQgdG8gcmlnaHQsIG9uZSBjaGFyIGJ5IG9uZSwgY291bnRpbmcgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleGAuXG4gICAgICogSWYgdGhlIGNoYXIgaXMgaW4gdGhlIGByYXdOdW1iZXJTdHJpbmdgIChzdGFydGluZyBhdCBpbmRleCAwKSwgdGhlbiBgcmF3TnVtYmVyU3RyaW5nSW5kZXgrK2AsIGFuZCBjb250aW51ZSB1bnRpbFxuICAgICAqIHRoZXJlIGlzIG5vIG1vcmUgY2hhcmFjdGVycyBpbiBgcmF3TnVtYmVyU3RyaW5nYCkgb3IgdGhhdCBgcmF3TnVtYmVyU3RyaW5nSW5kZXggPT09IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlYC5cbiAgICAgKiBXaGVuIHlvdSBzdG9wLCB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YCBpcyB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGNhcmV0IHNob3VsZCBiZSBzZXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIDEyMzQ1Njd8ODkuMDEgICA6IHBvc2l0aW9uIDcgKHJhd051bWJlclN0cmluZylcbiAgICAgKiAxMjMuNDU2Ljd8ODksMDEgOiBwb3NpdGlvbiA5IChmb3JtYXR0ZWROdW1iZXJTdHJpbmcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmF3TnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZE51bWJlclN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyYXdOdW1iZXJTdHJpbmcsIGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlLCBmb3JtYXR0ZWROdW1iZXJTdHJpbmcsIGRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkTnVtYmVyU3RyaW5nU2l6ZSA9IGZvcm1hdHRlZE51bWJlclN0cmluZy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJhd051bWJlclN0cmluZ1NpemUgPSByYXdOdW1iZXJTdHJpbmcubGVuZ3RoO1xuXG4gICAgICAgIGxldCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleDtcbiAgICAgICAgbGV0IHJhd051bWJlclN0cmluZ0luZGV4ID0gMDtcbiAgICAgICAgZm9yIChmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA9IDA7XG4gICAgICAgICAgICAgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXggPCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplICYmXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCByYXdOdW1iZXJTdHJpbmdTaXplICYmXG4gICAgICAgICAgICAgcmF3TnVtYmVyU3RyaW5nSW5kZXggPCBjYXJldFBvc2l0aW9uSW5SYXdWYWx1ZTtcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAocmF3TnVtYmVyU3RyaW5nW3Jhd051bWJlclN0cmluZ0luZGV4XSA9PT0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSB8fFxuICAgICAgICAgICAgICAgIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSAnLicgJiYgZm9ybWF0dGVkTnVtYmVyU3RyaW5nW2Zvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4XSA9PT0gZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGRvdCAnLicgaW4gdGhlIGdpdmVuIHRleHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY291bnREb3RzSW5UZXh0KHRleHQpIHtcbiAgICAgICAgcmV0dXJuIGNvdW50Q2hhckluVGV4dCgnLicsIHRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50IHRoZSBudW1iZXIgb2Ygb2NjdXJyZW5jZSBvZiB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpbiB0aGUgZ2l2ZW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY291bnRDaGFySW5UZXh0KGNoYXJhY3RlciwgdGV4dCkge1xuICAgICAgICBsZXQgY2hhckNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZXh0W2ldID09PSBjaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjaGFyQ291bnRlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoYXJDb3VudGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgaW5kZXggdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uLlxuICAgICAqIFRoaXMgdGFrZXMgaW50byBhY2NvdW50IHRoYXQgdGhlIHBvc2l0aW9uIGlzIHN0YXJ0aW5nIGF0ICcwJywgbm90IDEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludH0gY2hhcmFjdGVyQ291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjaGFyYWN0ZXJDb3VudCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoY2hhcmFjdGVyQ291bnQsIGNoYXJhY3RlckNvdW50IC0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBnZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gdGhhdFxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gdGhhdFxuICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxuICAgICAqIEBwYXJhbSB7aW50fG51bGx9IGVuZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCA9IG51bGwpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShlbmQpKSB7XG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGF0LnNlbGVjdGlvblN0YXJ0KSkge1xuICAgICAgICAgICAgdGhhdC5mb2N1cygpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGF0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBlbmQpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZVN0YXJ0KCdjaGFyYWN0ZXInLCBzdGFydCk7XG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0aW9uRW5kID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCB0aHJvdyBlcnJvciBtZXNzYWdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhIHdhcm5pbmcgbWVzc2FnZXMsIGFjY29yZGluZyB0byB0aGUgZGVidWcgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvd1dhcm5pbmcgSWYgRkFMU0UsIHRoZW4gdGhlIHdhcm5pbmcgbWVzc2FnZSBpcyBub3QgZGlzcGxheWVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2FybmluZyhtZXNzYWdlLCBzaG93V2FybmluZyA9IHRydWUpIHtcbiAgICAgICAgaWYgKHNob3dXYXJuaW5nKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY29uc29sZTogMCAqL1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBXYXJuaW5nOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdXRvTnVtZXJpYy1zcGVjaWZpYyBmdW5jdGlvbnNcblxuICAgIC8qKlxuICAgICAqIFJ1biBhbnkgY2FsbGJhY2tzIGZvdW5kIGluIHRoZSBzZXR0aW5ncyBvYmplY3QuXG4gICAgICogQW55IHBhcmFtZXRlciBjb3VsZCBiZSBhIGNhbGxiYWNrOlxuICAgICAqIC0gYSBmdW5jdGlvbiwgd2hpY2ggaW52b2tlZCB3aXRoIGpRdWVyeSBlbGVtZW50LCBwYXJhbWV0ZXJzIGFuZCB0aGlzIHBhcmFtZXRlciBuYW1lIGFuZCByZXR1cm5zIHBhcmFtZXRlciB2YWx1ZVxuICAgICAqIC0gYSBuYW1lIG9mIGZ1bmN0aW9uLCBhdHRhY2hlZCB0byAkKHNlbGVjdG9yKS5hdXRvTnVtZXJpYy5mdW5jdGlvbk5hbWUoKXt9IC0gd2hpY2ggd2FzIGNhbGxlZCBwcmV2aW91c2x5XG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gTG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbWF4aW11bSBkZWNpbWFsIGxlbmd0aCBmcm9tIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1pbmltdW1WYWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXhpbXVtVmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgobWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGRlY2ltYWxQbGFjZXMobWluaW11bVZhbHVlKSwgZGVjaW1hbFBsYWNlcyhtYXhpbXVtVmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHJpcCBhbGwgdW53YW50ZWQgbm9uLW51bWJlciBjaGFyYWN0ZXJzIGFuZCBsZWF2ZSBvbmx5IGEgbnVtYmVyIGFsZXJ0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVmdE9yQWxsXG4gICAgICogQHJldHVybnMge3N0cmluZ3wqfVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHMsIHNldHRpbmdzLCBsZWZ0T3JBbGwpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLnN1ZmZpeFRleHQpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJiBjb250YWlucyhzLCAnLScpICYmIHMgIT09ICcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XG5cbiAgICAgICAgLy8gVGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RpbmcgY2hhcmFjdGVyc1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGxlZnRPckFsbCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB8fFxuICAgICAgICAgICAgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIGZvY3VzIHN0YXRlLlxuICAgICAqIFRoZSBmb2N1cyBzdGF0ZSBpcyAnc3RvcmVkJyBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IHVuZGVyIHRoZSBgc2V0dGluZ3Mub25PZmZgIGF0dHJpYnV0ZS4gLy9UT0RPIFVzZSBhbm90aGVyIG9iamVjdCB0byBrZWVwIHRyYWNrIG9mIGludGVybmFsIGRhdGEgdGhhdCBhcmUgbm90IHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChzLCBzZXR0aW5ncykge1xuICAgICAgICBpZiAoKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJykgfHwgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdEJyYWNrZXQsIGxhc3RCcmFja2V0XSA9IHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICcnKTtcbiAgICAgICAgICAgICAgICBzID0gZmlyc3RCcmFja2V0ICsgcyArIGxhc3RCcmFja2V0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5vbk9mZiAmJiBzLmNoYXJBdCgwKSA9PT0gZmlyc3RCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCBsb2NhbGUgZm9ybWF0IHRvIEphdmFzY3JpcHQgbnVtZXJpYyBzdHJpbmdcbiAgICAgKiBBbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgcGVyaW9kIG9yIGEgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZCBvZiBjdXJyZW5jeSBzaWducyBhbGxvd2VkXG4gICAgICogJzEyMzQuNTYnICAgIE9LXG4gICAgICogJy0xMjM0LjU2JyAgIE9LXG4gICAgICogJzEyMzQuNTYtJyAgIE9LXG4gICAgICogJzEyMzQsNTYnICAgIE9LXG4gICAgICogJy0xMjM0LDU2JyAgIE9LXG4gICAgICogJzEyMzQsNTYtJyAgIE9LXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tTG9jYWxlKHMpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnLCcsICcuJyk7XG4gICAgICAgIGlmIChjb250YWlucyhzLCAnLScpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgcyA9ICctJyArIHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgSVNPIG51bWVyaWMgc3RyaW5nIHRvIHRoZSBsb2NhbGUgZGVjaW1hbCBhbmQgbWludXMgc2lnbiBwbGFjZW1lbnQuXG4gICAgICogU2VlIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xvY2FsZSh2YWx1ZSwgbG9jYWxlKSB7XG4gICAgICAgIGlmIChpc051bGwobG9jYWxlKSB8fCBsb2NhbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKGxvY2FsZSkge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLi0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRhaW5zKHZhbHVlLCAnLScpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICBjYXNlICctLCc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcsLSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gY29udGFpbnMocmVzdWx0LCAnLScpID8gcmVzdWx0LnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBjYXNlXG4gICAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIGNhc2UgJy0uJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBnaXZlbiBvdXRwdXRGb3JtYXQgWyR7bG9jYWxlfV0gb3B0aW9uIGlzIG5vdCByZWNvZ25pemVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBvZiB0aGUgZ2l2ZW4gc3RyaW5nIHZhbHVlIHRvIGFuIGh5cGhlbiAoLSkgYW5kIGEgZG90ICguKSBpbiBvcmRlciB0byBtYWtlIHRoYXQgdmFsdWUgJ3R5cGVjYXN0YWJsZScgdG8gYSByZWFsIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yUmF3VmFsdWUocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSByZXR1cm5lZCBieSBgZ2V0YCBpcyBmb3JtYXR0ZWQgd2l0aCBkZWNpbWFsc1xuICAgICAgICAgICAgcyArPSAnMC4wMCc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHRoZSBkZWNpbWFsIGNoYXJhY3RlciB0byB1c2UgdGhvc2UgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvckZvcm1hdHRlZFZhbHVlKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICctJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCcuJywgc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvciBlbXB0eSB2YWx1ZVxuICAgICAqIC8vVE9ETyBNb2RpZnkgdGhpcyBmdW5jdGlvbiBzbyB0aGF0IGl0IHJldHVybiBlaXRoZXIgVFJVRSBvciBGQUxTRSBpZiB0aGUgdmFsdWUgaXMgZW1wdHkuIFRoZW4gY3JlYXRlIGFub3RoZXIgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBpbnB1dCB2YWx1ZSBpZiBpdCdzIG5vdCBlbXB0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWduT25FbXB0eVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrRW1wdHkoaW5wdXRWYWx1ZSwgc2V0dGluZ3MsIHNpZ25PbkVtcHR5KSB7XG4gICAgICAgIGlmIChpbnB1dFZhbHVlID09PSAnJyB8fCBpbnB1dFZhbHVlID09PSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdhbHdheXMnIHx8IHNpZ25PbkVtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSA/IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHNldHRpbmdzLnN1ZmZpeFRleHQgOiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWUgKyBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgaW5wdXQgdmFsdWUgYnkgYWRkaW5nIHRoZSBncm91cCBzZXBhcmF0b3JzLCBhcyBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkR3JvdXBTZXBhcmF0b3JzKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zdHJpcCkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhpbnB1dFZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGlucHV0VmFsdWUsICctJykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnLScgKyBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW1wdHkgPSBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IGNvbnRhaW5zKGlucHV0VmFsdWUsICctJyk7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwoZW1wdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nID0gc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZy50b1N0cmluZygpO1xuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwO1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcycyc6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcn0kMmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAhPT0gMCAmJiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSm9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgaXQncyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgKyBpbnB1dFZhbHVlICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIGlucHV0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCArIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlICsgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgKHNldHRpbmdzLnJhd1ZhbHVlIDwgMCB8fCBpbnB1dFZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChpbnB1dFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHJldHVybiBpbnB1dFZhbHVlICsgc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcm91bmRlZElucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge2ludH0gdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlXG4gICAgICogQHJldHVybnMge3ZvaWR8WE1MfHN0cmluZ3wqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlWmVyb3Mocm91bmRlZElucHV0VmFsdWUsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIHN3aXRjaCAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudHMgcGFkZGluZyAtIHJlbW92ZXMgdHJhaWxpbmcgemVyb3MgdW50aWwgdGhlIGZpcnN0IHNpZ25pZmljYW50IGRpZ2l0IGlzIGVuY291bnRlcmVkXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLig/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgLy8gQWxsb3dzIHBhZGRpbmcgd2hlbiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgZXF1YWxzIG9uZSAtIGxlYXZlcyBvbmUgemVybyB0cmFpbGluZyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgYWNjZXNzIHplcm9zIHRvIHRoZSBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgbGVuZ3RoIHdoZW4gYWxsb3dEZWNpbWFsUGFkZGluZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHt0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGV9fSg/OlxcXFxkKlsxLTldKT8pMCpgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBkZWNpbWFsIHBsYWNlcywgd2UgZG9uJ3QgbmVlZCBhIGRlY2ltYWwgcG9pbnQgYXQgdGhlIGVuZFxuICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAodGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID09PSAwKSB7XG4gICAgICAgICAgICByb3VuZGVkSW5wdXRWYWx1ZSA9IHJvdW5kZWRJbnB1dFZhbHVlLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcm91bmRlZElucHV0VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmQgdGhlIGlucHV0IHZhbHVlIHVzaW5nIHRoZSByb3VuZGluZyBtZXRob2QgZGVmaW5lZCBpbiB0aGUgc2V0dGluZ3MuXG4gICAgICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIG11bHRpcGxlIHJvdW5kaW5nIG1ldGhvZHMuIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHRob3NlLlxuICAgICAqXG4gICAgICogTm90ZSA6IFRoaXMgaXMgaGFuZGxlZCBhcyB0ZXh0IHNpbmNlIEphdmFTY3JpcHQgbWF0aCBmdW5jdGlvbiBjYW4gcmV0dXJuIGluYWNjdXJhdGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByb3VuZFZhbHVlKGlucHV0VmFsdWUsIHNldHRpbmdzKSB7XG4gICAgICAgIGlucHV0VmFsdWUgPSAoaW5wdXRWYWx1ZSA9PT0gJycpID8gJzAnIDogaW5wdXRWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdOMDUnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQ0hGJyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UwNScgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdEMDUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTjA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLnJvdW5kKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmNlaWwoaW5wdXRWYWx1ZSAqIDIwKSAvIDIwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IChNYXRoLmZsb29yKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghY29udGFpbnMoaW5wdXRWYWx1ZSwgJy4nKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0VmFsdWUgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRWYWx1ZS5sZW5ndGggLSBpbnB1dFZhbHVlLmluZGV4T2YoJy4nKSA8IDMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpdlJvdW5kZWQgPSAnJztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgbGV0IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZTtcblxuICAgICAgICAvLyBzZXRzIHRoZSB0cnVuY2F0ZSB6ZXJvIG1ldGhvZFxuICAgICAgICBpZiAoc2V0dGluZ3MuYWxsb3dEZWNpbWFsUGFkZGluZykge1xuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgaW5wdXRWYWx1ZSAoaW5wdXQgVmFsdWUpIGlzIGEgbmVnYXRpdmUgdmFsdWVcbiAgICAgICAgaWYgKGlucHV0VmFsdWUuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHRoYXQgd2lsbCBiZSBhZGRlZCBiYWNrIGxhdGVyIGlmIHJlcXVpcmVkXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXBwZW5kIGEgemVybyBpZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhIGRpZ2l0ICh0aGVuIGl0IGlzIGxpa2VseSB0byBiZSBhIGRvdClcbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlLm1hdGNoKC9eXFxkLykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnMCcgKyBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lcyBpZiB0aGUgdmFsdWUgaXMgZXF1YWwgdG8gemVyby4gSWYgaXQgaXMsIHJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBOdW1iZXIoaW5wdXRWYWx1ZSkgPT09IDApIHtcbiAgICAgICAgICAgIG5TaWduID0gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmltcyBsZWFkaW5nIHplcm8ncyBhcyBuZWVkZWRcbiAgICAgICAgaWYgKChOdW1iZXIoaW5wdXRWYWx1ZSkgPiAwICYmIHNldHRpbmdzLmxlYWRpbmdaZXJvICE9PSAna2VlcCcpIHx8IChpbnB1dFZhbHVlLmxlbmd0aCA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gPT09ICdhbGxvdycpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGlucHV0VmFsdWUubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgICAgY29uc3QgaW5wdXRWYWx1ZUhhc0FEb3QgPSBkUG9zID09PSAtMTtcblxuICAgICAgICAvLyBWaXJ0dWFsIGRlY2ltYWwgcG9zaXRpb25cbiAgICAgICAgY29uc3QgdmRQb3MgPSBpbnB1dFZhbHVlSGFzQURvdCA/IGlucHV0VmFsdWUubGVuZ3RoIC0gMSA6IGRQb3M7XG5cbiAgICAgICAgLy8gQ2hlY2tzIGRlY2ltYWwgcGxhY2VzIHRvIGRldGVybWluZSBpZiByb3VuZGluZyBpcyByZXF1aXJlZCA6XG4gICAgICAgIC8vIENoZWNrIGlmIG5vIHJvdW5kaW5nIGlzIHJlcXVpcmVkXG4gICAgICAgIGxldCBjRGVjID0gKGlucHV0VmFsdWUubGVuZ3RoIC0gMSkgLSB2ZFBvcztcblxuICAgICAgICBpZiAoY0RlYyA8PSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gcGFkIHdpdGggemVyb3NcbiAgICAgICAgICAgIGl2Um91bmRlZCA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICBpZiAoY0RlYyA8IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgemVyb3MgPSAnMDAwMDAwJztcbiAgICAgICAgICAgICAgICB3aGlsZSAoY0RlYyA8IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICB6ZXJvcyA9IHplcm9zLnN1YnN0cmluZygwLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgLSBjRGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2Um91bmRlZCwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA9PT0gMCAmJiB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgbGV0IHJMZW5ndGg7XG4gICAgICAgIGlmIChpbnB1dFZhbHVlSGFzQURvdCkge1xuICAgICAgICAgICAgckxlbmd0aCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlICsgZFBvcztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRSb3VuZCA9IE51bWJlcihpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoICsgMSkpO1xuICAgICAgICBjb25zdCBvZGQgPSAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCkgPT09ICcuJykgPyAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCAtIDEpICUgMikgOiAoaW5wdXRWYWx1ZS5jaGFyQXQockxlbmd0aCkgJSAyKTtcbiAgICAgICAgbGV0IGl2QXJyYXkgPSBpbnB1dFZhbHVlLnN1YnN0cmluZygwLCByTGVuZ3RoICsgMSkuc3BsaXQoJycpO1xuXG4gICAgICAgIGlmICgodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgdXAgYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDQgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdhJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBuZWdhdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0InICYmIG9kZCA9PT0gMSkgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0MnICYmIG5TaWduID09PSAnJykgIHx8IC8vIFJvdW5kIHRvIGNlaWxpbmcgdG93YXJkIHBvc2l0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdVJykpIHsgICAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCBhd2F5IGZyb20gemVyb1xuICAgICAgICAgICAgLy8gUm91bmQgdXAgdGhlIGxhc3QgZGlnaXQgaWYgcmVxdWlyZWQsIGFuZCBjb250aW51ZSB1bnRpbCBubyBtb3JlIDkncyBhcmUgZm91bmRcbiAgICAgICAgICAgIGZvciAoaSA9IChpdkFycmF5Lmxlbmd0aCAtIDEpOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICtpdkFycmF5W2ldICsgMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gPCAxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWNvbnN0cnVjdCB0aGUgc3RyaW5nLCBjb252ZXJ0aW5nIGFueSAxMCdzIHRvIDAnc1xuICAgICAgICBpdkFycmF5ID0gaXZBcnJheS5zbGljZSgwLCByTGVuZ3RoICsgMSk7XG5cbiAgICAgICAgLy8gUmV0dXJuIHRoZSByb3VuZGVkIHZhbHVlXG4gICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZBcnJheS5qb2luKCcnKSwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRydW5jYXRlcyB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIGlzUGFzdGUpIHtcbiAgICAgICAgcyA9IChpc1Bhc3RlKSA/IHJvdW5kVmFsdWUocywgc2V0dGluZ3MpIDogcztcblxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAmJiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcblxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgZGVjaW1hbCBwYXJ0IHRvIHNhdGlzZnlpbmcgbGVuZ3RoIHNpbmNlIHdlIHdvdWxkIHJvdW5kIGl0IGFueXdheVxuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0ICYmIGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkRGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgICAgICAgICAgcyA9IGAke2ludGVnZXJQYXJ0fSR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke21vZGlmaWVkRGVjaW1hbFBhcnR9YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gcGFyc2UgbWluaW11bVZhbHVlLCBtYXhpbXVtVmFsdWUgJiB0aGUgaW5wdXQgdmFsdWUgdG8gcHJlcGFyZSBmb3IgdGVzdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIC8gbWF4IHJhbmdlLlxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogbWluaW11bVZhbHVlOiBcIjk5OTk5OTk5OTk5OTk5OS45OVwiIHJldHVybnMgdGhlIGZvbGxvd2luZyBcIntzOiAtMSwgZTogMTIsIGM6IEFycmF5WzE1XX1cIi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuIEEgbnVtZXJpYyB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VTdHIobikge1xuICAgICAgICBjb25zdCB4ID0ge307IC8vIEEgQmlnIG51bWJlciBpbnN0YW5jZS5cbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5ncy5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIHBhcnNlZCBzdHJpbmdzIGZvciB0aGUgYWJvdmUgcGFyc2VTdHIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzLy4gTWFueSB0aGFua3MgdG8gTWlrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB5IEJpZyBudW1iZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0geCBCaWcgbnVtYmVyIGluc3RhbmNlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdGVzdE1pbk1heCh5LCB4KSB7XG4gICAgICAgIGNvbnN0IHhjID0geC5jO1xuICAgICAgICBjb25zdCB5YyA9IHkuYztcbiAgICAgICAgbGV0IGkgPSB4LnM7XG4gICAgICAgIGxldCBqID0geS5zO1xuICAgICAgICBsZXQgayA9IHguZTtcbiAgICAgICAgbGV0IGwgPSB5LmU7XG5cbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKCF4Y1swXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICF5Y1swXT8wOi1qO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cbiAgICAgICAgaWYgKGkgIT09IGopIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhOZWcgPSBpIDwgMDtcblxuICAgICAgICAvLyBDb21wYXJlIGV4cG9uZW50c1xuICAgICAgICBpZiAoayAhPT0gbCkge1xuICAgICAgICAgICAgcmV0dXJuIChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IC0xO1xuICAgICAgICBrID0geGMubGVuZ3RoO1xuICAgICAgICBsID0geWMubGVuZ3RoO1xuICAgICAgICBqID0gKGsgPCBsKSA/IGsgOiBsO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXRcbiAgICAgICAgZm9yIChpICs9IDE7IGkgPCBqOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICh4Y1tpXSAhPT0geWNbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHhjW2ldID4geWNbaV0gXiB4TmVnKT8xOi0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcGFyZSBsZW5ndGhzXG4gICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgIGlmIChrID09PSBsKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgbnVtYmVyIHNhdGlzZnkgdGhlIGZvcm1hdCBjb25kaXRpb25zXG4gICAgICogYW5kIGxheXMgYmV0d2VlbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxuICAgICAqIGFuZCB0aGUgc3RyaW5nIGxlbmd0aCBkb2VzIG5vdCBleGNlZWQgdGhlIGRpZ2l0cyBpbiBzZXR0aW5ncy5taW5pbXVtVmFsdWUgYW5kIHNldHRpbmdzLm1heGltdW1WYWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbihzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy5taW5pbXVtVmFsdWUpO1xuICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1heGltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IHZhbFBhcnNlID0gcGFyc2VTdHIocyk7XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5vdmVycmlkZU1pbk1heExpbWl0cykge1xuICAgICAgICAgICAgY2FzZSAnZmxvb3InOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZWlsaW5nJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhhbmtzIHRvIEFudGhvbnkgJiBFdmFuIENcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudHxzdHJpbmd9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl8SFRNTEVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIChhbmQgdGhlcmVmb3JlIGlzIGEgQ1NTIHNlbGVjdG9yKSwgdGhlbiB3ZSBuZWVkIHRvIG1vZGlmeSB0aGlzIHN0cmluZyBpbiBvcmRlclxuICAgICAgICAgKiBmb3IgalF1ZXJ5IHRvIGJlIGFibGUgdG8gcGFyc2UgdGhlIHNlbGVjdG9yIGNvcnJlY3RseS5cbiAgICAgICAgICogY2YuIGh0dHA6Ly9sZWFybi5qcXVlcnkuY29tL3VzaW5nLWpxdWVyeS1jb3JlL2ZhcS9ob3ctZG8taS1zZWxlY3QtYW4tZWxlbWVudC1ieS1hbi1pZC10aGF0LWhhcy1jaGFyYWN0ZXJzLXVzZWQtaW4tY3NzLW5vdGF0aW9uL1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzU3RyaW5nKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvL1RPRE8gVGhpcyBibG9jayBpcyBhcHBhcmVudGx5IG5ldmVyIGVudGVyZWQuIFdlIHNob3VsZCByZW1vdmUgaXQgYWZ0ZXIgbWFraW5nIHN1cmUgdGhhdCdzIDEwMCUgdGhlIGNhc2VcbiAgICAgICAgICAgIGVsZW1lbnQgPSBgIyR7ZWxlbWVudC5yZXBsYWNlKC8oOnxcXC58XFxbfF18LHw9KS9nLCAnXFxcXCQxJyl9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRoYXQgYXR0YWNoIHRoZSBhdXRvTnVtZXJpYyBmaWVsZCBwcm9wZXJ0aWVzIHRvIHRoZSBET00gZWxlbWVudCB2aWEgYW4gQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXBkYXRlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBob2xkZXIgPSBkYXRhLmhvbGRlcjtcbiAgICAgICAgaWYgKHVwZGF0ZSB8fCAoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykpIHtcbiAgICAgICAgICAgIGhvbGRlciA9IG5ldyBBdXRvTnVtZXJpY0hvbGRlcigkdGhpcy5nZXQoMCksIHNldHRpbmdzKTtcbiAgICAgICAgICAgIGRhdGEuaG9sZGVyID0gaG9sZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvbGRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAmIG5vU2VwYXJhdG9yT25Gb2N1cyBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxuICAgICAqIFRob3NlIG9yaWdpbmFsIHNldHRpbmdzIGFyZSB1c2VkIGV4Y2x1c2l2ZWx5IGluIHRoZSBgZm9jdXNpbmAgYW5kIGBmb2N1c291dGAgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncykge1xuICAgICAgICAvL1RPRE8gUmVuYW1lIHRoZSBvbGQgb3B0aW9uIG5hbWVzIHRvIHRoZSBuZXcgb25lc1xuICAgICAgICBzZXR0aW5ncy5vRGVjICAgICA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nO1xuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyO1xuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3I7XG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgIHNldHRpbmdzLm9TdWZmaXggID0gc2V0dGluZ3Muc3VmZml4VGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gYGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNgICYgYG5vU2VwYXJhdG9yT25Gb2N1c2Agb3B0aW9ucyBhcmUgYmVpbmcgdXNlZC5cbiAgICAgKiBUaGlzIGlzIHRha2VuIGZyb20gUXVpcmtzbW9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIGlzIHRha2VuIGZyb20gTW9kZXJuaXpyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmFnZVRlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gd2hhdCB0aGUgYnJvd3NlciBpcyBzdXBwb3J0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEV2ZW50VGFyZ2V0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZWxlbWVudCwgc2V0dGluZ3MsIGFjdGlvbikge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9IChlbGVtZW50Lm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZChlbGVtZW50Lm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoZWxlbWVudC5uYW1lKX1gIDpgQVVUT18ke2VsZW1lbnQuaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIFNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0ke3NldHRpbmdzLnJhd1ZhbHVlfTsgZXhwaXJlcz0gOyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyBOb3RlIDogYHRvR01UU3RyaW5nKClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgKGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvR01UU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXNzIEF1dG9OdW1lcmljSG9sZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGN1cnJlbnQgdmFsdWUsIGtleSBzdGF0ZXMgKEN0cmwsIFNoaWZ0IGFuZCBDb21tYW5kIGtleXMpLCBzZWxlY3Rpb24gYW5kIHNvbWUgb3RoZXIga2V5Y29kZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF91cGRhdGVGaWVsZFByb3BlcnRpZXMoZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY3RybEtleSA9IGUuY3RybEtleTtcbiAgICAgICAgICAgIHRoaXMuY21kS2V5ID0gZS5tZXRhS2V5O1xuICAgICAgICAgICAgdGhpcy5zaGlmdEtleSA9IGUuc2hpZnRLZXk7XG5cbiAgICAgICAgICAgIC8vIEtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gZ2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQpO1xuICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgICAgICAgICAgIHRoaXMua2RDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy53aGljaCA9IGUud2hpY2g7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0IHNlbGVjdGlvbiBpbnNpZGUgdGhlIGlucHV0IHdpdGggdGhlIGdpdmVuIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZW5kXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCwgc2V0UmVhbCkge1xuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7IC8vVE9ETyBSZXBsYWNlIGB0aGlzLnRoYXQudmFsdWUubGVuZ3RoYCB3aXRoIGB0aGlzLnZhbHVlLmxlbmd0aGBcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYXJldCBwb3NpdGlvbiBpbnNpZGUgdGhlIGlucHV0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0Q2FyZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuKVxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICogVGhvc2UgcGFydHMgYXJlIGxlZnQgJ3VudG91Y2hlZCcsIGllLiBmb3JtYXR0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgLy9GSVhNRSBgdGhpcy5zZWxlY3Rpb25gIGNhbiBzb21ldGltZXMgYmUgdW5kZWZpbmVkLCBmb3VuZCB3aHkgYW5kIGZpeCBpdFxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgdW5mb3JtYXR0ZWQgKHN0cmlwcGVkKSBvZiBhbnkgbm9uLW51bWJlcnMgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbiwgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBpZiBjaGFuZ2luZyB0aGUgc2lnbiBhbmQgbGVmdCBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIHplcm8gLSBwcmV2ZW50cyBzdHJpcHBpbmcgdGhlIGxlYWRpbmcgemVyb3NcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwWmVyb3MgPSAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgICAgICBsZWZ0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGxlZnQsIHRoaXMuc2V0dGluZ3NDbG9uZSwgc3RyaXBaZXJvcyk7XG5cbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxuICAgICAgICAgKiBAcmV0dXJucyB7WyosKl19XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG5cbiAgICAgICAgICAgIC8vIGlmIGNoYW5naW5nIHRoZSBzaWduIGFuZCBsZWZ0IGlzIGVxdWFsIHRvIHRoZSBudW1iZXIgemVybyAtIHByZXZlbnRzIHN0cmlwcGluZyB0aGUgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgY29uc3Qgc3RyaXBaZXJvcyA9ICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5IeXBoZW4gJiYgTnVtYmVyKGxlZnQpID09PSAwKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgICAgIGxlZnQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgc2V0dGluZ3NDbG9uZSwgc3RyaXBaZXJvcyk7XG5cbiAgICAgICAgICAgIC8vIElmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICAgICAgICByaWdodCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55JyAmJiB0aGlzLmtkQ29kZSA9PT0gNDggJiYgTnVtYmVyKGxlZnQpID09PSAwICYmICFjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpICAmJiByaWdodCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbnNlcnQgemVybyBpZiBoYXMgbGVhZGluZyBkb3RcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBsZWZ0ICsgcmlnaHQ7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMubmV3VmFsdWUubWF0Y2gobmV3IFJlZ0V4cChgXiR7c2V0dGluZ3NDbG9uZS5hTmVnUmVnQXV0b1N0cmlwfVxcXFwke3NldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcn1gKSk7XG4gICAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZShtWzFdLCBtWzFdICsgJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSB3aGlsZSBrZWVwaW5nIHRoZSBjdXJzb3IgcG9zaXRpb24uIC8vVE9ETyBXaGF0IGFib3V0IHRoZSBjdXJzb3Igc2VsZWN0aW9uP1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1Bhc3RlXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQsIGlzUGFzdGUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy5fbm9ybWFsaXplUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgY29uc3QgW21pblRlc3QsIG1heFRlc3RdID0gY2hlY2tJZkluUmFuZ2VXaXRoT3ZlcnJpZGVPcHRpb24odGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSBwYXJ0c1swXS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gcGFydHMuam9pbignJyk7XG5cbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gdHJ1bmNhdGVEZWNpbWFsKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUsIGlzUGFzdGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RWYWx1ZSA9IChjb250YWlucyh0aGlzLm5ld1ZhbHVlLCAnLCcpKSA/IHRoaXMubmV3VmFsdWUucmVwbGFjZSgnLCcsICcuJykgOiB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0VmFsdWUgPT09ICcnIHx8IHRlc3RWYWx1ZSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSB0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5uZXdWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSB0aGlzLm5ld1ZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2hlbiB0aGUgdXNlciBlbnRlciBhICcwJyBvbiB0aGUgZmFyIGxlZnQgd2l0aCBhIGxlYWRpbmcgemVybyBvcHRpb24gc2V0IHRvICdkZW55JywgdGhhdCB0aGUgY2FyZXQgZG9lcyBub3QgbW92ZXMgc2luY2UgdGhlIGlucHV0IGlzIGRyb3BwZWQgKGZpeCBpc3N1ZSAjMjgzKVxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMSAmJiBwYXJ0c1swXSA9PT0gJzAnICYmIHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdXNlciBlbnRlciBgMGAsIHRoZW4gdGhlIGNhcmV0IGlzIHB1dCBvbiB0aGUgcmlnaHQgc2lkZSBvZiBpdCAoRml4IGlzc3VlICMyOTkpXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0c1sxXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldENhcmV0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kdGhhdC50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBgX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp9IFNpZ24gcG9zaXRpb24gb2YgYSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRTaWduUG9zaXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2wgPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sO1xuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbmN5U3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xMZW4gPSBjdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNOZWcgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiB0aGF0LnZhbHVlICYmIHRoYXQudmFsdWUuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05lZyA/IFsxLCBjdXJyZW5jeVN5bWJvbExlbiArIDFdIDogWzAsIGN1cnJlbmN5U3ltYm9sTGVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlTGVuIC0gY3VycmVuY3lTeW1ib2xMZW4sIHZhbHVlTGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFsxMDAwLCAtMV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXhwYW5kcyBzZWxlY3Rpb24gdG8gY292ZXIgd2hvbGUgc2lnblxuICAgICAgICAgKiBQcmV2ZW50cyBwYXJ0aWFsIGRlbGV0aW9uL2NvcHlpbmcvb3ZlcndyaXRpbmcgb2YgYSBzaWduXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9leHBhbmRTZWxlY3Rpb25PblNpZ24oc2V0UmVhbCkge1xuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4gb25seSlcbiAgICAgICAgICAgIC8vVE9ETyBVc2UgYXJyYXkgZGVzdHJ1Y3R1cmluZyBoZXJlIHRvIHNldCBzaWduUG9zaXRpb24gdG8gbW9yZSBleHBsaWNpdCB2YXJpYWJsZXNcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuX2dldFNpZ25Qb3NpdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdGlvbiBjYXRjaGVzIHNvbWV0aGluZyBleGNlcHQgc2lnbiBhbmQgY2F0Y2hlcyBvbmx5IHNwYWNlIGZyb20gc2lnblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblsxXSAmJiBzZWxlY3Rpb24uZW5kID4gc2lnblBvc2l0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlbiBzZWxlY3Qgd2l0aG91dCBlbXB0eSBzcGFjZVxuICAgICAgICAgICAgICAgIGlmICgoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzBdIHx8IHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMV0pICYmIHRoaXMudmFsdWUuc3Vic3RyaW5nKE1hdGgubWF4KHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdKSwgTWF0aC5taW4oc2VsZWN0aW9uLmVuZCwgc2lnblBvc2l0aW9uWzFdKSkubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSwgc2V0UmVhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oc2lnblBvc2l0aW9uWzFdLCBzZWxlY3Rpb24uZW5kLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2Ugc2VsZWN0IHdpdGggd2hvbGUgc2lnblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTZWxlY3Rpb24oTWF0aC5taW4oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1heChzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcbiAgICAgICAgICovXG4gICAgICAgIF9jaGVja1Bhc3RlKCkge1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbGRQYXJ0cyA9IHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIGZpcnN0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NldFZhbHVlUGFydHMobW9kaWZpZWRMZWZ0UGFydCwgcmlnaHQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvbGRQYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihvbGRQYXJ0c1swXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5cy5cbiAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFRSVUUsIHRoZW4gZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2tpcEFsd2F5cyhlKSB7XG4gICAgICAgICAgICAvLyBDYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGlmICgoKHRoaXMuY3RybEtleSB8fCB0aGlzLmNtZEtleSkgJiYgZS50eXBlID09PSAna2V5dXAnICYmICFpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHx8ICh0aGlzLnNoaWZ0S2V5ICYmIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkluc2VydCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBmdW5jdGlvbiBrZXlzIChGMS1GMTIpLCBXaW5kb3dzIGtleXMsIHRhYiBhbmQgb3RoZXIgc3BlY2lhbCBrZXlzXG4gICAgICAgICAgICBpZiAoKHRoaXMua2RDb2RlID49IGtleUNvZGUuRjEgJiYgdGhpcy5rZENvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMua2RDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiB0aGlzLmtkQ29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMua2RDb2RlID49IGtleUNvZGUuVGFiICYmIHRoaXMua2RDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5rZENvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLndoaWNoID09PSAwIHx8IHRoaXMud2hpY2ggPT09IHRoaXMua2RDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5OdW1Mb2NrIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgICAgIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYSBcIlNlbGVjdCBhbGxcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAoY3RybCArIGEpXG4gICAgICAgICAgICBpZiAoKHRoaXMuY3RybEtleSB8fCB0aGlzLmNtZEtleSkgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNlbGVjdE51bWJlck9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGlzIHVzZWQgaGVyZSB0byBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGZpcnN0IHNlbGVjdCBhbGwgdGhlIGlucHV0IHRleHQgKGluY2x1ZGluZyB0aGUgY3VycmVuY3kgc2lnbiksIG90aGVyd2lzZSB3ZSB3b3VsZCBzZWUgdGhhdCB3aG9sZSBzZWxlY3Rpb24gZmlyc3QgaW4gYSBmbGFzaCwgdGhlbiB0aGUgc2VsZWN0aW9uIHdpdGggb25seSB0aGUgbnVtYmVyIHBhcnQgd2l0aG91dCB0aGUgY3VycmVuY3kgc2lnbi5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoaXMudGhhdC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbmN5U3ltYm9sTGVuID0gdGhpcy5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ0xlbiA9ICghY29udGFpbnModGhpcy50aGF0LnZhbHVlLCAnLScpKT8wOjE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeFRleHRMZW4gPSB0aGlzLnNldHRpbmdzLnN1ZmZpeFRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gdGhpcy5zZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnICYmIG5lZ0xlbiA9PT0gMSAmJiBjdXJyZW5jeVN5bWJvbExlbiA+IDApP2N1cnJlbmN5U3ltYm9sTGVuICsgMTpjdXJyZW5jeVN5bWJvbExlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIHN1ZmZpeFRleHRMZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKHN1ZmZpeFRleHRMZW4gKyBjdXJyZW5jeVN5bWJvbExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoY3VycmVuY3lTeW1ib2xMZW4gPiAwKT92YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIG5lZ0xlbiArIHN1ZmZpeFRleHRMZW4pOnZhbHVlTGVuIC0gKGN1cnJlbmN5U3ltYm9sTGVuICsgc3VmZml4VGV4dExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIFwiQ29weVwiLCBcIlBhc3RlXCIgb3IgXCJDdXRcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAocmVzcGVjdGl2ZWx5ICdjdHJsICsgYycsICdjdHJsICsgdicgb3IgJ2N0cmwgKyB4JylcbiAgICAgICAgICAgIGlmICgodGhpcy5jdHJsS2V5IHx8IHRoaXMuY21kS2V5KSAmJiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuYyB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS52IHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLngpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V4cGFuZFNlbGVjdGlvbk9uU2lnbigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBwcmV2ZW50IHdyb25nIHBhc3RlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSBrZXlDb2RlLnYgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUGFzdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuY3RybEtleSB8fCB0aGlzLmNtZEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWdpdEdyb3VwU2VwYXJhdG9yID0gdGhpcy5zZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjaW1hbENoYXJhY3RlciA9IHRoaXMuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SnVtcCA9IHRoaXMuc2VsZWN0aW9uLnN0YXJ0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy50aGF0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyAmJiAhdGhpcy5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGRpZ2l0R3JvdXBTZXBhcmF0b3IgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBkZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5SaWdodEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wICsgMSkgPT09IGRpZ2l0R3JvdXBTZXBhcmF0b3IgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBkZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihzdGFydEp1bXAgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2RDb2RlID49IGtleUNvZGUuUGFnZURvd24gJiYgdGhpcy5rZENvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdGhlIG1pbnVzIHNpZ24gaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBudW1lcmljIGNoYXJhY3RlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0IFRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0IFRoZSBwYXJ0IG9uIHRoZSByaWdodCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbklmVHJhaWxpbmdOZWdhdGl2ZVNpZ24oW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgJiYgc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmxlbmd0aCAtIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSAmJiBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSArIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCAnLScpICYmIHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0KSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCkgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRbMF0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmIHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIC0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9jZXNzIHRoZSBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG5cbiAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgbGV0IHJpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgcmlnaHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgoKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICBjb250YWlucyh0aGlzLnZhbHVlLCAnLScpKSB7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZGVjaWRlcyBpZiB0aGUga2V5IHByZXNzZWQgc2hvdWxkIGJlIGRyb3BwZWQgb3IgYWNjZXB0ZWQsIGFuZCBtb2RpZnkgdGhlIHZhbHVlICdvbi10aGUtZmx5JyBhY2NvcmRpbmdseS5cbiAgICAgICAgICogUmV0dXJucyBUUlVFIGlmIHRoZSBrZXljb2RlIGlzIGFsbG93ZWQuXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb25zIGFsc28gbW9kaWZ5IHRoZSB2YWx1ZSBvbi10aGUtZmx5LiAvL0ZJWE1FIFRoaXMgc2hvdWxkIHVzZSBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNlcGFyYXRlIHRoZSB0ZXN0IGFuZCB0aGUgbW9kaWZpY2F0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgY0NvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMud2hpY2gpO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciB8fFxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAmJiBjQ29kZSA9PT0gc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpIHx8XG4gICAgICAgICAgICAgICAgKChjQ29kZSA9PT0gJy4nIHx8IGNDb2RlID09PSAnLCcpICYmIHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRvdE51bXBhZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUuZGVjaW1hbFBsYWNlc092ZXJyaWRlIHx8ICFzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBuZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmlnaHQuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlciwgcmlnaHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGlmICgoY0NvZGUgPT09ICctJyB8fCBjQ29kZSA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5nc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENhcmV0IGlzIGFsd2F5cyBhZnRlciBtaW51c1xuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG51bWJlciBzaWduLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSAnLScgfHwgY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSwgbGVmdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IChjQ29kZSA9PT0gJy0nKSA/IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoYW5nZSBudW1iZXIgc2lnbiwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRyeSB0byBpbnNlcnQgZGlnaXQgYmVmb3JlIG1pbnVzXG4gICAgICAgICAgICBpZiAoY0NvZGUgPj0gJzAnICYmIGNDb2RlIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5tYXhpbXVtVmFsdWUgPD0gMCAmJiBzZXR0aW5nc0Nsb25lLm1pbmltdW1WYWx1ZSA8IHNldHRpbmdzQ2xvbmUubWF4aW11bVZhbHVlICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgJiYgY0NvZGUgIT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCArIGNDb2RlLCByaWdodCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBhbnkgb3RoZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2hpbGUga2VlcGluZyB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9mb3JtYXRWYWx1ZShlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgbGVmdExlbmd0aCA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBldmVudEtleUNvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICBsZXQgW2xlZnRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIE5vIGdyb3VwaW5nIHNlcGFyYXRvciBhbmQgbm8gY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJyAgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvcikpKSAmJlxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgW3N1YlBhcnRzXSA9IGxlZnRMZW5ndGguc3BsaXQoc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMoc3ViUGFydHMsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgblNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIHN1YlBhcnRzID0gc3ViUGFydHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnRQb3MgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm8gb24gbmVnYXRpdmUgdmFsdWUgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50TmVnICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5TaWduICsgbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhZGRHcm91cFNlcGFyYXRvcnModGhpcy52YWx1ZSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgcmVnZXhwIHdoaWNoIHNlYXJjaGVzIGZvciBjdXJzb3IgcG9zaXRpb24gZnJvbSB1bmZvcm1hdHRlZCBsZWZ0IHBhcnRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QXIgPSBsZWZ0LnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIC8vIEZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyWzBdID09PSAnLScgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRBci5zaGlmdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSB8fCB0aGlzLmtkQ29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEtleUNvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1c2hpbmcgdGhlIGVzY2FwZWQgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBci5wdXNoKGVzY2FwZWRQYXJ0cy5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IGUudHlwZSA9PT0gJ2tleWRvd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBqdXN0IGJlZm9yZSB0aGUgc2lnbiB3aGljaCBpcyBpbiBwcmVmaXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgocG9zaXRpb24gPT09IDAgJiYgdmFsdWUuY2hhckF0KDApICE9PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYWZ0ZXIgcHJlZml4IHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJyA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc2lnbiBhcyBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeCBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2UgY2FyZXQgYmVmb3JlIHN1ZmZpeFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgdGhlIHZhbHVlIGlmIGl0IGhhcyBjaGFuZ2VkLiBUaGlzIHByZXZlbnRzIG1vZGlmeWluZyB0aGUgc2VsZWN0aW9uLCBpZiBhbnkuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudGhhdC52YWx1ZSB8fCB2YWx1ZSA9PT0gdGhpcy50aGF0LnZhbHVlICYmIGV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW0wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTsgLy9UT0RPIFJlbmFtZSBgdGhpcy5mb3JtYXR0ZWRgIHRvIGB0aGlzLl9mb3JtYXRFeGVjdXRlZGAsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGZvcm1hdCBhbnl0aGluZyAoaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGtleWNvZGUgaXMgZHJvcHBlZCBmb3IgaW5zdGFuY2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhhdCk7XG4gICAgICAgIGNvbnN0IGZvcm1JbmRleCA9ICQoJ2Zvcm0nKS5pbmRleCgkdGhpcyk7XG4gICAgICAgIGNvbnN0IGFsbEZvcm1FbGVtZW50cyA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KWApWzBdO1xuICAgICAgICBjb25zdCBhaUluZGV4ID0gW107XG5cbiAgICAgICAgLy8gYWxsIGlucHV0IGluZGV4XG4gICAgICAgIGNvbnN0IHNjSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBzdWNjZXNzZnVsIGNvbnRyb2wgaW5kZXhcbiAgICAgICAgY29uc3QgclN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgclN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgckNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcbiAgICAgICAgY29uc3Qgck5vbkF1dG9OdW1lcmljVHlwZXMgPSAvXig/OmJ1dHRvbnxjaGVja2JveHxjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGZpbGV8aW1hZ2V8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhZGlvfHJhbmdlfHJlc2V0fHNlYXJjaHxzdWJtaXR8dGltZXx1cmx8d2VlaykvaTtcblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIHN1Y2Nlc3NmdWwgZWxlbWVudHNcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSAhPT0gJycgJiYgclN1Ym1pdHRhYmxlLnRlc3QoZmllbGQubG9jYWxOYW1lKSAmJiAhclN1Ym1pdHRlclR5cGVzLnRlc3QoZmllbGQudHlwZSkgJiYgIWZpZWxkLmRpc2FibGVkICYmIChmaWVsZC5jaGVja2VkIHx8ICFyQ2hlY2thYmxlVHlwZS50ZXN0KGZpZWxkLnR5cGUpKSkge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW5kZXggb2YgYWxsIGlucHV0cyB0YWdzIGV4Y2VwdCBjaGVja2JveFxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiAoZmllbGQudHlwZSA9PT0gJycgfHwgZmllbGQudHlwZSA9PT0gJ3RleHQnIHx8IGZpZWxkLnR5cGUgPT09ICdoaWRkZW4nIHx8IGZpZWxkLnR5cGUgPT09ICd0ZWwnKSkge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIHJOb25BdXRvTnVtZXJpY1R5cGVzLnRlc3QoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChnZXRBcnJheUJlaGF2aW9yKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1GaWVsZHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcblxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVBhcnRzW2ldID0gYCR7aW5wdXROYW1lfT0ke21vZGlmaWVkSW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtUGFydHMuam9pbignJicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3VzaW4nIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vVE9ETyBGaXggaXNzdWUgIzMwMyA6IGlmIChlLnR5cGUgPT09ICdmb2N1c2luJyAmJiBubyBtb3VzZSBjbGljayAmJiBmcm9tVGFiS2V5KSB7IHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDApOyB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCAmJiBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChlLnRhcmdldC52YWx1ZSwgc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSAnJztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnN1ZmZpeFRleHQgPSAnJztcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0Jywgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgocmVzdWx0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncywgdHJ1ZSkpICE9PSBzZXR0aW5ncy5yYXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJbiBvcmRlciB0byBzZW5kIGEgJ25hdGl2ZScgY2hhbmdlIGV2ZW50IHdoZW4gYmx1cnJpbmcgdGhlIGlucHV0LCB3ZSBuZWVkIHRvIGZpcnN0IHN0b3JlIHRoZSBpbml0aWFsIGlucHV0IHZhbHVlIG9uIGZvY3VzLlxuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBob2xkZXIudmFsdWVPbkZvY3VzO1xuICAgICAgICAgICAgY29uc3Qgb25FbXB0eSA9IGNoZWNrRW1wdHkoaG9sZGVyLnZhbHVlT25Gb2N1cywgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgaWYgKChvbkVtcHR5ICE9PSBudWxsICYmIG9uRW1wdHkgIT09ICcnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwob25FbXB0eSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRW1wdHkgPT09IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICYmIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2tleWRvd24nIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBqdXN0IHN0YXJ0ZWQgcHVzaGluZyBhbnkga2V5LCBoZW5jZSBvbmUgZXZlbnQgaXMgc2VudC5cbiAgICAgKlxuICAgICAqIE5vdGUgOlxuICAgICAqIEJ5IGRlZmF1bHQgYSAnbm9ybWFsJyBpbnB1dCBvdXRwdXQgdGhvc2UgZXZlbnRzIGluIHRoZSByaWdodCBvcmRlciB3aGVuIGlucHV0dGluZyBhIGNoYXJhY3RlciBrZXkgKGllLiAnYScpIDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXByZXNzXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIC4uLndoZW4gaW5wdXR0aW5nIGEgbW9kaWZpZXIga2V5IChpZS4gJ2N0cmwnKSA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogSWYgJ2RlbGV0ZScgb3IgJ2JhY2tzcGFjZScgaXMgZW50ZXJlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBJZiAnZW50ZXInIGlzIGVudGVyZWQgYW5kIHRoZSB2YWx1ZSBoYXMgbm90IGNoYW5nZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXByZXNzXG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogSWYgJ2VudGVyJyBpcyBlbnRlcmVkIGFuZCB0aGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5cHJlc3NcbiAgICAgKiAtIGNoYW5nZVxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIFdoZW4gYSBwYXN0ZSBpcyBkb25lLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBpbnB1dCAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIHRoZSBtb3VzZSlcbiAgICAgKlxuICAgICAqIC0ga2V5ZG93biAoaWYgcGFzdGUgaXMgZG9uZSB3aXRoIGN0cmwrdilcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleWRvd24oaG9sZGVyLCBlKSB7XG4gICAgICAgIC8vVE9ETyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHJpZXZlIHRoZSBlbGVtZW50IHZhbHVlIChlaXRoZXIgYnkgdXNpbmcgYGUudGFyZ2V0LnZhbHVlYCB3aGVuIHRoZSBlbGVtZW50IGlzIGFuIDxpbnB1dD4sIG9yIGJ5IHVzaW5nIGBlbGVtZW50LnRleHRDb250ZW50YCB3aGVuIHRoZSBlbGVtZW50IGFzIGl0cyBgY29udGVudGVkaXRhYmxlYCBzZXQgdG8gdHJ1ZSlcbiAgICAgICAgY29uc3QgY3VycmVudEtleUNvZGUgPSBrZXkoZSk7IC8vIFRoZSBrZXkgYmVpbmcgdXNlZFxuXG4gICAgICAgIGlmIChob2xkZXIudGhhdC5yZWFkT25seSkge1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBcImVudGVyXCIga2V5IHRocm93cyBhIGBjaGFuZ2VgIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgYGZvY3VzYCBldmVudFxuICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci52YWx1ZU9uRm9jdXMgIT09IGUudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2NoYW5nZScsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGhvbGRlci52YWx1ZU9uRm9jdXMgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvbGRlci5fdXBkYXRlRmllbGRQcm9wZXJ0aWVzKGUpOyAvL0ZJWE1FIFRoaXMgaXMgY2FsbGVkIDIgdG8gMyB0aW1lc1xuICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaG9sZGVyLl9za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGtleSBpcyBhIGRlbGV0ZS9iYWNrc3BhY2Uga2V5XG4gICAgICAgIGlmIChjdXJyZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgY3VycmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlKSB7XG4gICAgICAgICAgICBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJEZWxldGlvbigpOyAvLyBCZWNhdXNlIGJhY2tzcGFjZSBhbmQgZGVsZXRlIG9ubHkgdHJpZ2dlcnMga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzLCBub3Qga2V5cHJlc3NcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcblxuICAgICAgICAgICAgLy8gSWYgYW5kIG9ubHkgaWYgdGhlIHJlc3VsdGluZyB2YWx1ZSBoYXMgY2hhbmdlZCBhZnRlciB0aGF0IGJhY2tzcGFjZS9kZWxldGUsIHRoZW4gd2UgaGF2ZSB0byBzZW5kIGFuICdpbnB1dCcgZXZlbnQgbGlrZSBicm93c2VycyBub3JtYWxseSBkby5cbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYW4gaW5wdXQgZXZlbnQgd2hlbiBhIGNoYXJhY3RlciBkZWxldGlvbiBpcyBkZXRlY3RlZFxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBkZWxldGUgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlOyAvL1RPRE8gSXMgdGhpcyBsaW5lIG5lZWRlZD9cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5cHJlc3MnIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBpcyBzdGlsbCBwcmVzc2luZyB0aGUga2V5LCB3aGljaCB3aWxsIG91dHB1dCBhIGNoYXJhY3RlciAoaWUuICcyJykgY29udGludW91c2x5IHVudGlsIGl0IHJlbGVhc2VzIHRoZSBrZXkuXG4gICAgICogTm90ZTogJ2tleXByZXNzJyBldmVudHMgYXJlIG5vdCBzZW50IGZvciBkZWxldGUga2V5cyBsaWtlIEJhY2tzcGFjZS9EZWxldGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlwcmVzcyhob2xkZXIsIGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEtleUNvZGUgPSBrZXkoZSk7IC8vIFRoZSBrZXkgYmVpbmcgdXNlZFxuXG4gICAgICAgIC8vIEZpcmVmb3ggZml4IGZvciBTaGlmdCAmJiBpbnNlcnQgcGFzdGUgZXZlbnRcbiAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgY3VycmVudEtleUNvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xuICAgICAgICBob2xkZXIuX3VwZGF0ZUZpZWxkUHJvcGVydGllcyhlKTsgLy9GSVhNRSBUaGlzIGlzIGNhbGxlZCAyIHRvIDMgdGltZXNcbiAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGhvbGRlci5fc2tpcEFsd2F5cyhlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQgPSBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oKTtcbiAgICAgICAgaWYgKGlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgICAgICAgIGlmICgoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci5sYXN0VmFsKSAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGlucHV0IGV2ZW50IG9uIGFkZGluZyBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnaW5wdXQnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBhZGQgYSBzZWNvbmQgY2hhcmFjdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCB3ZSBkbyBub3QgYWxsb3cgdGhlIGlucHV0IGV2ZW50IHRvIGJlIHNlbnRcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gZS50YXJnZXQudmFsdWU7XG4gICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGhvbGRlci5mb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAna2V5dXAnIGV2ZW50cy5cbiAgICAgKiBUaGUgdXNlciBqdXN0IHJlbGVhc2VkIGFueSBrZXksIGhlbmNlIG9uZSBldmVudCBpcyBzZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uS2V5dXAoaG9sZGVyLCBzZXR0aW5ncywgZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50S2V5Q29kZSA9IGtleShlKTsgLy8gVGhlIGtleSBiZWluZyB1c2VkXG5cbiAgICAgICAgaG9sZGVyLl91cGRhdGVGaWVsZFByb3BlcnRpZXMoZSk7IC8vRklYTUUgVGhpcyBpcyBjYWxsZWQgMiB0byAzIHRpbWVzXG4gICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuX3NraXBBbHdheXMoZSk7XG4gICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICBpZiAoc2tpcCB8fCBlLnRhcmdldC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZGVkIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBjYXJldCB3aGVuIG9ubHkgdGhlIGN1cnJlbmN5IHNpZ24gaXMgcHJlc2VudFxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudEtleUNvZGUgPT09IGtleUNvZGUuVGFiKSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSA9PT0gaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCkgfHxcbiAgICAgICAgICAgIChob2xkZXIuc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9PT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgIT09ICcnICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKSkge1xuICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZS50YXJnZXQsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhvbGRlci5mb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnZm9jdXNvdXQnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmICghJHRoaXMuaXMoJzpmb2N1cycpKSB7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5vU2VwYXJhdG9yT25Gb2N1cyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IgPSBzZXR0aW5ncy5vU2VwO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9IHNldHRpbmdzLm9TdWZmaXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Mub0RlYztcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hbGxvd0RlY2ltYWxQYWRkaW5nID0gc2V0dGluZ3Mub1BhZDtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciA9IHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSkgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA/ICtzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMgOiBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUoJzAnLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBncm91cGVkVmFsdWUgPSBjaGVja0VtcHR5KHZhbHVlLCBzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGdyb3VwZWRWYWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBvcmlnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSAoc2V0dGluZ3Muc2NhbGVTeW1ib2wpID8gZ3JvdXBlZFZhbHVlICsgc2V0dGluZ3Muc2NhbGVTeW1ib2wgOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdwYXN0ZScgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uUGFzdGUoJHRoaXMsIGhvbGRlciwgZSkge1xuICAgICAgICAvL1RPRE8gVXNpbmcgY3RybCt6IGFmdGVyIGEgcGFzdGUgc2hvdWxkIGNhbmNlbCBpdCAtPiBIb3cgd291bGQgdGhhdCBhZmZlY3Qgb3RoZXIgZnJhbWV3b3Jrcy9jb21wb25lbnQgYnVpbHQgd2l0aCB0aGF0IGZlYXR1cmUgaW4gbWluZCB0aG91Z2g/XG4gICAgICAgIC8vRklYTUUgV2hlbiBwYXN0aW5nICcwMDAnIG9uIGEgdGhvdXNhbmQgZ3JvdXAgc2VsZWN0aW9uLCB0aGUgd2hvbGUgc2VsZWN0aW9uIGdldHMgZGVsZXRlZCwgYW5kIG9ubHkgb25lICcwJyBpcyBwYXN0ZWQgKGNmLiBpc3N1ZSAjMzAyKVxuICAgICAgICAvLyBUaGUgZXZlbnQgaXMgcHJldmVudGVkIGJ5IGRlZmF1bHQsIHNpbmNlIG90aGVyd2lzZSB0aGUgdXNlciB3b3VsZCBiZSBhYmxlIHRvIHBhc3RlIGludmFsaWQgY2hhcmFjdGVycyBpbnRvIHRoZSBpbnB1dFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IHJhd1Bhc3RlZFRleHQgPSBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXG4gICAgICAgIC8vIDAuIFNwZWNpYWwgY2FzZSBpZiB0aGUgdXNlciBoYXMgc2VsZWN0ZWQgYWxsIHRoZSBpbnB1dCB0ZXh0IGJlZm9yZSBwYXN0aW5nXG4gICAgICAgIGNvbnN0IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydCA9IGUudGFyZ2V0LnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkVuZCA9IGUudGFyZ2V0LnNlbGVjdGlvbkVuZCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25TaXplID0gc2VsZWN0aW9uRW5kIC0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIGxldCBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvblNpemUgPT09IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMS4gQ2hlY2sgaWYgdGhlIHBhc3RlIGhhcyBhIG5lZ2F0aXZlIHNpZ24gKG9ubHkgaWYgaXQncyB0aGUgZmlyc3QgY2hhcmFjdGVyKSwgYW5kIHN0b3JlIHRoYXQgaW5mb3JtYXRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICBjb25zdCBpc1Bhc3RlTmVnYXRpdmUgPSBpc05lZ2F0aXZlKHJhd1Bhc3RlZFRleHQpO1xuICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAvLyAxYS4gUmVtb3ZlIHRoZSBuZWdhdGl2ZSBzaWduIGZyb20gdGhlIHBhc3RlZCB0ZXh0XG4gICAgICAgICAgICByYXdQYXN0ZWRUZXh0ID0gcmF3UGFzdGVkVGV4dC5zbGljZSgxLCByYXdQYXN0ZWRUZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmF3UGFzdGVkVGV4dFNpemUgPSByYXdQYXN0ZWRUZXh0Lmxlbmd0aDsgLy8gVGhpcyB1c2UgdGhlICdjbGVhbmVkJyBwYXN0ZSB0ZXh0XG5cbiAgICAgICAgLy8gMi4gU3RyaXAgYWxsIHRob3VzYW5kIHNlcGFyYXRvcnMsIGJyYWNrZXRzIGFuZCBjdXJyZW5jeSBzaWduLCBhbmQgY29udmVydCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gYSBkb3RcbiAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KHJhd1Bhc3RlZFRleHQsIGhvbGRlcik7XG5cbiAgICAgICAgLy8gMy4gVGVzdCBpZiB0aGUgcGFzdGUgaXMgdmFsaWQgKG9ubHkgaGFzIG51bWJlcnMgYW5kIGV2ZW50dWFsbHkgYSBkZWNpbWFsIGNoYXJhY3RlcikuIElmIGl0J3Mgbm90IHZhbGlkLCBzdG9wIGhlcmUuXG4gICAgICAgIGlmICghaXNOdW1iZXIocGFzdGVkVGV4dCkgfHwgcGFzdGVkVGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChob2xkZXIuc2V0dGluZ3Mub25JbnZhbGlkUGFzdGUgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgaXMgbm90IGEgdmFsaWQgcGFzdGUgY29udGVudC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNC4gQ2FsY3VsYXRlIHRoZSBwYXN0ZSByZXN1bHRcbiAgICAgICAgbGV0IGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nO1xuICAgICAgICBsZXQgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICBsZXQgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUoaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyKTtcbiAgICAgICAgbGV0IGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmU7XG4gICAgICAgIGxldCByZXN1bHQ7XG5cbiAgICAgICAgLy8gSWYgdGhlIHBhc3RlZCBjb250ZW50IGlzIG5lZ2F0aXZlLCB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBuZWdhdGl2ZSB0b29cbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSAmJiAhaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gYC0ke2luaXRpYWxVbmZvcm1hdHRlZE51bWJlcn1gO1xuICAgICAgICAgICAgaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAvKiA0YS4gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJbnNlcnQgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNhcmV0IGZyb20gdGhlIHBhc3RlZCB0ZXh0IGNvbnRlbnQsIHVudGlsIHRoZSBpbnB1dCByZWFjaCBpdHMgcmFuZ2UgbGltaXQuXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIGNsaXBib2FyZCBvbmNlIGEgbGltaXQgaXMgcmVhY2hlZCwgZHJvcCB0aGUgZXh0cmFuZW91cyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHBhc3RlIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgY2xpcGJvYXJkLlxuICAgICAgICAgICAgICogV2hpbGUgZG9pbmcgc28sIHdlIGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBhbGxvd2VkLCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIGVuY291bnRlciBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogNGIuIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJZGVtIHRoYW4gdGhlICd0cnVuY2F0ZScgcGFzdGUgYmVoYXZpb3IsIGV4Y2VwdCB0aGF0IHdoZW4gYSByYW5nZSBsaW1pdCBpcyBoaXQsIHdlIHRyeSB0byByZXBsYWNlIHRoZSBzdWJzZXF1ZW50IGluaXRpYWwgbnVtYmVycyB3aXRoIHRoZSBwYXN0ZWQgb25lcywgdW50aWwgd2UgaGl0IHRoZSByYW5nZSBsaW1pdCBhIHNlY29uZCAoYW5kIGxhc3QpIHRpbWUsIG9yIHdlIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY2FzZS1kZWNsYXJhdGlvbnM6IDAgKi9cbiAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQgKyByaWdodEZvcm1hdHRlZFBhcnQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRQYXJ0ID0gcmVzdWx0LnNsaWNlKDAsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodFBhcnQgPSByZXN1bHQuc2xpY2UoY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIC0tIEhlcmUsIHdlIGFyZSBnb29kIHRvIGdvIHRvIGNvbnRpbnVlIG9uIHRoZSBzYW1lIGJhc2lzXG5cbiAgICAgICAgICAgICAgICAvLyBjLiBBZGQgbnVtYmVycyBvbmUgYnkgb25lIGF0IHRoZSBjYXJldCBwb3NpdGlvbiwgd2hpbGUgdGVzdGluZyBpZiB0aGUgcmVzdWx0IGlzIHZhbGlkIGFuZCB3aXRoaW4gdGhlIHJhbmdlIG9mIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gICAgQ29udGludWUgdW50aWwgeW91IGVpdGhlciBydW4gb3V0IG9mIG51bWJlcnMgdG8gcGFzdGUsIG9yIHRoYXQgeW91IGdldCBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pblBhcnNlID0gcGFyc2VTdHIoaG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihob2xkZXIuc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDsgLy8gVGhpcyBpcyBzZXQgYXMgdGhlIGRlZmF1bHQsIGluIGNhc2Ugd2UgZG8gbm90IGFkZCBldmVuIG9uZSBudW1iZXJcbiAgICAgICAgICAgICAgICBsZXQgcGFzdGVkVGV4dEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgcmVzdWx0IHdpdGggYW5vdGhlciBwYXN0ZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVmdFBhcnQgKz0gcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtb2RpZmllZExlZnRQYXJ0ICsgcmlnaHRQYXJ0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsYXN0IGNhcmV0IHBvc2l0aW9uIHdoZXJlIHRvIGluc2VydCBhIG5ldyBudW1iZXJcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyArPSBwYXN0ZWRUZXh0SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvL1hYWCBIZXJlIHdlIGhhdmUgdGhlIHJlc3VsdCBmb3IgdGhlIGB0cnVuY2F0ZWAgb3B0aW9uXG4gICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ3RydW5jYXRlJykge1xuICAgICAgICAgICAgICAgICAgICAvL1RPRE8gSWYgdGhlIHVzZXIgYXMgZGVmaW5lZCBhIHRydW5jYXRlIGNhbGxiYWNrIGFuZCB0aGVyZSBhcmUgc3RpbGwgc29tZSBudW1iZXJzICh0aGF0IHdpbGwgYmUgZHJvcHBlZCksIHRoZW4gY2FsbCB0aGlzIGNhbGxiYWNrIHdpdGggdGhlIGluaXRpYWwgcGFzdGUgYXMgd2VsbCBhcyB0aGUgcmVtYWluaW5nIG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vWFhYIC4uLmVsc2Ugd2UgbmVlZCB0byBjb250aW51ZSBtb2RpZnlpbmcgdGhlIHJlc3VsdCBmb3IgdGhlICdyZXBsYWNlJyBvcHRpb25cblxuICAgICAgICAgICAgICAgIC8vIGQuIFVudGlsIHRoZXJlIGFyZSBudW1iZXJzIHRvIHBhc3RlLCByZXBsYWNlIHRoZSBpbml0aWFsIG51bWJlcnMgb25lIGJ5IG9uZSwgYW5kIHN0aWxsIGRvIHRoZSByYW5nZSB0ZXN0LlxuICAgICAgICAgICAgICAgIC8vICAgIFN0b3Agd2hlbiB5b3UgaGF2ZSBubyBtb3JlIG51bWJlcnMgdG8gcGFzdGUsIG9yIGlmIHlvdSBhcmUgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMuXG4gICAgICAgICAgICAgICAgLy8gICAgSWYgeW91IGRvIGdldCB0byB0aGUgcmFuZ2UgbGltaXRzLCB1c2UgdGhlIHByZXZpb3VzIGtub3duIGdvb2QgdmFsdWUgd2l0aGluIHRob3NlIGxpbWl0cy5cbiAgICAgICAgICAgICAgICAvLyAgICBOb3RlOiBUaGUgbnVtYmVycyBhcmUgcmVwbGFjZWQgb25lIGJ5IG9uZSwgaW4gdGhlIGludGVnZXIgdGhlbiBkZWNpbWFsIHBhcnQsIHdoaWxlIGlnbm9yaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIC8vVE9ETyBXaGF0IHNob3VsZCBoYXBwZW4gaWYgdGhlIHVzZXIgdHJ5IHRvIHBhc3RlIGEgZGVjaW1hbCBudW1iZXI/IFNob3VsZCB3ZSBvdmVycmlkZSB0aGUgY3VycmVudCBpbml0aWFsIGRlY2ltYWwgY2hhcmFjdGVyIGluIGZhdm9yIG9mIHRoaXMgbmV3IG9uZT8gSWYgd2UgZG8sIHRoZW4gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGUgdk1pbi92TWF4IGZyb20gdGhlIHN0YXJ0IGluIG9yZGVyIHRvIHRha2UgaW50byBhY2NvdW50IHRoaXMgbmV3IGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uLi5cbiAgICAgICAgICAgICAgICBsZXQgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4ID0gY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3Rpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEdvb2RLbm93blJlc3VsdFNpemUgPSBsYXN0R29vZEtub3duUmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChwYXN0ZWRUZXh0SW5kZXggPCBwYXN0ZWRUZXh0Lmxlbmd0aCAmJiBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEdvb2RLbm93blJlc3VsdFtsYXN0R29vZEtub3duUmVzdWx0SW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNraXAgdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdyZXBsYWNlbWVudCcuIFRoYXQgd2F5LCB3ZSBkbyBub3QgY2hhbmdlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBwb3NpdGlvbiByZWdhcmRpbmcgdGhlIHJlbWFpbmluZyBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVwbGFjZSBvbmUgY2hhcmFjdGVyIGF0IGEgdGltZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXBsYWNlQ2hhckF0KGxhc3RHb29kS25vd25SZXN1bHQsIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCwgcGFzdGVkVGV4dFtwYXN0ZWRUZXh0SW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcmFuZ2UgbGltaXRzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hlY2tJZkluUmFuZ2UocmVzdWx0LCBtaW5QYXJzZSwgbWF4UGFyc2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzLCBzdG9wIHRoZSBsb29wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSB0aGUgbGFzdCBnb29kIGtub3duIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbG9jYWwgdmFyaWFibGVzIGZvciB0aGUgbmV4dCBsb29wXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlZFRleHRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gbGFzdEdvb2RLbm93blJlc3VsdEluZGV4O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbGFzdEdvb2RLbm93blJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogNGMuIE5vcm1hbCBwYXN0ZSBiZWhhdmlvcjpcbiAgICAgICAgICAgICAqIEluc2VydCB0aGUgcGFzdGVkIG51bWJlciBpbnNpZGUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgdGV4dCwgYXQgdGhlIHJpZ2h0IGNhcmV0IHBvc2l0aW9uIG9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGlmIHRoZXJlIGlzIGEgc2VsZWN0aW9uIGluIHRoZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIHNlbGVjdGlvbiwgYW5kIHRoaXMgaXMgdGhlIGNhcmV0IHBvc2l0aW9uIDogSW5zZXJ0IHRoZSBwYXN0ZSBpbnRvIHRoZSBlbGVtZW50LnZhbHVlIGF0IHRoYXQgY2FyZXQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGV4V2hlcmVUb0luc2VydFRoZVBhc3RlZFRleHQgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleFdoZXJlVG9JbnNlcnRUaGVQYXN0ZWRUZXh0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnNlcnRDaGFyQXRQb3NpdGlvbihpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIsIHBhc3RlZFRleHQsIGluZGV4V2hlcmVUb0luc2VydFRoZVBhc3RlZFRleHQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gaW5kZXhXaGVyZVRvSW5zZXJ0VGhlUGFzdGVkVGV4dCArIHJhd1Bhc3RlZFRleHRTaXplIC0gY291bnREb3RzSW5UZXh0KHJhd1Bhc3RlZFRleHQpOyAvLyBJIG11c3Qgbm90IGNvdW50IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgcGFzdGVkIHRleHQgKGllLiAnLicpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBzZWxlY3Rpb24gOiByZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgcGFzdGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBhcnQgPSBlLnRhcmdldC52YWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBlLnRhcmdldC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBmaXJzdFBhcnQgKyBwYXN0ZWRUZXh0ICsgbGFzdFBhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRmluYWxseSwgcmVtb3ZlIGFueSB1bndhbnRlZCBub24tbnVtYmVyIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0UGFydCAhPT0gJycgfHwgbGFzdFBhcnQgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgcHJpb3IgdG8gcGFzdGluZywgdGhlbiBmaXJzdFBhcnQgYW5kIGxhc3RQYXJ0IGFyZSBlbXB0eSwgaGVuY2Ugd2Ugb25seSB1c2UgdGhlIHBhc3RlZFRleHQgdmFyaWFibGUsIG90aGVyd2lzZSB3ZSByZW1vdmUgdGhlIHBvdGVudGlhbCBkZWNpbWFsIGNoYXJhY3RlciBpbiB0aGUgcmVzdWx0IHZhcmlhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChyZXN1bHQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNldFJhd05lZ2F0aXZlU2lnbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVuIGFsbCB0aGUgaW5wdXQgdGV4dCBpcyBzZWxlY3RlZCBiZWZvcmUgcGFzdGluZywgd2hpY2ggbWVhbnMgd2UnbGwgY29tcGxldGVseSBlcmFzZSBpdHMgY29udGVudCBhbmQgcGFzdGUgb25seSB0aGUgY2xpcGJvYXJkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvbkVuZCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcGFzdGVkIHZhbHVlIGhhcyBhICctJyBzaWduLCBidXQgdGhlIGluaXRpYWwgdmFsdWUgZG9lcyBub3QsIG9mZnNldCB0aGUgaW5kZXggYnkgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhTZWxlY3Rpb25FbmRJblJhd1ZhbHVlKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhlcmUgSSBtdXN0IG5vdCBjb3VudCB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHBhc3RlZCB0ZXh0IChpZS4gJy4nKSwgb3IgdGhlIHRob3VzYW5kIHNlcGFyYXRvcnMgaW4gdGhlIGluaXRpYWwgc2VsZWN0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZS50YXJnZXQudmFsdWUuc2xpY2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4U2VsZWN0aW9uRW5kSW5SYXdWYWx1ZSAtIHNlbGVjdGlvblNpemUgKyBjb3VudENoYXJJblRleHQoaG9sZGVyLnNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIHNlbGVjdGVkVGV4dCkgKyByYXdQYXN0ZWRUZXh0U2l6ZSAtIGNvdW50RG90c0luVGV4dChyYXdQYXN0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuIENoZWNrIGlmIHRoZSByZXN1bHQgaXMgYSB2YWxpZCBudW1iZXIsIGlmIG5vdCwgZHJvcCB0aGUgcGFzdGUgYW5kIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICghaXNOdW1iZXIocmVzdWx0KSB8fCByZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlZCB2YWx1ZSAnJHtyYXdQYXN0ZWRUZXh0fScgd291bGQgcmVzdWx0IGludG8gYW4gaW52YWxpZCBjb250ZW50ICcke3Jlc3VsdH0nLmApOyAvL1RPRE8gU2hvdWxkIHdlIHNlbmQgYSB3YXJuaW5nIGluc3RlYWQgb2YgdGhyb3dpbmcgYW4gZXJyb3I/XG4gICAgICAgICAgICAgICAgLy9UT0RPIFRoaXMgaXMgbm90IERSWSA7IHJlZmFjdG9yIHdpdGggYWJvdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIElmIGl0J3MgYSB2YWxpZCBudW1iZXIsIGNoZWNrIGlmIGl0IGZhbGxzIGluc2lkZSB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZS4gSWYgdGhpcyBmYWlscywgbW9kaWZ5IHRoZSB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBwcm9jZWR1cmUgOlxuICAgICAgICAvKlxuICAgICAgICAgKiBJZiAnZXJyb3InICh0aGlzIGlzIHRoZSBkZWZhdWx0KSA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCB0aGVuIHRocm93IGFuIGVycm9yIGluIHRoZSBjb25zb2xlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnaWdub3JlJyA6XG4gICAgICAgICAqICAgICAgLSBOb3JtYWwgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIGlmIGl0IGZhaWxzLCBkbyBub3RoaW5nIG1vcmUuXG4gICAgICAgICAqICAgICAgLSBEbyBub3QgY2hhbmdlIHRoZSBpbnB1dCB2YWx1ZSwgZG8gbm90IGNoYW5nZSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gICAgICAgICAqIElmICdjbGFtcCcgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgc2V0IHRoZSB2YWx1ZSB0byB0aGUgbWluaW11bSBvciBtYXhpbXVtIGxpbWl0LCB3aGljaGV2ZXIgaXMgY2xvc2VzdCB0byB0aGVcbiAgICAgICAgICogICAgICAgIHBhc3RlIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUgb2YgdGhlIGRlY2ltYWwgY2hhcmFjdGVyLlxuICAgICAgICAgKiBJZiAndHJ1bmNhdGUnIDpcbiAgICAgICAgICogICAgICAtIFRydW5jYXRlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAgLSBEcm9wIHRoZSByZW1haW5pbmcgbm9uLXBhc3RlZCBudW1iZXJzLCBhbmQga2VlcCB0aGUgbGFzdCBrbm93biBub24tZmFpbGluZyByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGxhc3QgcGFzdGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3JlcGxhY2UnIDpcbiAgICAgICAgICogICAgICAtIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3IuXG4gICAgICAgICAqICAgICAgLSBUcnkgdG8gc2V0IHRoZSBuZXcgdmFsdWUsIHVudGlsIGl0IGZhaWxzIChpZiB0aGUgcmVzdWx0IGlzIG91dCBvZiB0aGUgbWluIGFuZCBtYXggdmFsdWUgbGltaXRzKS5cbiAgICAgICAgICAqICAgICAtIFRoZW4gdHJ5IHRvIHJlcGxhY2UgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIHdpdGggdGhlIHBhc3RlZCBvbmVzLiBPbmNlIGl0IGZhaWxzLCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlblNldCA9IGZhbHNlO1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IGNsYW1wZWRWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBjbGFtcGVkVmFsdWUgPSBjbGFtcFRvUmFuZ2VMaW1pdHMocmVzdWx0LCBob2xkZXIuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGNsYW1wZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBGYXRhbCBlcnJvcjogVW5hYmxlIHRvIHNldCB0aGUgY2xhbXBlZCB2YWx1ZSAnJHtjbGFtcGVkVmFsdWV9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlbkNsYW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjbGFtcGVkVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHJlc3VsdHMgaW4gYSB2YWx1ZSAnJHtyZXN1bHR9JyB0aGF0IGlzIG91dHNpZGUgb2YgdGhlIG1pbmltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtIFske2hvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSB2YWx1ZSByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIC4uLmFuZCBub3RoaW5nIGVsc2Ugc2hvdWxkIGJlIGNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDcuIFRoZW4gbGFzdGx5LCBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGF0IHRoZSByaWdodCBsb2dpY2FsIHBsYWNlXG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXI7XG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNCZWVuQ2xhbXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoIC0gaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7IC8vIFRoaXMgcHV0cyB0aGUgY2FyZXQgb24gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTsgLy8gLi5hbmQgdGhpcyBvbiB0aGUgZmFyIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgaWYgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjbGFtcGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB1c2VkLi4uXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0cnVuY2F0ZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAncmVwbGFjZSc6XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW5ldmVyIG9uZSBvciBtdWx0aXBsZSBjaGFyYWN0ZXJzIGFyZSBwYXN0ZWQsIHRoaXMgbWVhbnMgd2UgaGF2ZSB0byBtYW5hZ2UgdGhlIHBvdGVudGlhbCB0aG91c2FuZCBzZXBhcmF0b3JzIHRoYXQgY291bGQgYmUgYWRkZWQgYnkgdGhlIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyID0gZmluZENhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcihyZXN1bHQsIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCBlLnRhcmdldC52YWx1ZSwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gOC4gV2UgbWFrZSBzdXJlIHdlIHNlbmQgYW4gaW5wdXQgZXZlbnQgb25seSBpZiB0aGUgcmVzdWx0IGlzIGRpZmZlcmVudCB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIGJlZm9yZSB0aGUgcGFzdGVcbiAgICAgICAgaWYgKHZhbHVlSGFzQmVlblNldCAmJiBpbml0aWFsRm9ybWF0dGVkVmFsdWUgIT09IGUudGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgICAvLyBPbiBhICdub3JtYWwnIG5vbi1hdXRvTnVtZXJpYyBpbnB1dCwgYW4gYGlucHV0YCBldmVudCBpcyBzZW50IHdoZW4gYSBwYXN0ZSBpcyBkb25lLiBXZSBtaW1pYyB0aGF0LlxuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZm9jdXNpbmcgb3V0IG9mIHRoZSBpbnB1dCwgd2UgY2hlY2sgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLCB0aGVuIHdlIHNlbmQgYSBgY2hhbmdlYCBldmVudCAoc2luY2UgdGhlIG5hdGl2ZSBvbmUgd291bGQgaGF2ZSBiZWVuIHByZXZlbnRlZCBieSBgZS5wcmV2ZW50RGVmYXVsdCgpYCBjYWxsZWQgaW4gdGhlIG90aGVyIGV2ZW50IGxpc3RlbmVycykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25CbHVyKGhvbGRlciwgZSkge1xuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgIT09IGhvbGRlci52YWx1ZU9uRm9jdXMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyAuLi5hbmQgaW1tZWRpYXRlbHkgcHJldmVudCB0aGUgYnJvd3NlciB0byBzZW5kIGEgc2Vjb25kIGNoYW5nZSBldmVudCAodGhhdCBzb21laG93IGdldHMgcGlja2VkIHVwIGJ5IGpRdWVyeSwgYnV0IG5vdCBieSBgYWRkRXZlbnRMaXN0ZW5lcigpYCAvL0ZJWE1FIEtOT1dOIEJVRyA6IFRoaXMgZG9lcyBub3QgcHJldmVudCB0aGUgc2Vjb25kIGNoYW5nZSBldmVudCB0byBiZSBwaWNrZWQgdXAgYnkgalF1ZXJ5XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy51bmZvcm1hdE9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBqUXVlcnkgc2VsZWN0ZWQgaW5wdXQgaWYgdGhlIHRhZyBhbmQgdHlwZSBhcmUgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcbiAgICAgICAgLy8gU3VwcG9ydGVkIGlucHV0IHR5cGVcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xuICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudFRhZyA9ICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRUYWcgIT09ICdpbnB1dCcgJiYgIWlzSW5BcnJheShjdXJyZW50RWxlbWVudFRhZywgYWxsb3dlZFRhZ0xpc3QpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRpbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3V0aW5lIHRvIGZvcm1hdCB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBwYWdlIGxvYWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkaW5wdXQgalF1ZXJ5LXNlbGVjdGVkIDxpbnB1dD4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKSB7XG4gICAgICAgIGxldCBzZXRWYWx1ZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSWYgdGhlIGlucHV0IHZhbHVlIGhhcyBiZWVuIHNldCBieSB0aGUgZGV2LCBidXQgbm90IGRpcmVjdGx5IGFzIGFuIGF0dHJpYnV0ZSBpbiB0aGUgaHRtbCwgdGhlbiBpdCB0YWtlc1xuICAgICAgICAgICAgICogcHJlY2VkZW5jZSBhbmQgc2hvdWxkIGdldCBmb3JtYXR0ZWQgb24gaW5pdCAoaWYgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5mb3JtYXRPblBhZ2VMb2FkYCkpLlxuICAgICAgICAgICAgICogTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXIgaGFzIHNldCBmb3IgYGRhdGEtYW4tZGVmYXVsdGAgaW4gdGhlIGh0bWwgKGFzcC5uZXQgdXNlcnMpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEluIG90aGVyIHdvcmRzIDogaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGRldmVsb3BlciBpcyB0cnlpbmcgdG8gcHJldmVudCBwb3N0YmFjayBwcm9ibGVtcy5cbiAgICAgICAgICAgICAqIEJ1dCBpZiBgaW5wdXQudmFsdWVgIGlzIHNldCB0byBhIG51bWJlciwgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LCB0aGVuIGl0IG1lYW5zIHRoZSBkZXYgaGFzXG4gICAgICAgICAgICAgKiBjaGFuZ2VkIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIHRoZW4gaXQgbWVhbnMgd2Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUgaGlzIG93biBkZWNpc2lvbiB0byBkbyBzby5cbiAgICAgICAgICAgICAqIEhlbmNlLCBpZiBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgaWdub3JlIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgYWx0b2dldGhlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoJHRoaXMuYXR0cigndmFsdWUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCBvciBub3RcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ZWRDdXJyZW50VmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJ1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAvL1RPRE8gUmVwbGFjZSB3aGF0ZXZlciBsb2NhbGUgY2hhcmFjdGVyIGlzIHVzZWQgYnkgYSAnLicsIGFuZCBub3Qgb25seSB0aGUgY29tbWEgJywnLCBiYXNlZCBvbiB0aGUgbG9jYWxlIHVzZWQgYnkgdGhlIHVzZXJcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsICYmIHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlLnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICEkLmlzTnVtZXJpYyhjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5zY2FsZURpdmlzb3IgJiYgc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZSgkdGhpc1swXSwgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHNob3VsZCBOT1QgYmUgc2F2ZWQgaW4gc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG9TdHJpcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChjdXJyZW50VmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9TdHJpcCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHwgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycgJiYgY29udGFpbnMoY3VycmVudFZhbHVlLCAnLScpKT8nLScgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpOnN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0b1N0cmlwLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSAkdGhpcy50ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2UgdGhlIHVzZXIgZXhwZXJpZW5jZSBieSBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gZGVwZW5kaW5nIG9uIGBjdXJyZW5jeVN5bWJvbGAgYW5kIGBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdXNlciBoYXMgbm90IHNldCB0aGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIChgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgKSwgYnV0IGhhcyBzZXQgYSBjdXJyZW5jeSBzeW1ib2wgKGBjdXJyZW5jeVN5bWJvbGApLFxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgaW4gb3JkZXIgdG8ga2VlcCB0aGUgcmVzdWx0aW5nIG91dHB1dCBsb2dpY2FsIGJ5IGRlZmF1bHQgOlxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSlcbiAgICAgKiAtIFwiLTEsMjM0LjU2JFwiIGluc3RlYWQgb2YgXCIxLDIzNC41Ni0kXCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ycmVjdFBOZWdPcHRpb24ob3B0aW9ucywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy9UT0RPIE1lcmdlIHRoZSBvcHRpb25zIGFuZCBzZXR0aW5ncyBwYXJhbWV0ZXIgdG8gdXNlIG9ubHkgYHNldHRpbmdzYFxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG9wdGlvbnMpICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eShvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSAmJiBvcHRpb25zLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdwJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID0gJ3InO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHl6ZSBhbmQgc2F2ZSB0aGUgbWluaW11bVZhbHVlIGFuZCBtYXhpbXVtVmFsdWUgaW50ZWdlciBzaXplIGZvciBsYXRlciB1c2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyhzZXR0aW5ncykge1xuICAgICAgICBsZXQgW21heGltdW1WYWx1ZUludGVnZXJQYXJ0XSA9IHNldHRpbmdzLm1heGltdW1WYWx1ZS50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgIGxldCBbbWluaW11bVZhbHVlSW50ZWdlclBhcnRdID0gKCFzZXR0aW5ncy5taW5pbXVtVmFsdWUgJiYgc2V0dGluZ3MubWluaW11bVZhbHVlICE9PSAwKT9bXTpzZXR0aW5ncy5taW5pbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1heGltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0ID0gbWluaW11bVZhbHVlSW50ZWdlclBhcnQucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICBzZXR0aW5ncy5tSW50UG9zID0gTWF0aC5tYXgobWF4aW11bVZhbHVlSW50ZWdlclBhcnQubGVuZ3RoLCAxKTtcbiAgICAgICAgc2V0dGluZ3MubUludE5lZyA9IE1hdGgubWF4KG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IGBkZWNpbWFsUGxhY2VzT3ZlcnJpZGVgIGFzIG5lZWRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29ycmVjdE1EZWNPcHRpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFpc051bGwoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSAmJiAhaXNOdWxsKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB3aXRoIHRoZSBvbmUgZGVmaW5lZCB3aXRoIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdG8gc2hvdyB3aGVuIG5vdCBpbiBmb2N1cywgaWYgc2V0XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLm9EZWMgPSBTdHJpbmcoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcblxuICAgICAgICAvLyBNb3N0IGNhbGN1bHVzIGFzc3VtZSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBpcyBhbiBpbnRlZ2VyLCB0aGUgZm9sbG93aW5nIHN0YXRlbWVudCBtYWtlcyBpdCBjbGVhciAob3RoZXJ3aXNlIGhhdmluZyBpdCBhcyBhIHN0cmluZyBsZWFkcyB0byBwcm9ibGVtcyBpbiByb3VuZGluZyBmb3IgaW5zdGFuY2UpXG4gICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmIE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpID4gMCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcuJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcsJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncykge1xuICAgICAgICBjb25zdCBhTmVnUmVnID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyP2AoWy1cXFxcJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9XT8pYDonKC0/KSc7XG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHsoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyP2BcXFxcJHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9YDonJyl9XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1cXFxcZF0uKj8oXFxcXGR8XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1cXFxcZClgKTtcbiAgICAgICAgc2V0dGluZ3Muc2tpcExhc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAoXFxcXGRcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfT8pW15cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfVxcXFxkXVxcXFxEKiRgKTtcblxuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0/KFxcXFxkK1xcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9XFxcXGQrKXwoXFxcXGQqKD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn1cXFxcZCopPykpYCk7XG5cbiAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxuICAgICAgICBzZXR0aW5ncy5zdHJpcFJlZyA9IG5ldyBSZWdFeHAoYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGQpYCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSB1c2VyIHNldHRpbmdzIHRvIG1ha2UgdGhlbSAnZXhwbG9pdGFibGUnIGxhdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKSB7XG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHN0cmluZyAndHJ1ZScgYW5kICdmYWxzZScgdG8gcmVhbCBCb29sZWFuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICd0cnVlJyB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2tleV0gPSB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IG51bWJlcnMgaW4gb3B0aW9ucyB0byBzdHJpbmdzXG4gICAgICAgICAgICAvL1RPRE8gaWYgYSB2YWx1ZSBpcyBhbHJlYWR5IG9mIHR5cGUgJ051bWJlcicsIHNob3VsZG4ndCB3ZSBrZWVwIGl0IGFzIGEgbnVtYmVyIGZvciBmdXJ0aGVyIG1hbmlwdWxhdGlvbiwgaW5zdGVhZCBvZiB1c2luZyBhIHN0cmluZz9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgb2xkIHNldHRpbmdzIG9wdGlvbnMgbmFtZSB0byBuZXcgb25lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucykge1xuICAgICAgICAvL1RPRE8gRGVsZXRlIHRoaXMgZnVuY3Rpb24gb25jZSB0aGUgb2xkIG9wdGlvbnMgYXJlIG5vdCB1c2VkIGFueW1vcmVcbiAgICAgICAgY29uc3Qgb2xkT3B0aW9uc0NvbnZlcnRlciA9IHtcbiAgICAgICAgICAgIC8vIE9sZCBvcHRpb24gbmFtZSwgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIG5ldyBvcHRpb25cbiAgICAgICAgICAgIGFTZXAgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGlnaXRHcm91cFNlcGFyYXRvcicsXG4gICAgICAgICAgICBuU2VwICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25vU2VwYXJhdG9yT25Gb2N1cycsXG4gICAgICAgICAgICBkR3JvdXAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RpZ2l0YWxHcm91cFNwYWNpbmcnLFxuICAgICAgICAgICAgYURlYyAgICAgICAgICAgICAgICAgICAgICAgICA6ICdkZWNpbWFsQ2hhcmFjdGVyJyxcbiAgICAgICAgICAgIGFsdERlYyAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlJyxcbiAgICAgICAgICAgIGFTaWduICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2wnLFxuICAgICAgICAgICAgcFNpZ24gICAgICAgICAgICAgICAgICAgICAgICA6ICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcsXG4gICAgICAgICAgICBwTmVnICAgICAgICAgICAgICAgICAgICAgICAgIDogJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyxcbiAgICAgICAgICAgIGFTdWZmaXggICAgICAgICAgICAgICAgICAgICAgOiAnc3VmZml4VGV4dCcsXG4gICAgICAgICAgICBvTGltaXRzICAgICAgICAgICAgICAgICAgICAgIDogJ292ZXJyaWRlTWluTWF4TGltaXRzJyxcbiAgICAgICAgICAgIHZNYXggICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWF4aW11bVZhbHVlJyxcbiAgICAgICAgICAgIHZNaW4gICAgICAgICAgICAgICAgICAgICAgICAgOiAnbWluaW11bVZhbHVlJyxcbiAgICAgICAgICAgIG1EZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyxcbiAgICAgICAgICAgIGVEZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycsXG4gICAgICAgICAgICBzY2FsZURlY2ltYWwgICAgICAgICAgICAgICAgIDogJ3NjYWxlRGVjaW1hbFBsYWNlcycsXG4gICAgICAgICAgICBhU3RvciAgICAgICAgICAgICAgICAgICAgICAgIDogJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnLFxuICAgICAgICAgICAgbVJvdW5kICAgICAgICAgICAgICAgICAgICAgICA6ICdyb3VuZGluZ01ldGhvZCcsXG4gICAgICAgICAgICBhUGFkICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2FsbG93RGVjaW1hbFBhZGRpbmcnLFxuICAgICAgICAgICAgbkJyYWNrZXQgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicsXG4gICAgICAgICAgICB3RW1wdHkgICAgICAgICAgICAgICAgICAgICAgIDogJ2VtcHR5SW5wdXRCZWhhdmlvcicsXG4gICAgICAgICAgICBsWmVybyAgICAgICAgICAgICAgICAgICAgICAgIDogJ2xlYWRpbmdaZXJvJyxcbiAgICAgICAgICAgIGFGb3JtICAgICAgICAgICAgICAgICAgICAgICAgOiAnZm9ybWF0T25QYWdlTG9hZCcsXG4gICAgICAgICAgICBzTnVtYmVyICAgICAgICAgICAgICAgICAgICAgIDogJ3NlbGVjdE51bWJlck9ubHknLFxuICAgICAgICAgICAgYW5EZWZhdWx0ICAgICAgICAgICAgICAgICAgICA6ICdkZWZhdWx0VmFsdWVPdmVycmlkZScsXG4gICAgICAgICAgICB1blNldE9uU3VibWl0ICAgICAgICAgICAgICAgIDogJ3VuZm9ybWF0T25TdWJtaXQnLFxuICAgICAgICAgICAgb3V0cHV0VHlwZSAgICAgICAgICAgICAgICAgICA6ICdvdXRwdXRGb3JtYXQnLFxuICAgICAgICAgICAgZGVidWcgICAgICAgICAgICAgICAgICAgICAgICA6ICdzaG93V2FybmluZ3MnLFxuICAgICAgICAgICAgLy8gQ3VycmVudCBvcHRpb25zIDpcbiAgICAgICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbm9TZXBhcmF0b3JPbkZvY3VzICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkaWdpdGFsR3JvdXBTcGFjaW5nICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBzdWZmaXhUZXh0ICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZSAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZURpdmlzb3IgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbFBsYWNlcyAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVTeW1ib2wgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9uSW52YWxpZFBhc3RlICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgOiB0cnVlLFxuICAgICAgICAgICAgZW1wdHlJbnB1dEJlaGF2aW9yICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzaG93V2FybmluZ3MgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgLy9GSVhNRSBGaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgdGhvc2UgaW50ZXJuYWwgZGF0YSBmcm9tIHRoZSBzZXR0aW5ncyBvYmplY3QgKGlkZWFsbHkgYnkgdXNpbmcgYW5vdGhlciBvYmplY3QsIG9yIGJldHRlciB5ZXQsIGNsYXNzIGF0dHJpYnV0ZXMpIC0tPlxuICAgICAgICAgICAgb25PZmYgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcnVuT25jZSAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZSAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY2FyZXRGaXggICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc3RyaXAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVTaWduQ2hhcmFjdGVyOiB0cnVlLFxuICAgICAgICAgICAgbUludFBvcyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbUludE5lZyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb0RlYyAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1BhZCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb0JyYWNrZXQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1NlcCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1NpZ24gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1N1ZmZpeCAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYU5lZ1JlZ0F1dG9TdHJpcCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcEZpcnN0QXV0b1N0cmlwICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcExhc3RBdXRvU3RyaXAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZEF1dG9TdHJpcCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbnVtUmVnQXV0b1N0cmlwICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc3RyaXBSZWcgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaG9sZGVyICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXMgYSAnbmV3JyBvcHRpb24sIHdlIGNvbnRpbnVlIGxvb3BpbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXIuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHdlIGhhdmUgYW4gJ29sZCcgb3B0aW9uIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZyhgWW91IGFyZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBvcHRpb24gbmFtZSAnJHtvcHRpb259Jy4gUGxlYXNlIHVzZSAnJHtvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl19JyBpbnN0ZWFkIGZyb20gbm93IG9uLiBUaGUgb2xkIG9wdGlvbiBuYW1lIHdpbGwgYmUgZHJvcHBlZCBzb29uLmAsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gd2UgbW9kaWZ5IHRoZSBpbml0aWFsIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBuZXcgb3B0aW9ucyBpbnN0ZWFkIG9mIHRoZSBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXV0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3IgdGhlIG9wdGlvbiBuYW1lIGlzIHVua25vd24uIFRoaXMgbWVhbnMgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVyZWZvcmUgd2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYE9wdGlvbiBuYW1lICcke29wdGlvbn0nIGlzIHVua25vd24uIFBsZWFzZSBmaXggdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGF1dG9OdW1lcmljYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHlzZSB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBwYXNzZWQgYnkgdGhlIHVzZXIsIHZhbGlkYXRlIGFuZCBjbGVhbiB0aGVtLCB0aGVuIHJldHVybiB0aGVtLlxuICAgICAqIE5vdGU6IFRoaXMgcmV0dXJucyBgbnVsbGAgaWYgc29tZWhvdyB0aGUgc2V0dGluZ3MgcmV0dXJuZWQgYnkgalF1ZXJ5IGlzIG5vdCBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIFRSVUUsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIWlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlIHx8IGlzVW5kZWZpbmVkKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncyBjcmVhdGUgdGhlbSBmcm9tIHRoZSBkZWZhdWx0IG9uZXMgYW5kIGNvbWJpbmUgdGhlbSB3aXRoIHRoZSBvcHRpb25zIHBhc3NlZFxuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgZ2VuZXJhdGVkIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBIVE1MNSBkYXRhLCBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB0YWdEYXRhLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIG9uT2ZmICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgIDogdHJ1ZSwgLy8gVGhyb3cgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgIDogYWxsb3dlZFRhZ0xpc3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJ1xuICAgICAgICAgICAgdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gSW1wcm92ZSB0aGUgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb3JyZWN0UE5lZ09wdGlvbihvcHRpb25zLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNldCB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciA9IHNldHRpbmdzLm1pbmltdW1WYWx1ZSA8IDAgPyAnLScgOiAnJztcblxuICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBjaGFuZ2VzIHRvIHRoZSBzZXR0aW5ncyBvYmplY3QgKGZyb20gdGhlIG9yaWdpbmFsIGF1dG9Db2RlKCkgZnVuY3Rpb24pXG4gICAgICAgICAgICBydW5DYWxsYmFja3NGb3VuZEluVGhlU2V0dGluZ3NPYmplY3QoJHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIGNhbGN1bGF0ZVZNaW5BbmRWTWF4SW50ZWdlclNpemVzKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGNvcnJlY3RNRGVjT3B0aW9uKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpO1xuICAgICAgICAgICAgY2FjaGVzVXN1YWxSZWd1bGFyRXhwcmVzc2lvbnMoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgc2V0dGluZ3NcbiAgICAgICAgICAgIHZhbGlkYXRlKHNldHRpbmdzLCBmYWxzZSk7IC8vIFRocm93cyBpZiBuZWNlc3NhcnlcblxuICAgICAgICAgICAgLy8gT3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMsIHNjYWxlRGl2aXNvciAmIG5vU2VwYXJhdG9yT25Gb2N1cyBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICAgICAgICBrZWVwQW5PcmlnaW5hbFNldHRpbmdzQ29weShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgb3VyIG5ldyBzZXR0aW5nc1xuICAgICAgICAgICAgJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kcyBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNcbiAgICAgKi9cbiAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGluaXRpYXRlIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7ZGlnaXRHcm91cFNlcGFyYXRvcjogXCIuXCIsIGRlY2ltYWxDaGFyYWN0ZXI6IFwiLFwiLCBjdXJyZW5jeVN5bWJvbDogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoKTsgICAgICAgICAgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgeyp8e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlcywgb3ZlcnJpZGVzfXx7c3RhdGVtZW50cywgYnJhbmNoZXMsIGxpbmVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfXx7c3RhdGVtZW50cywgbGluZXMsIGJyYW5jaGVzLCBmdW5jdGlvbnMsIGV4Y2x1ZGVzfX1cbiAgICAgICAgICovXG4gICAgICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9ICQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgY29uc3QgaG9sZGVyID0gZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnJ1bk9uY2UgJiYgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkKHNldHRpbmdzLCAkaW5wdXQsICR0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5ydW5PbmNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgZXZlbnRzIGxpc3RlbmVycyB0byBzdXBwb3J0ZWQgaW5wdXQgdHlwZXMgKFwidGV4dFwiLCBcImhpZGRlblwiLCBcInRlbFwiIGFuZCBubyB0eXBlKVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgZSA9PiB7IG9uRm9jdXNJbkFuZE1vdXNlRW50ZXIoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBlID0+IHsgb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7IG9uS2V5ZG93bihob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBlID0+IHsgb25LZXlwcmVzcyhob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHsgb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBlID0+IHsgb25CbHVyKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGUgPT4geyBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpOyAvL1RPRE8gU3dpdGNoIHRvIGBhZGRFdmVudExpc3RlbmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc3RvcCBhbmQgcmVtb3ZlIGF1dG9OdW1lcmljIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gRGVzdHJveXMgYXV0b051bWVyaWMgb24gdGhpcyBzZWxlY3RlZCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGZyb20gc2Vzc2lvblN0b3JhZ2UgKG9yIGNvb2tpZSwgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyBSZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICB3aXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gVXBkYXRlcyB0aGUgc2V0dGluZ3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpcCA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGdldEluaXRpYWxTZXR0aW5ncyhvcHRpb25zLCAkdGhpcywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdCB0aGF0IHN0b3JlIHRoZSBmaWVsZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgZ2V0QXV0b051bWVyaWNIb2xkZXIoJHRoaXMsIHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAndmFsdWUnKTsgLy8gRm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IG5ld1ZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYWxsb3dzIGxvY2FsZSBkZWNpbWFsIHNlcGFyYXRvciB0byBiZSBhIGNvbW1hIC0gbm8gdGhvdXNhbmQgc2VwYXJhdG9yIGFsbG93ZWRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGZyb21Mb2NhbGUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGhyb3dzIGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBiZWluZyBzZXQgaXMgbm90IG51bWVyaWNcbiAgICAgICAgICAgICAgICBpZiAoISQuaXNOdW1lcmljKE51bWJlcih2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmcoYFRoZSB2YWx1ZSBcIiR7dmFsdWV9XCIgYmVpbmcgXCJzZXRcIiBpcyBub3QgbnVtZXJpYyBhbmQgdGhlcmVmb3JlIGNhbm5vdCBiZSB1c2VkIGFwcHJvcHJpYXRlbHkuYCwgc2V0dGluZ3Muc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlIHZhbHVlIGZhbGxzIHdpdGhpbiB0aGUgbWluIG1heCByYW5nZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiAhc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvIHNldHRpbmdzLnNjYWxlRGl2aXNvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAoc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzKSA/IHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcyA6IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5zY2FsZURpdmlzb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICYmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmICYmIHNldHRpbmdzLnNjYWxlU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBzZXR0aW5ncy5zY2FsZVN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMuXG4gICAgICAgICAqIFRoaXMgaXMgaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5ncyAoaWUuIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiksIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycy5cbiAgICAgICAgICogUGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygndW5TZXQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCR0aGlzLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZS1mb3JtYXQgaW5wdXRzLlxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSAndW5TZXQnIG1ldGhvZCB0byByZWZvcm1hdCB0aGUgaW5wdXRcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAvL1RPRE8gV2h5IHdvdWxkIHdlIG5lZWQgdG8gZ2V0IGEgbmV3IHJlZmVyZW5jZSB0byAkdGhpcyBzaW5jZSBpdCBoYXMgYmVlbiBkb25lIGluIGBpbml0KClgP1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBlbGVtZW50IHR5cGUgdGhlbiB1c2UgLmVxKDApIHNlbGVjdG9yIHRvIGdyYWIgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnZhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS50ZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBcIjwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT5cIiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vbk9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgfHwgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUsIGJ1dCBmb2xsb3dpbmcgdGhlIGBvdXRwdXRGb3JtYXRgIHNldHRpbmcsIHdoaWNoIG1lYW5zIHRoZSBvdXRwdXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICAgICAqIC0gYSBzdHJpbmcgKHRoYXQgY291bGQgb3IgY291bGQgbm90IHJlcHJlc2VudCBhIG51bWJlciAoaWUuIFwiMTIzNDUsNjctXCIpKSwgb3JcbiAgICAgICAgICogLSBhIHBsYWluIG51bWJlciAoaWYgdGhlIHNldHRpbmcgJ251bWJlcicgaXMgdXNlZCkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgdGhlIHJldHVybmVkIHZhbHVlcyBhcmUgYW4gSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2QuXG4gICAgICAgICAqIENoZWNrIHRoZSBcIm91dHB1dEZvcm1hdFwiIG9wdGlvbiBkZWZpbml0aW9uIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TG9jYWxpemVkKCkge1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9ICR0aGlzLmF1dG9OdW1lcmljKCdnZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgY3VycmVudCBmb3JtYXR0ZWQgdmFsdWUgb2YgdGhlIGF1dG9OdW1lcmljIGVsZW1lbnQuXG4gICAgICAgICAqIEB1c2FnZSBhTklucHV0LmF1dG9OdW1lcmljKCdnZXRGb3JtYXR0ZWQnKSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEZvcm1hdHRlZCgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBgdGhpc1swXWAgZXhpc3RzIGFzIHdlbGwgYXMgYC52YWx1ZWAgYmVmb3JlIHRyeWluZyB0byBhY2Nlc3MgdGhhdCBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KCcwJykgfHwgISgndmFsdWUnIGluIHRoaXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcignVW5hYmxlIHRvIGdldCB0aGUgZm9ybWF0dGVkIHN0cmluZyBmcm9tIHRoZSBlbGVtZW50LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpc1swXS52YWx1ZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkoZmFsc2UsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiIG9yIHBsYWluIG51bWJlcnMgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7e318W119XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBcnJheSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheSh0cnVlLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlICdnZXRTZXR0aW5ncycgZnVuY3Rpb24gcmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGN1cnJlbnQgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTtcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpLmRlY2ltYWxDaGFyYWN0ZXI7IC8vIFJldHVybiB0aGUgZGVjaW1hbENoYXJhY3RlciBzZXR0aW5nIGFzIGEgc3RyaW5nIC0gYW55IHZhbGlkIG9wdGlvbiBuYW1lIGNhbiBiZSB1c2VkXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgICAgIC8vVE9ETyBBZGQgYW4gb3B0aW9uIGFyZ3VtZW50IGBvcHRpb25OYW1lYCB0byB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIG9ubHkgdGhlIHZhbHVlIG9mIHRoYXQgb3B0aW9uLCBub3QgdGhlIGVudGlyZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBhdXRvTnVtZXJpYyBmdW5jdGlvbiBhY2NlcHRzIG1ldGhvZHMgbmFtZXMgKGluIHN0cmluZyBmb3JtYXQpIGFuZCB0aG9zZSBtZXRob2QgcGFyYW1ldGVycyBpZiBuZWVkZWQuXG4gICAgICogSXQgaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBvbiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2QgVGhlIG1ldGhvZCBuYW1lIChpZS4gJ3NldCcsICdnZXQnLCBldGMuKVxuICAgICAqIEBwYXJhbSB7Kn0gYXJnc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkZWZhdWx0IGF1dG9OdW1lcmljIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gKCkgPT4gZGVmYXVsdFNldHRpbmdzO1xuXG4gICAgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cyA9IGRlZmF1bHRTZXR0aW5nczsgLy8gTWFrZSB0aG9zZSBzZXR0aW5ncyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcbiAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYEEgbnVtYmVyIGlzIG5lZWRlZCB0byBiZSBhYmxlIHRvIGZvcm1hdCBpdCwgWyR7dmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYXRlIGEgdmVyeSBiYXNpYyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB7IHN0cmlwOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZVN0cmluZyA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlU3RyaW5nID0gZnJvbUxvY2FsZSh2YWx1ZVN0cmluZyk7XG5cbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBtYXhpbXVtVk1pbkFuZFZNYXhEZWNpbWFsTGVuZ3RoKHNldHRpbmdzLm1pbmltdW1WYWx1ZSwgc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhc2ljIHRlc3RzIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZVN0cmluZyBpcyB2YWxpZFxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBkb2N1bWVudCwgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgb2ssIHByb2NlZWQgdG8gcm91bmRpbmcsIGZvcm1hdHRpbmcgYW5kIGdyb3VwaW5nXG4gICAgICAgIHZhbHVlU3RyaW5nID0gcm91bmRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZztcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2aW5nIGFuIHVuZm9ybWF0dGVkIHZhbHVlIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgdW5mb3JtYXR0ZWQgdmFsdWUsIHdoYXRldmVyIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHsgLy9UT0RPIENvbXBsZXRlIHRoZSB0ZXN0IHRvIHRocm93IHdoZW4gZ2l2ZW4gYSB3cm9uZ2x5IGZvcm1hdHRlZCBudW1iZXIgKGllLiAnZm9vYmFyJylcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYEEgbnVtYmVyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIG51bWJlciBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byB1bmZvcm1hdCBpdCwgWyR7dmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWA7XG4gICAgICAgIGNvbnN0IGF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIGlmICh2YWx1ZS5jaGFyQXQoMCkgPT09ICctJykge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICYmIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0Rm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0OyAvLyBUaGUgalF1ZXJ5IGV4cG9ydFxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgdGhlIGdpdmVuIG9wdGlvbiBvYmplY3QuXG4gICAgICogSWYgdGhlIG9wdGlvbnMgYXJlIHZhbGlkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgbm90aGluZywgb3RoZXJ3aXNlIGlmIHRoZSBvcHRpb25zIGFyZSBpbnZhbGlkLCB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgdGVzdHMgaWYgdGhlIG9wdGlvbnMgYXJlIG5vdCBjb25mbGljdGluZyBhbmQgYXJlIHdlbGwgZm9ybWF0dGVkLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGVuaWVudCBzaW5jZSBpdCBvbmx5IHRlc3RzIHRoZSBzZXR0aW5ncyBwcm9wZXJ0aWVzIDsgaXQgaWdub3JlcyBhbnkgb3RoZXIgcHJvcGVydGllcyB0aGUgb3B0aW9ucyBvYmplY3QgY291bGQgaGF2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdXNlck9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zIElmIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGV4dGVuZHMgdGhlIGB1c2VyT3B0aW9uc2AgcGFzc2VkIGJ5IHRoZSB1c2VyLCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMuXG4gICAgICogQHRocm93cyBFcnJvclxuICAgICAqL1xuICAgIHZhbGlkYXRlID0gKHVzZXJPcHRpb25zLCBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyA9IHRydWUpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh1c2VyT3B0aW9ucykgfHwgIWlzT2JqZWN0KHVzZXJPcHRpb25zKSB8fCBpc0VtcHR5T2JqKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVzZXJPcHRpb25zIGFyZSBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgdmFsaWQgb2JqZWN0LCBbJHt1c2VyT3B0aW9uc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICghaXNOdWxsKHVzZXJPcHRpb25zKSkge1xuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXModXNlck9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHVzZXIgY2FuIGNob29zZSBpZiB0aGUgYHVzZXJPcHRpb25zYCBoYXMgYWxyZWFkeSBiZWVuIGV4dGVuZGVkIHdpdGggdGhlIGRlZmF1bHQgb3B0aW9ucywgb3Igbm90XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB1c2VyT3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCB0aGluZ3MgZmlyc3QsIHdlIHRlc3QgdGhhdCB0aGUgYHNob3dXYXJuaW5nc2Agb3B0aW9uIGlzIHZhbGlkXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNob3dXYXJuaW5ncykgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNob3dXYXJuaW5ncykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWJ1ZyBvcHRpb24gJ3Nob3dXYXJuaW5ncycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2hvd1dhcm5pbmdzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgbmVlZGVkIGZvciB0aGUgZm9sbG93aW5nIHRlc3RzXG4gICAgICAgIGNvbnN0IHRlc3RQb3NpdGl2ZUludGVnZXIgPSAvXlswLTldKyQvO1xuICAgICAgICBjb25zdCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyA9IC9bMC05XSsvO1xuICAgICAgICAvLyBjb25zdCB0ZXN0RmxvYXRBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbiA9IC9eLT9bMC05XSsoXFwuP1swLTldKykkLztcbiAgICAgICAgY29uc3QgdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspPyQvO1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVGbG9hdE9ySW50ZWdlciA9IC9eWzAtOV0rKFxcLj9bMC05XSspPyQvO1xuXG4gICAgICAgIC8vIFRoZW4gdGVzdHMgdGhlIG9wdGlvbnMgaW5kaXZpZHVhbGx5XG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvciwgWycsJywgJy4nLCAnICcsICcnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGlnaXRHcm91cFNlcGFyYXRvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJyAnIG9yIGVtcHR5ICgnJyksIFske29wdGlvbnMuZGlnaXRHcm91cFNlcGFyYXRvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlICdub1NlcGFyYXRvck9uRm9jdXMnIG9wdGlvbiBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5ub1NlcGFyYXRvck9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZykpIHsgLy8gaXNOYU4ocGFyc2VJbnQob3B0aW9ucy5kaWdpdGFsR3JvdXBTcGFjaW5nKSkgLy9ERUJVR1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRob3VzYW5kIHNlcGFyYXRvciBvcHRpb24gJ2RpZ2l0YWxHcm91cFNwYWNpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmd9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlciwgWycsJywgJy4nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXIgb3B0aW9uICdkZWNpbWFsQ2hhcmFjdGVyJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlICcuJyBvciAnLCcsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyID09PSBvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdkZWNpbWFsQ2hhcmFjdGVyJyBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciAnZGlnaXRHcm91cFNlcGFyYXRvcicgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdjdXJyZW5jeVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCwgWydwJywgJ3MnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIGN1cnJlbmN5IHNpZ24gb3B0aW9uICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpIG9yICdzJyAoc3VmZml4KSwgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCwgWydwJywgJ3MnLCAnbCcsICdyJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIG9wdGlvbiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpIG9yICdyJyAocmlnaHQpLCBbJHtvcHRpb25zLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgKG9wdGlvbnMuc3VmZml4VGV4dCAhPT0gJycgJiYgKGNvbnRhaW5zKG9wdGlvbnMuc3VmZml4VGV4dCwgJy0nKSB8fCB0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycy50ZXN0KG9wdGlvbnMuc3VmZml4VGV4dCkpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGFkZGl0aW9uYWwgc3VmZml4IG9wdGlvbiAnc3VmZml4VGV4dCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBub3QgY29udGFpbnMgdGhlIG5lZ2F0aXZlIHNpZ24gJy0nIG5vciBhbnkgbnVtZXJpY2FsIGNoYXJhY3RlcnMsIFske29wdGlvbnMuc3VmZml4VGV4dH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cykgJiYgIWlzSW5BcnJheShvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzLCBbJ2NlaWxpbmcnLCAnZmxvb3InLCAnaWdub3JlJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgb3ZlcnJpZGUgbWluICYgbWF4IGxpbWl0cyBvcHRpb24gJ292ZXJyaWRlTWluTWF4TGltaXRzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnY2VpbGluZycsICdmbG9vcicgb3IgJ2lnbm9yZScsIFske29wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5tYXhpbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtYXhpbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLm1pbmltdW1WYWx1ZSkgfHwgIXRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduLnRlc3Qob3B0aW9ucy5taW5pbXVtVmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbWluaW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gJ21pbmltdW1WYWx1ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VGbG9hdChvcHRpb25zLm1pbmltdW1WYWx1ZSkgPiBwYXJzZUZsb2F0KG9wdGlvbnMubWF4aW11bVZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZSBvcHRpb24gOyAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gJ21heGltdW1WYWx1ZScgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XS5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKGlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgfHxcbiAgICAgICAgICAgIChpc0ludChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgb3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPj0gMCkgfHwgLy8gSWYgaW50ZWdlciBvcHRpb25cbiAgICAgICAgICAgIChpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdGVzdFBvc2l0aXZlSW50ZWdlci50ZXN0KG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkpICAvLyBJZiBzdHJpbmcgb3B0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9wdGlvbiAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIGEgd2FybmluZyBtZXNzYWdlIGluIHRoZSBjb25zb2xlIGlmIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlIGlzIG92ZXJyaWRkZW4gYnkgZGVjaW1hbFBsYWNlc092ZXJyaWRlIChhbmQgbm90IGlmIGRlY2ltYWxQbGFjZXNPdmVycmlkZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgdXNlZCBpbiBtaW5pbXVtVmFsdWUvbWF4aW11bVZhbHVlKVxuICAgICAgICBjb25zdCB2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzID0gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChvcHRpb25zLm1pbmltdW1WYWx1ZSwgb3B0aW9ucy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgJiYgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyAhPT0gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSkge1xuICAgICAgICAgICAgd2FybmluZyhgU2V0dGluZyAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyB0byBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHdpbGwgb3ZlcnJpZGUgdGhlIGRlY2ltYWxzIGRlY2xhcmVkIGluICdtaW5pbXVtVmFsdWUnIFske29wdGlvbnMubWluaW11bVZhbHVlfV0gYW5kICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcgJiYgIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2FsbG93RGVjaW1hbFBhZGRpbmcnIHRvIFtmYWxzZV0gd2lsbCBvdmVycmlkZSB0aGUgY3VycmVudCAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBzZXR0aW5nIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0uYCwgb3B0aW9ucy5zaG93V2FybmluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAoIWlzU3RyaW5nKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgfHwgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG51bWJlciBvZiBleHBhbmRlZCBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrcyBpZiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzXCIgaXMgZ3JlYXRlciB0aGFuIHRoZSBub3JtYWwgZGVjaW1hbCBwbGFjZXMgXCJkZWNpbWFsUGxhY2VzT3ZlcnJpZGVcIlxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpICYmICFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkgPiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkge1xuICAgICAgICAgICAgd2FybmluZyhgVGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXN9XSBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIHRoZSAnZGVjaW1hbFBsYWNlc092ZXJyaWRlJyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dIHZhbHVlLiBDdXJyZW50bHksIHRoaXMgd2lsbCBsaW1pdCB0aGUgYWJpbGl0eSBvZiB5b3VyIGNsaWVudCB0byBtYW51YWxseSBjaGFuZ2Ugc29tZSBvZiB0aGUgZGVjaW1hbCBwbGFjZXMuIERvIHlvdSByZWFsbHkgd2FudCB0byBkbyB0aGF0P2AsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVEaXZpc29yKSAmJiAhdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBkaXZpc29yIG9wdGlvbiAnc2NhbGVEaXZpc29yJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgbnVtYmVyLCBwcmVmZXJhYmx5IGFuIGludGVnZXIsIFske29wdGlvbnMuc2NhbGVEaXZpc29yfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykgJiYgIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzY2FsZSBudW1iZXIgb2YgZGVjaW1hbHMgb3B0aW9uICdzY2FsZURlY2ltYWxQbGFjZXMnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGVjaW1hbFBsYWNlc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZVN5bWJvbCkgJiYgIWlzU3RyaW5nKG9wdGlvbnMuc2NhbGVTeW1ib2wpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgc3ltYm9sIG9wdGlvbiAnc2NhbGVTeW1ib2wnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcsIFske29wdGlvbnMuc2NhbGVTeW1ib2x9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNhdmUgdG8gc2Vzc2lvbiBzdG9yYWdlIG9wdGlvbiAnc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5vbkludmFsaWRQYXN0ZSwgW1xuICAgICAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgICAgICdpZ25vcmUnLFxuICAgICAgICAgICAgJ2NsYW1wJyxcbiAgICAgICAgICAgICd0cnVuY2F0ZScsXG4gICAgICAgICAgICAncmVwbGFjZScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGFzdGUgYmVoYXZpb3Igb3B0aW9uICdvbkludmFsaWRQYXN0ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2Vycm9yJywgJ2lnbm9yZScsICdjbGFtcCcsICd0cnVuY2F0ZScgb3IgJ3JlcGxhY2UnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMub25JbnZhbGlkUGFzdGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMucm91bmRpbmdNZXRob2QsIFtcbiAgICAgICAgICAgICdTJyxcbiAgICAgICAgICAgICdBJyxcbiAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICdCJyxcbiAgICAgICAgICAgICdVJyxcbiAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICdDJyxcbiAgICAgICAgICAgICdGJyxcbiAgICAgICAgICAgICdOMDUnLFxuICAgICAgICAgICAgJ0NIRicsXG4gICAgICAgICAgICAnVTA1JyxcbiAgICAgICAgICAgICdEMDUnLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJvdW5kaW5nIG1ldGhvZCBvcHRpb24gJ3JvdW5kaW5nTWV0aG9kJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGVpdGhlciBiZSAnUycsICdBJywgJ3MnLCAnYScsICdCJywgJ1UnLCAnRCcsICdDJywgJ0YnLCAnTjA1JywgJ0NIRicsICdVMDUnIG9yICdEMDUnIChjZi4gZG9jdW1lbnRhdGlvbiksIFske29wdGlvbnMucm91bmRpbmdNZXRob2R9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmcpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGNvbnRyb2wgZGVjaW1hbCBwYWRkaW5nIG9wdGlvbiAnYWxsb3dEZWNpbWFsUGFkZGluZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cikgJiYgIWlzSW5BcnJheShvcHRpb25zLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLCBbJygsKScsICdbLF0nLCAnPCw+JywgJ3ssfSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGJyYWNrZXRzIGZvciBuZWdhdGl2ZSB2YWx1ZXMgb3B0aW9uICduZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJygsKScsICdbLF0nLCAnPCw+JyBvciAneyx9JywgWyR7b3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1cn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3IsIFsnZm9jdXMnLCAncHJlc3MnLCAnYWx3YXlzJywgJ3plcm8nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBkaXNwbGF5IG9uIGVtcHR5IHN0cmluZyBvcHRpb24gJ2VtcHR5SW5wdXRCZWhhdmlvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycgb3IgJ3plcm8nLCBbJHtvcHRpb25zLmVtcHR5SW5wdXRCZWhhdmlvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5sZWFkaW5nWmVybywgWydhbGxvdycsICdkZW55JywgJ2tlZXAnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBsZWFkaW5nIHplcm8gYmVoYXZpb3Igb3B0aW9uICdsZWFkaW5nWmVybycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2FsbG93JywgJ2RlbnknIG9yICdrZWVwJywgWyR7b3B0aW9ucy5sZWFkaW5nWmVyb31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZm9ybWF0T25QYWdlTG9hZCkgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZm9ybWF0IG9uIGluaXRpYWxpemF0aW9uIG9wdGlvbiAnZm9ybWF0T25QYWdlTG9hZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZm9ybWF0T25QYWdlTG9hZH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2VsZWN0TnVtYmVyT25seSkgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2VsZWN0IG51bWJlciBvbmx5IG9wdGlvbiAnc2VsZWN0TnVtYmVyT25seScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2VsZWN0TnVtYmVyT25seX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWZhdWx0VmFsdWVPdmVycmlkZSkgJiYgKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUgIT09ICcnICYmICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWUgb3B0aW9uICdkZWZhdWx0VmFsdWVPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXIsIFske29wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnVuZm9ybWF0T25TdWJtaXQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHJlbW92ZSBmb3JtYXR0aW5nIG9uIHN1Ym1pdCBvcHRpb24gJ3VuZm9ybWF0T25TdWJtaXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnVuZm9ybWF0T25TdWJtaXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3V0cHV0Rm9ybWF0KSAmJiAhaXNJbkFycmF5KG9wdGlvbnMub3V0cHV0Rm9ybWF0LCBbXG4gICAgICAgICAgICAnc3RyaW5nJyxcbiAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICAgICAgJy4nLFxuICAgICAgICAgICAgJy0uJyxcbiAgICAgICAgICAgICcsJyxcbiAgICAgICAgICAgICctLCcsXG4gICAgICAgICAgICAnLi0nLFxuICAgICAgICAgICAgJywtJyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXN0b20gbG9jYWxlIGZvcm1hdCBvcHRpb24gJ291dHB1dEZvcm1hdCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgbnVsbCwgJ3N0cmluZycsICdudW1iZXInLCAnLicsICctLicsICcsJywgJy0sJywgJy4tJyBvciAnLC0nLCBbJHtvcHRpb25zLm91dHB1dEZvcm1hdH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdmYWlsT25Vbmtub3duT3B0aW9uJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9ufV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi52YWxpZGF0ZSA9IHZhbGlkYXRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHNldHRpbmdzL29wdGlvbnMgYXJlIHZhbGlkLCBGQUxTRSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGFyZVNldHRpbmdzVmFsaWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbGlkYXRlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICAgIH0pKCk7XG59KSk7XG5cbi8qKlxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcbiAgICB2YWxpZGF0ZSwgLy8gYW4udmFsaWRhdGUob3B0aW9ucykgOiB0aHJvd3MgaWYgbmVjZXNzYXJ5XG4gICAgYXJlU2V0dGluZ3NWYWxpZCwgLy9hbi5hcmVTZXR0aW5nc1ZhbGlkKG9wdGlvbnMpIDogcmV0dXJuIHRydWUgb3IgZmFsc2UgLy9UT0RPIElzIHRoaXMgcmVkdW5kYW50PyBTaG91bGQgd2UgbGV0IHRoZSBkZXZlbG9wZXJzIHdyYXAgZWFjaCBhdXRvTnVtZXJpYy52YWxpZGF0ZSgpIGNhbGxzIGluIHRyeS9jYXRjaCBibG9jaz8gT3Igc2hvdWxkIHdlIGp1c3QgZmFjaWxpdGF0ZSB0aGVpciBsaWZlIGJ5IGRvaW5nIGl0IGFscmVhZHk/XG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9DOi9Vc2Vycy9ib2Jrbi9Eb2N1bWVudHMvR2l0SHViL2F1dG9OdW1lcmljL3NyYy9hdXRvTnVtZXJpYy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;