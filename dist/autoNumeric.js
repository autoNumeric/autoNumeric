(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jquery"));
	else if(typeof define === 'function' && define.amd)
		define(["jquery"], factory);
	else if(typeof exports === 'object')
		exports["autonumeric"] = factory(require("jquery"));
	else
		root["autonumeric"] = factory(root["jQuery"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* autoNumeric.js\n* @author: Bob Knothe\n* @contributors: Sokolov Yura and other Github users\n* @version: 2.0 - 2016-11-16 UTC-10 23:00\n*\n* Created by Robert J. Knothe on 2009-08-09. Please report any bugs to https://github.com/BobKnothe/autoNumeric\n*\n* Copyright (c) 2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n*\n* The MIT License (http://www.opensource.org/licenses/mit-license.php)\n*\n* Permission is hereby granted, free of charge, to any person\n* obtaining a copy of this software and associated documentation\n* files (the \"Software\"), to deal in the Software without\n* restriction, including without limitation the rights to use,\n* copy, modify, merge, publish, distribute, sub license, and/or sell\n* copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following\n* conditions:\n*\n* The above copyright notice and this permission notice shall be\n* included in all copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n* OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\n\n/* global module, require, define */\n\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    /**\n     * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n     */\n    var keyCode = {\n        Backspace: 8,\n        Tab: 9,\n        Enter: 13,\n        Shift: 16,\n        Ctrl: 17,\n        Alt: 18,\n        PauseBreak: 19,\n        CapsLock: 20,\n        Esc: 27,\n        Space: 32,\n        PageUp: 33,\n        PageDown: 34,\n        End: 35,\n        Home: 36,\n        LeftArrow: 37,\n        UpArrow: 38,\n        RightArrow: 39,\n        DownArrow: 40,\n        Insert: 45,\n        Delete: 46,\n        num0: 48,\n        num1: 49,\n        num2: 50,\n        num3: 51,\n        num4: 52,\n        num5: 53,\n        num6: 54,\n        num7: 55,\n        num8: 56,\n        num9: 57,\n        a: 65,\n        b: 66,\n        c: 67,\n        d: 68,\n        e: 69,\n        f: 70,\n        g: 71,\n        h: 72,\n        i: 73,\n        j: 74,\n        k: 75,\n        l: 76,\n        m: 77,\n        n: 78,\n        o: 79,\n        p: 80,\n        q: 81,\n        r: 82,\n        s: 83,\n        t: 84,\n        u: 85,\n        v: 86,\n        w: 87,\n        x: 88,\n        y: 89,\n        z: 90,\n        Windows: 91,\n        RightClick: 93,\n        numpad0: 96,\n        numpad1: 97,\n        numpad2: 98,\n        numpad3: 99,\n        numpad4: 100,\n        numpad5: 101,\n        numpad6: 102,\n        numpad7: 103,\n        numpad8: 104,\n        numpad9: 105,\n        MultiplyNumpad: 106,\n        PlusNumpad: 107,\n        MinusNumpad: 109,\n        DotNumpad: 110,\n        SlashNumpad: 111,\n        F1: 112,\n        F2: 113,\n        F3: 114,\n        F4: 115,\n        F5: 116,\n        F6: 117,\n        F7: 118,\n        F8: 119,\n        F9: 120,\n        F10: 121,\n        F11: 122,\n        F12: 123,\n        NumLock: 144,\n        ScrollLock: 145,\n        MyComputer: 182,\n        MyCalculator: 183,\n        Semicolon: 186,\n        Equal: 187,\n        Comma: 188,\n        Hyphen: 189,\n        Dot: 190,\n        Slash: 191,\n        Backquote: 192,\n        LeftBracket: 219,\n        Backslash: 220,\n        RightBracket: 221,\n        Quote: 222,\n        Command: 224\n    };\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is as String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {Array} array\n     * @param {*} needle\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle) || needle === '' || needle === null) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     */\n    function setElementSelection(that, start, end) {\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function to handle errors messages\n     */\n    function throwError(message, debug) {\n        if (debug) {\n            throw new Error(message);\n        }\n    }\n\n    /**\n     * run callbacks in parameters if any\n     * any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     */\n    function runCallbacks($this, settings) {\n        // loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the decimal length from the vMin vMax settings\n     */\n    function decLength(vMin, vMax) {\n        var vMaxLength = 0;\n        var vMinLength = 0;\n        if (vMax[1]) {\n            vMaxLength = vMax[1].length;\n        }\n        if (vMin[1]) {\n            vMinLength = vMin[1].length;\n        }\n\n        return Math.max(vMaxLength, vMinLength);\n    }\n\n    /**\n     * Preparing user defined options for further usage\n     * merge them with defaults appropriately\n     */\n    function autoCode($this, settings) {\n        runCallbacks($this, settings);\n        var vMax = settings.vMax.toString().split('.');\n        var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n        settings.aNeg = settings.vMin < 0 ? '-' : '';\n        vMax[0] = vMax[0].replace('-', '');\n        vMin[0] = vMin[0].replace('-', '');\n        settings.mIntPos = Math.max(vMax[0].length, 1);\n        settings.mIntNeg = Math.max(vMin[0].length, 1);\n        if (settings.mDec === null) {\n            settings.mDec = decLength(vMin, vMax);\n            settings.oDec = settings.mDec;\n        } else {\n            settings.mDec = Number(settings.mDec);\n        }\n        if (settings.scaleDecimal) {\n            settings.mDec = settings.scaleDecimal;\n        }\n\n        // set alternative decimal separator key\n        if (settings.altDec === null && settings.mDec > 0) {\n            if (settings.aDec === '.' && settings.aSep !== ',') {\n                settings.altDec = ',';\n            } else if (settings.aDec === ',' && settings.aSep !== '.') {\n                settings.altDec = '.';\n            }\n        }\n\n        // cache regexps for autoStrip\n        var aNegReg = settings.aNeg ? '([-\\\\' + settings.aNeg + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + (settings.aNeg ? '\\\\' + settings.aNeg : '') + '\\\\' + settings.aDec + '\\\\d].*?(\\\\d|\\\\' + settings.aDec + '\\\\d)');\n        settings.skipLastAutoStrip = new RegExp('(\\\\d\\\\' + settings.aDec + '?)[^\\\\' + settings.aDec + '\\\\d]\\\\D*$');\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.aDec + '?(\\\\d+\\\\' + settings.aDec + '\\\\d+)|(\\\\d*(?:\\\\' + settings.aDec + '\\\\d*)?))');\n\n        return settings;\n    }\n\n    /**\n     * strip all unwanted characters and leave only a number alert\n     */\n    function autoStrip(s, settings) {\n        if (settings.aSign !== '') {\n            // remove currency sign\n            s = s.replace(settings.aSign, '');\n        }\n        if (settings.aSuffix) {\n            // remove suffix\n            while (contains(s, settings.aSuffix)) {\n                s = s.replace(settings.aSuffix, '');\n            }\n        }\n\n        // first replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && contains(s, '-') && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // then remove any uninterested characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.altDec) {\n            s = s.replace(settings.altDec, settings.aDec);\n        }\n\n        // get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n        if (settings.lZero === 'allow' || settings.lZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.aDec),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.aNeg)) {\n                nSign = settings.aNeg;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.aNeg, '');\n            }\n\n            // strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.aDec + decimalPart);\n        }\n        if (settings.onOff && settings.lZero === 'deny' || settings.lZero === 'allow' && settings.onOff === false) {\n            // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n            var stripReg = '^' + settings.aNegRegAutoStrip + '0*(\\\\d)';\n            stripReg = new RegExp(stripReg);\n            s = s.replace(stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * places or removes brackets on negative values\n     */\n    function negativeBracket(s, settings) {\n        if (settings.pSign === 'p' && settings.pNeg === 'l' || settings.pSign === 's' && settings.pNeg === 'p') {\n            var _settings$nBracket$sp = settings.nBracket.split(','),\n                _settings$nBracket$sp2 = _slicedToArray(_settings$nBracket$sp, 2),\n                firstBracket = _settings$nBracket$sp2[0],\n                lastBracket = _settings$nBracket$sp2[1];\n\n            if (!settings.onOff) {\n                s = s.replace(settings.aNeg, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.onOff && s.charAt(0) === firstBracket) {\n                s = s.replace(firstBracket, settings.aNeg);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * convert locale format to Javascript numeric string\n     * allows locale decimal separator to be a period or comma - no thousand separator allowed of currency signs allowed\n     * '1234.56'    OK\n     * '-1234.56'   OK\n     * '1234.56-'   OK\n     * '1234,56'    OK\n     * '-1234,56'   OK\n     * '1234,56-'   OK\n     */\n    function fromLocale(s) {\n        s = s.replace(',', '.');\n        if (contains(s, '-') && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        return s;\n    }\n\n    /**\n     * converts the ISO numeric string to the locale decimal and minus sign placement\n     * see \"localeOutput\" option for determine\n     * null => nnnn.nn or -nnnn.nn default\n     * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n     * \".-\" => nnnn.nn or nnnn.nn-\n     * \",-\" => nnnn,nn or nnnn,nn-\n     */\n    function toLocale(value, locale) {\n        if (locale === '.-') {\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n        if (locale === ',' || locale === '-,') {\n            value = value.replace('.', ',');\n        }\n        if (locale === ',-') {\n            value = value.replace('.', ',');\n            value = contains(value, '-') ? value.replace('-', '') + '-' : value;\n        }\n\n        return value;\n    }\n\n    /**\n     * prepare number string to be converted to real number\n     */\n    function fixNumber(s, aDec, aNeg) {\n        if (aDec && aDec !== '.') {\n            s = s.replace(aDec, '.');\n        }\n        if (aNeg && aNeg !== '-') {\n            s = s.replace(aNeg, '-');\n        }\n        if (!s.match(/\\d/)) {\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * prepare real number to be converted to our format\n     */\n    function presentNumber(s, settings) {\n        if (settings.aNeg && settings.aNeg !== '-') {\n            s = s.replace('-', settings.aNeg);\n        }\n        if (settings.aDec && settings.aDec !== '.') {\n            s = s.replace('.', settings.aDec);\n        }\n\n        return s;\n    }\n\n    /**\n     * private function to check for empty value\n     */\n    function checkEmpty(iv, settings, signOnEmpty) {\n        if (iv === '' || iv === settings.aNeg) {\n            if (settings.wEmpty === 'always' || signOnEmpty) {\n                return settings.pNeg === 'l' ? iv + settings.aSign + settings.aSuffix : settings.aSign + iv + settings.aSuffix;\n            }\n            return iv;\n        }\n\n        return null;\n    }\n\n    /**\n     * private function that formats our number\n     */\n    function autoGroup(iv, settings) {\n        if (settings.strip) {\n            iv = autoStrip(iv, settings);\n        }\n        if (settings.trailingNegative && !contains(iv, '-')) {\n            iv = '-' + iv;\n        }\n        var empty = checkEmpty(iv, settings, true);\n        var isNeg = contains(iv, '-');\n        if (isNeg) {\n            iv = iv.replace('-', '');\n        }\n        if (empty !== null) {\n            return empty;\n        }\n        var digitalGroup = '';\n        settings.dGroup = settings.dGroup.toString();\n        if (settings.dGroup === '2') {\n            digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n        } else if (settings.dGroup === '2s') {\n            digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n        } else if (settings.dGroup === '4') {\n            digitalGroup = /(\\d)((\\d{4}?)+)$/;\n        } else {\n            digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // splits the string at the decimal string\n\n        var _iv$split = iv.split(settings.aDec),\n            _iv$split2 = _slicedToArray(_iv$split, 2),\n            integerPart = _iv$split2[0],\n            decimalPart = _iv$split2[1];\n\n        if (settings.altDec && isUndefined(decimalPart)) {\n            var _iv$split3 = iv.split(settings.altDec);\n\n            var _iv$split4 = _slicedToArray(_iv$split3, 2);\n\n            integerPart = _iv$split4[0];\n            decimalPart = _iv$split4[1];\n        }\n        if (settings.aSep !== '') {\n            // re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.aSep + '$2');\n            }\n        }\n        if (settings.mDec !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.mDec) {\n                decimalPart = decimalPart.substring(0, settings.mDec);\n            }\n\n            // joins the whole number with the decimal value\n            iv = integerPart + settings.aDec + decimalPart;\n        } else {\n            // if whole numbers only\n            iv = integerPart;\n        }\n        if (settings.pSign === 'p') {\n            if (isNeg && settings.pNeg === 'l') {\n                iv = settings.aNeg + settings.aSign + iv;\n            }\n            if (isNeg && settings.pNeg === 'r') {\n                iv = settings.aSign + settings.aNeg + iv;\n            }\n            if (isNeg && settings.pNeg === 's') {\n                iv = settings.aSign + iv + settings.aNeg;\n            }\n            if (!isNeg) {\n                iv = settings.aSign + iv;\n            }\n        }\n        if (settings.pSign === 's') {\n            if (isNeg && settings.pNeg === 'r') {\n                iv = iv + settings.aSign + settings.aNeg;\n            }\n            if (isNeg && settings.pNeg === 'l') {\n                iv = iv + settings.aNeg + settings.aSign;\n            }\n            if (isNeg && settings.pNeg === 'p') {\n                iv = settings.aNeg + iv + settings.aSign;\n            }\n            if (!isNeg) {\n                iv = iv + settings.aSign;\n            }\n        }\n\n        // removes the negative sign and places brackets\n        if (settings.nBracket !== null && (settings.rawValue < 0 || iv.charAt(0) === '-')) {\n            iv = negativeBracket(iv, settings);\n        }\n        settings.trailingNegative = false;\n\n        return iv + settings.aSuffix;\n    }\n\n    /**\n     * Truncate not needed zeros\n     */\n    function truncateZeros(ivRounded, rDec) {\n        var regex = void 0;\n        switch (rDec) {\n            case 0:\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                regex = new RegExp('(\\\\.\\\\d{' + rDec + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        ivRounded = ivRounded.replace(regex, '$1');\n        if (rDec === 0) {\n            ivRounded = ivRounded.replace(/\\.$/, '');\n        }\n\n        return ivRounded;\n    }\n\n    /**\n     * round number after setting by pasting or $().autoNumericSet()\n     * private function for round the number\n     * please note this handled as text - JavaScript math function can return inaccurate values\n     * also this offers multiple rounding methods that are not easily accomplished in JavaScript\n     */\n    function autoRound(iv, settings) {\n        // value to string\n        iv = iv === '' ? '0' : iv.toString();\n        if (settings.mRound === 'N05' || settings.mRound === 'CHF' || settings.mRound === 'U05' || settings.mRound === 'D05') {\n            switch (settings.mRound) {\n                case 'N05':\n                    iv = (Math.round(iv * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    iv = (Math.ceil(iv * 20) / 20).toString();\n                    break;\n                default:\n                    iv = (Math.floor(iv * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(iv, '.')) {\n                result = iv + '.00';\n            } else if (iv.length - iv.indexOf('.') < 3) {\n                result = iv + '0';\n            } else {\n                result = iv;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var rDec = void 0;\n\n        if (typeof settings.aPad === 'boolean' || settings.aPad === null) {\n            rDec = settings.aPad ? settings.mDec : 0;\n        } else {\n            rDec = Number(settings.aPad);\n        }\n\n        // Checks if the iv (input Value)is a negative value\n        if (iv.charAt(0) === '-') {\n            nSign = '-';\n\n            // removes the negative sign will be added back later if required\n            iv = iv.replace('-', '');\n        }\n\n        // append a zero if first character is not a digit (then it is likely to be a dot\n        if (!iv.match(/^\\d/)) {\n            iv = '0' + iv;\n        }\n\n        // determines if the value is zero - if zero no negative sign\n        if (nSign === '-' && Number(iv) === 0) {\n            nSign = '';\n        }\n\n        // trims leading zero's needed\n        if (Number(iv) > 0 && settings.lZero !== 'keep' || iv.length > 0 && settings.lZero === 'allow') {\n            iv = iv.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = iv.lastIndexOf('.');\n\n        // virtual decimal position\n        var vdPos = dPos === -1 ? iv.length - 1 : dPos;\n\n        // checks decimal places to determine if rounding is required :\n        // check if no rounding is required\n        var cDec = iv.length - 1 - vdPos;\n        if (cDec <= settings.mDec) {\n            // check if we need to pad with zeros\n            ivRounded = iv;\n            if (cDec < rDec) {\n                if (dPos === -1) {\n                    ivRounded += settings.aDec;\n                }\n                var zeros = '000000';\n                while (cDec < rDec) {\n                    zeros = zeros.substring(0, rDec - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > rDec) {\n                ivRounded = truncateZeros(ivRounded, rDec);\n            } else if (cDec === 0 && rDec === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // rounded length of the string after rounding\n        var rLength = dPos + settings.mDec; //TODO Modify `dPos` here if it's not intended that it can be equal to '-1'\n        var tRound = Number(iv.charAt(rLength + 1));\n        var odd = iv.charAt(rLength) === '.' ? iv.charAt(rLength - 1) % 2 : iv.charAt(rLength) % 2;\n        var ivArray = iv.substring(0, rLength + 1).split('');\n        if (tRound > 4 && settings.mRound === 's' || // Round half up symmetric\n        tRound > 4 && settings.mRound === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.mRound === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.mRound === 's' || // Round half down symmetric\n        tRound > 5 && settings.mRound === 'A' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.mRound === 'A' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.mRound === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.mRound === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.mRound === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.mRound === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.mRound === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // return rounded value\n        ivRounded = truncateZeros(ivArray.join(''), rDec);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * truncates the decimal part of a number\n     */\n    function truncateDecimal(s, settings, paste) {\n        var aDec = settings.aDec;\n        var mDec = settings.mDec;\n        s = paste === 'paste' ? autoRound(s, settings) : s;\n        if (aDec && mDec) {\n            var _s$split3 = s.split(aDec),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > mDec) {\n                if (mDec > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, mDec);\n                    s = '' + integerPart + aDec + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse vMin, vMax & the input value to prepare for testing to determine if the value falls within the min / max range\n     * Return an object example: vMin: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\"\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function parseStr(n) {\n        var x = {};\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (n.charAt(0) === '-') {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings\n     * This uses the parsed strings for the above parseStr function\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/\n     * Many thanks to Mike\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * checking that number satisfy format conditions\n     * and lays between settings.vMin and settings.vMax\n     * and the string length does not exceed the digits in settings.vMin and settings.vMax\n     */\n    function autoCheck(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.vMin);\n        var maxParse = parseStr(settings.vMax);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.oLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * thanks to Anthony & Evan C\n     */\n    function autoGet(obj) {\n        if (typeof obj === 'string' || obj instanceof String) {\n            obj = obj.replace(/\\[/g, '\\\\[').replace(/]/g, '\\\\]');\n            obj = '#' + obj.replace(/(:|\\.)/g, '\\\\$1');\n            // possible modification to replace the above 2 lines\n            // obj = '#' + obj.replace(/([;&,\\.\\+\\*\\~':\"\\!\\^#$%@\\[\\]\\(\\)=>\\|])/g, '\\\\$1');\n        }\n\n        return $(obj);\n    }\n\n    /**\n     * function to attach data to the element\n     * and imitate the holder\n     */\n    function getHolder($that, settings, update) {\n        var data = $that.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $that.data('autoNumeric', data);\n        }\n        var holder = data.holder;\n        if (isUndefined(holder) && settings || update) {\n            holder = new AutoNumericHolder($that.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     */\n    function originalSettings(settings) {\n        settings.oDec = settings.mDec;\n        settings.oPad = settings.aPad;\n        settings.oBracket = settings.nBracket;\n        settings.oSep = settings.aSep;\n        settings.oSign = settings.aSign;\n\n        return settings;\n    }\n\n    /**\n     * original settings saved for use when eDec & nSep options are being used\n     * taken from Quirksmode\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported - taken from modernizr\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * creates or removes sessionStorage or cookie depending on browser support\n     */\n    function autoSave($this, settings, toDo) {\n        if (settings.aStor) {\n            var storedName = $this[0].name !== '' && !isUndefined($this[0].name) ? 'AUTO_' + decodeURIComponent($this[0].name) : 'AUTO_' + $this[0].id;\n            var date = void 0;\n            var expires = void 0;\n\n            // sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (toDo) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (toDo) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n    function AutoNumericHolder(that, settings) {\n        this.settings = settings;\n        this.that = that;\n        this.$that = $(that);\n        this.formatted = false;\n        this.settingsClone = autoCode(this.$that, this.settings);\n        this.value = that.value;\n    }\n\n    AutoNumericHolder.prototype = {\n        init: function init(e) {\n            this.value = this.that.value;\n            this.settingsClone = autoCode(this.$that, this.settings);\n            this.ctrlKey = e.ctrlKey;\n            this.cmdKey = e.metaKey;\n            this.shiftKey = e.shiftKey;\n\n            // keypress event overwrites meaningful value of e.keyCode\n            this.selection = getElementSelection(this.that);\n            if (e.type === 'keydown' || e.type === 'keyup') {\n                this.kdCode = e.keyCode;\n            }\n            this.which = e.which;\n            this.processed = false;\n            this.formatted = false;\n        },\n        setSelection: function setSelection(start, end, setReal) {\n            start = Math.max(start, 0);\n            end = Math.min(end, this.that.value.length);\n            this.selection = {\n                start: start,\n                end: end,\n                length: end - start\n            };\n            if (isUndefined(setReal) || setReal) {\n                setElementSelection(this.that, start, end);\n            }\n        },\n        setPosition: function setPosition(pos, setReal) {\n            this.setSelection(pos, pos, setReal);\n        },\n        getBeforeAfter: function getBeforeAfter() {\n            var value = this.value;\n            var left = value.substring(0, this.selection.start);\n            var right = value.substring(this.selection.end, value.length);\n\n            return [left, right];\n        },\n        getBeforeAfterStriped: function getBeforeAfterStriped() {\n            var settingsClone = this.settingsClone;\n\n            var _getBeforeAfter = this.getBeforeAfter(),\n                _getBeforeAfter2 = _slicedToArray(_getBeforeAfter, 2),\n                left = _getBeforeAfter2[0],\n                right = _getBeforeAfter2[1];\n\n            left = autoStrip(left, this.settingsClone);\n            right = autoStrip(right, this.settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                right = right === '-' ? '' : right;\n            }\n            settingsClone.trailingNegative = false;\n\n            return [left, right];\n        },\n\n\n        /**\n         * strip parts from excess characters and leading zeroes\n         */\n        normalizeParts: function normalizeParts(left, right) {\n            var settingsClone = this.settingsClone;\n\n            // prevents multiple leading zeros from being entered\n            left = autoStrip(left, settingsClone);\n\n            // if right is not empty and first character is not aDec,\n            right = autoStrip(right, settingsClone);\n            if (settingsClone.trailingNegative && !contains(left, '-')) {\n                left = '-' + left;\n                settingsClone.trailingNegative = false;\n            }\n            if ((left === '' || left === settingsClone.aNeg) && settingsClone.lZero === 'deny') {\n                if (right > '') {\n                    right = right.replace(/^0*(\\d)/, '$1');\n                }\n            }\n\n            // insert zero if has leading dot\n            this.newValue = left + right;\n            if (settingsClone.aDec) {\n                var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.aDec));\n                if (m) {\n                    left = left.replace(m[1], m[1] + '0');\n                    this.newValue = left + right;\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * set part of number to value keeping position of cursor\n         */\n        setValueParts: function setValueParts(left, right, advent) {\n            var settingsClone = this.settingsClone;\n            var parts = this.normalizeParts(left, right);\n\n            var _autoCheck = autoCheck(this.newValue, settingsClone),\n                _autoCheck2 = _slicedToArray(_autoCheck, 2),\n                minTest = _autoCheck2[0],\n                maxTest = _autoCheck2[1];\n\n            var position = parts[0].length;\n            this.newValue = parts.join('');\n            if (minTest && maxTest) {\n                this.newValue = truncateDecimal(this.newValue, settingsClone, advent);\n                var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                if (testValue === '' || testValue === settingsClone.aNeg) {\n                    settingsClone.rawValue = '';\n                } else {\n                    settingsClone.rawValue = testValue;\n                }\n                if (position > this.newValue.length) {\n                    position = this.newValue.length;\n                }\n                this.value = this.newValue;\n                this.setPosition(position, false);\n                return true;\n            }\n            if (!minTest) {\n                this.$that.trigger('autoNumeric:minExceeded');\n            } else if (!maxTest) {\n                this.$that.trigger('autoNumeric:maxExceeded');\n            }\n\n            return false;\n        },\n\n\n        /**\n         * helper function for expandSelectionOnSign\n         * returns sign position of a formatted value\n         */\n        signPosition: function signPosition() {\n            var settingsClone = this.settingsClone;\n            var aSign = settingsClone.aSign;\n            var that = this.that;\n            if (aSign) {\n                var aSignLen = aSign.length;\n                if (settingsClone.pSign === 'p') {\n                    var hasNeg = settingsClone.aNeg && that.value && that.value.charAt(0) === settingsClone.aNeg;\n                    return hasNeg ? [1, aSignLen + 1] : [0, aSignLen];\n                }\n                var valueLen = that.value.length;\n                return [valueLen - aSignLen, valueLen];\n            }\n\n            return [1000, -1];\n        },\n\n\n        /**\n         * expands selection to cover whole sign\n         * prevents partial deletion/copying/overwriting of a sign\n         */\n        expandSelectionOnSign: function expandSelectionOnSign(setReal) {\n            var signPosition = this.signPosition();\n            var selection = this.selection;\n\n            // if selection catches something except sign and catches only space from sign\n            if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                // then select without empty space\n                if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                    if (selection.start < signPosition[0]) {\n                        this.setSelection(selection.start, signPosition[0], setReal);\n                    } else {\n                        this.setSelection(signPosition[1], selection.end, setReal);\n                    }\n                } else {\n                    // else select with whole sign\n                    this.setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                }\n            }\n        },\n\n\n        /**\n         * try to strip pasted value to digits\n         */\n        checkPaste: function checkPaste() {\n            if (!isUndefined(this.valuePartsBeforePaste)) {\n                var oldParts = this.valuePartsBeforePaste;\n\n                var _getBeforeAfter3 = this.getBeforeAfter(),\n                    _getBeforeAfter4 = _slicedToArray(_getBeforeAfter3, 2),\n                    left = _getBeforeAfter4[0],\n                    right = _getBeforeAfter4[1];\n\n                // try to strip pasted value first\n\n\n                delete this.valuePartsBeforePaste;\n                var modifiedLeftPart = left.substr(0, oldParts[0].length) + autoStrip(left.substr(oldParts[0].length), this.settingsClone);\n                if (!this.setValueParts(modifiedLeftPart, right, 'paste')) {\n                    this.value = oldParts.join('');\n                    this.setPosition(oldParts[0].length, false);\n                }\n            }\n        },\n\n\n        /**\n         * process pasting, cursor moving and skipping of not interesting keys\n         * if returns true, further processing is not performed\n         */\n        skipAlways: function skipAlways(e) {\n            var kdCode = this.kdCode;\n            var which = this.which;\n            var ctrlKey = this.ctrlKey;\n            var cmdKey = this.cmdKey;\n\n            // catch the ctrl up on ctrl-v\n            var shiftKey = this.shiftKey;\n            if ((ctrlKey || cmdKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || shiftKey && kdCode === keyCode.Insert) {\n                this.checkPaste();\n                return false;\n            }\n\n            // skip Fx keys, windows keys, other special keys\n            if (kdCode >= keyCode.F1 && kdCode <= keyCode.F12 || kdCode >= keyCode.Windows && kdCode <= keyCode.RightClick || kdCode >= keyCode.Tab && kdCode < keyCode.Space || kdCode < keyCode.Backspace && (which === 0 || which === kdCode) || kdCode === keyCode.NumLock || kdCode === keyCode.ScrollLock || kdCode === keyCode.Insert || kdCode === keyCode.Command) {\n                return true;\n            }\n\n            // if select all (a)\n            if ((ctrlKey || cmdKey) && kdCode === keyCode.a) {\n                if (this.settings.sNumber) {\n                    e.preventDefault();\n                    var valueLen = this.that.value.length;\n                    var aSignLen = this.settings.aSign.length;\n                    var negLen = !contains(this.that.value, '-') ? 0 : 1;\n                    var aSuffixLen = this.settings.aSuffix.length;\n                    var pSign = this.settings.pSign;\n                    var pNeg = this.settings.pNeg;\n\n                    var start = void 0;\n                    if (pSign === 's') {\n                        start = 0;\n                    } else {\n                        start = pNeg === 'l' && negLen === 1 && aSignLen > 0 ? aSignLen + 1 : aSignLen;\n                    }\n\n                    var end = void 0;\n                    if (pSign === 'p') {\n                        end = valueLen - aSuffixLen;\n                    } else {\n                        switch (pNeg) {\n                            case 'l':\n                                end = valueLen - (aSuffixLen + aSignLen);\n                                break;\n                            case 'r':\n                                end = aSignLen > 0 ? valueLen - (aSignLen + negLen + aSuffixLen) : valueLen - (aSignLen + aSuffixLen);\n                                break;\n                            default:\n                                end = valueLen - (aSignLen + aSuffixLen);\n                        }\n                    }\n\n                    setElementSelection(this.that, start, end);\n                }\n                return true;\n            }\n\n            // if copy (c)\n            if ((ctrlKey || cmdKey) && (kdCode === keyCode.c || kdCode === keyCode.v || kdCode === keyCode.x)) {\n                if (e.type === 'keydown') {\n                    this.expandSelectionOnSign();\n                }\n\n                // try to prevent wrong paste\n                if (kdCode === keyCode.v || kdCode === keyCode.Insert) {\n                    if (e.type === 'keydown' || e.type === 'keypress') {\n                        if (isUndefined(this.valuePartsBeforePaste)) {\n                            this.valuePartsBeforePaste = this.getBeforeAfter();\n                        }\n                    } else {\n                        this.checkPaste();\n                    }\n                }\n                return e.type === 'keydown' || e.type === 'keypress' || kdCode === keyCode.c;\n            }\n\n            if (ctrlKey || cmdKey) {\n                return true;\n            }\n\n            // jump over thousand separator\n            if (kdCode === keyCode.LeftArrow || kdCode === keyCode.RightArrow) {\n                var aSep = this.settingsClone.aSep;\n                var aDec = this.settingsClone.aDec;\n                var startJump = this.selection.start;\n                var value = this.that.value;\n                if (e.type === 'keydown' && !this.shiftKey) {\n                    if (kdCode === keyCode.LeftArrow && (value.charAt(startJump - 2) === aSep || value.charAt(startJump - 2) === aDec)) {\n                        this.setPosition(startJump - 1);\n                    } else if (kdCode === keyCode.RightArrow && (value.charAt(startJump + 1) === aSep || value.charAt(startJump + 1) === aDec)) {\n                        this.setPosition(startJump + 1);\n                    }\n                }\n                return true;\n            }\n\n            return kdCode >= keyCode.PageDown && kdCode <= keyCode.DownArrow;\n        },\n\n\n        /**\n         * process deletion of characters when the minus sign is to the right of the numeric characters\n         */\n        processTrailing: function processTrailing(_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                left = _ref2[0],\n                right = _ref2[1];\n\n            var settingsClone = this.settingsClone;\n            if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's') {\n                if (this.kdCode === 8) {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.value.charAt(this.selection.start - 1) === '-') {\n                        left = left.substring(1);\n                    } else if (this.selection.start <= this.value.length - settingsClone.aSuffix.length) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSuffix) && settingsClone.aSuffix !== '');\n                    if (this.selection.start >= this.value.indexOf(settingsClone.aSign) + settingsClone.aSign.length) {\n                        right = right.substring(1, right.length);\n                    }\n                    if (contains(left, '-') && this.value.charAt(this.selection.start) === '-') {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.aNeg) || !contains(this.value, settingsClone.aNeg))) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    if (left[0] === '-') {\n                        right = right.substring(1);\n                    }\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) && contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                }\n            }\n\n            if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r') {\n                settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length);\n                if (this.kdCode === 8) {\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg) + settingsClone.aNeg.length) {\n                        left = left.substring(1);\n                    } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.aNeg) - settingsClone.aSign.length) {\n                        left = left.substring(0, left.length - 1);\n                    } else if (left !== '' && !contains(this.value, settingsClone.aNeg)) {\n                        left = left.substring(0, left.length - 1);\n                    }\n                } else {\n                    settingsClone.caretFix = Boolean(this.selection.start >= this.value.indexOf(settingsClone.aSign) && settingsClone.aSign !== '');\n                    if (this.selection.start === this.value.indexOf(settingsClone.aNeg)) {\n                        left = left.substring(1);\n                    }\n                    right = right.substring(1);\n                }\n            }\n\n            return [left, right];\n        },\n\n\n        /**\n         * process deletion of characters\n         * returns true if processing performed\n         */\n        processAlways: function processAlways() {\n            var settingsClone = this.settingsClone;\n            if (this.kdCode === keyCode.Backspace || this.kdCode === keyCode.Delete) {\n                var left = void 0;\n                var right = void 0;\n                if (!this.selection.length) {\n                    var _getBeforeAfterStripe = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe2 = _slicedToArray(_getBeforeAfterStripe, 2);\n\n                    left = _getBeforeAfterStripe2[0];\n                    right = _getBeforeAfterStripe2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n                    if ((settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && (settingsClone.pNeg === 'l' || settingsClone.pNeg === 'r')) && contains(this.value, '-')) {\n                        var _processTrailing = this.processTrailing([left, right]);\n\n                        var _processTrailing2 = _slicedToArray(_processTrailing, 2);\n\n                        left = _processTrailing2[0];\n                        right = _processTrailing2[1];\n                    } else {\n                        if (this.kdCode === 8) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                    this.setValueParts(left, right);\n                } else {\n                    this.expandSelectionOnSign(false);\n\n                    var _getBeforeAfterStripe3 = this.getBeforeAfterStriped();\n\n                    var _getBeforeAfterStripe4 = _slicedToArray(_getBeforeAfterStripe3, 2);\n\n                    left = _getBeforeAfterStripe4[0];\n                    right = _getBeforeAfterStripe4[1];\n\n                    this.setValueParts(left, right);\n                }\n                return true;\n            }\n\n            return false;\n        },\n\n\n        /**\n         * process insertion of characters\n         * returns true if processing performed\n         */\n        processKeypress: function processKeypress() {\n            var settingsClone = this.settingsClone;\n            var cCode = String.fromCharCode(this.which);\n\n            var _getBeforeAfterStripe5 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe6 = _slicedToArray(_getBeforeAfterStripe5, 2),\n                left = _getBeforeAfterStripe6[0],\n                right = _getBeforeAfterStripe6[1];\n\n            settingsClone.throwInput = true;\n\n            // start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n            // do not allow decimal character if no decimal part allowed\n            if (cCode === settingsClone.aDec || settingsClone.altDec && cCode === settingsClone.altDec || (cCode === '.' || cCode === ',') && this.kdCode === keyCode.DotNumpad) {\n                if (!settingsClone.mDec || !settingsClone.aDec) {\n                    return true;\n                }\n\n                // do not allow decimal character before aNeg character\n                if (settingsClone.aNeg && contains(right, settingsClone.aNeg)) {\n                    return true;\n                }\n\n                // do not allow decimal character if other decimal character present\n                if (contains(left, settingsClone.aDec)) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) > 0) {\n                    return true;\n                }\n                if (right.indexOf(settingsClone.aDec) === 0) {\n                    right = right.substr(1);\n                }\n                this.setValueParts(left + settingsClone.aDec, right, null);\n                return true;\n            }\n\n            // prevent minus if not allowed\n            if ((cCode === '-' || cCode === '+') && settingsClone.aNeg === '-') {\n                if (!settingsClone) {\n                    return true;\n                }\n\n                // caret is always after minus\n                if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === '-' || contains(left, settingsClone.aNeg)) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                } else {\n                    if (left === '' && contains(right, settingsClone.aNeg)) {\n                        left = settingsClone.aNeg;\n                        right = right.substring(1, right.length);\n                    }\n\n                    // change sign of number, remove part if should\n                    if (left.charAt(0) === settingsClone.aNeg) {\n                        left = left.substring(1, left.length);\n                    } else {\n                        left = cCode === '-' ? settingsClone.aNeg + left : left;\n                    }\n                }\n                this.setValueParts(left, right, null);\n                return true;\n            }\n\n            // if try to insert digit before minus\n            if (cCode >= '0' && cCode <= '9') {\n                if (settingsClone.aNeg && left === '' && contains(right, settingsClone.aNeg)) {\n                    left = settingsClone.aNeg;\n                    right = right.substring(1, right.length);\n                }\n                if (settingsClone.vMax <= 0 && settingsClone.vMin < settingsClone.vMax && !contains(this.value, settingsClone.aNeg) && cCode !== '0') {\n                    left = settingsClone.aNeg + left;\n                }\n                this.setValueParts(left + cCode, right, null);\n                return true;\n            }\n\n            // prevent any other character\n            settingsClone.throwInput = false;\n\n            return true;\n        },\n\n\n        /**\n         * formatting of just processed value with keeping of cursor position\n         */\n        formatQuick: function formatQuick(e) {\n            var _this = this;\n\n            var settingsClone = this.settingsClone;\n            var leftLength = this.value;\n            var kuCode = e.keyCode;\n\n            var _getBeforeAfterStripe7 = this.getBeforeAfterStriped(),\n                _getBeforeAfterStripe8 = _slicedToArray(_getBeforeAfterStripe7, 1),\n                left = _getBeforeAfterStripe8[0];\n\n            // no grouping separator and no currency sign\n\n\n            if ((settingsClone.aSep === '' || settingsClone.aSep !== '' && !contains(leftLength, settingsClone.aSep)) && (settingsClone.aSign === '' || settingsClone.aSign !== '' && !contains(leftLength, settingsClone.aSign))) {\n                var _leftLength$split = leftLength.split(settingsClone.aDec),\n                    _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                    subParts = _leftLength$split2[0];\n\n                var nSign = '';\n                if (contains(subParts, '-')) {\n                    nSign = '-';\n                    subParts = subParts.replace('-', '');\n                    left = left.replace('-', '');\n                }\n\n                // strip leading zero on positive value if need\n                if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n\n                // strip leading zero on negative value if need\n                if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                    left = left.slice(1);\n                }\n                left = nSign + left;\n            }\n\n            var value = autoGroup(this.value, this.settingsClone);\n            var position = value.length;\n            if (value) {\n                // prepare regexp which searches for cursor position from unformatted left part\n                var leftAr = left.split('');\n\n                // fixes caret position with trailing minus sign\n                if ((settingsClone.pNeg === 's' || settingsClone.pSign === 's' && settingsClone.pNeg !== 'p') && leftAr[0] === '-' && settingsClone.aNeg !== '') {\n                    leftAr.shift();\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'l' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 'p' && settingsClone.pNeg === 's' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        leftAr.push('-');\n                        settingsClone.caretFix = Boolean(e.type === 'keydown');\n                    }\n                    if (settingsClone.pSign === 's' && settingsClone.pNeg === 'r' && (kuCode === keyCode.Backspace || this.kdCode === keyCode.Backspace || kuCode === keyCode.Delete || this.kdCode === keyCode.Delete) && settingsClone.caretFix) {\n                        (function () {\n                            var signParts = settingsClone.aSign.split('');\n                            var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                            var escapedParts = [];\n                            $.each(signParts, function (i, miniParts) {\n                                miniParts = signParts[i];\n                                if (isInArray(miniParts, escapeChr)) {\n                                    escapedParts.push('\\\\' + miniParts);\n                                } else {\n                                    escapedParts.push(miniParts);\n                                }\n                            });\n                            if (kuCode === keyCode.Backspace || _this.kdCode === keyCode.Backspace) {\n                                escapedParts.push('-');\n                            }\n\n                            // pushing the escaped sign\n                            leftAr.push(escapedParts.join(''));\n                            settingsClone.caretFix = Boolean(e.type === 'keydown');\n                        })();\n                    }\n                }\n\n                for (var i = 0; i < leftAr.length; i++) {\n                    if (!leftAr[i].match('\\\\d')) {\n                        leftAr[i] = '\\\\' + leftAr[i];\n                    }\n                }\n\n                var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                // search cursor position in formatted value\n                var newLeft = value.match(leftReg);\n                if (newLeft) {\n                    position = newLeft[0].length;\n\n                    // if we are just before sign which is in prefix position\n                    if ((position === 0 && value.charAt(0) !== settingsClone.aNeg || position === 1 && value.charAt(0) === settingsClone.aNeg) && settingsClone.aSign && settingsClone.pSign === 'p') {\n                        // place caret after prefix sign\n                        position = this.settingsClone.aSign.length + (value.charAt(0) === '-' ? 1 : 0);\n                    }\n                } else {\n                    if (settingsClone.aSign && settingsClone.pSign === 's') {\n                        // if we could not find a place for cursor and have a sign as a suffix\n                        // place caret before suffix currency sign\n                        position -= settingsClone.aSign.length;\n                    }\n                    if (settingsClone.aSuffix) {\n                        // if we could not find a place for cursor and have a suffix\n                        // place caret before suffix\n                        position -= settingsClone.aSuffix.length;\n                    }\n                }\n            }\n            this.that.value = value;\n            this.setPosition(position);\n            this.formatted = true;\n        }\n    };\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @returns {*}\n     * @private\n     */\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = autoGet($(that));\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = $.inArray(i, scIndex);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('get', settings.localeOutput).toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = $.inArray(i, scIndex);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('get', settings.localeOutput).toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initiate autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // initiate autoNumeric with options\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n\n                // attempt to grab HTML5 data, if they don't exist we'll get \"undefined\"\n                var tagData = $this.data();\n\n                // supported input type\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                // attempt to grab \"autoNumeric\" settings, if they don't exist returns \"undefined\"\n                var settings = $this.data('autoNumeric');\n\n                // If we couldn't grab settings, create them from defaults and passed options\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    settings = $.extend({}, $.fn.autoNumeric.defaults, tagData, options, {\n                        onOff: false,\n                        runOnce: false,\n                        rawValue: '',\n                        trailingNegative: false,\n                        caretFix: false,\n                        throwInput: true,\n                        strip: true,\n                        tagList: ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u']\n                    });\n\n                    // Merge defaults, tagData and options\n                    if (settings.aDec === settings.aSep) {\n                        throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                    }\n\n                    $.each(settings, function (key, value) {\n                        if (value === 'true' || value === 'false') {\n                            settings[key] = Boolean(value === 'true');\n                        }\n                        if (typeof value === 'number' && key !== 'aScale') {\n                            settings[key] = value.toString();\n                        }\n                    });\n\n                    if (settings.aScale !== null) {\n                        settings.scaleFactor = +settings.aScale[0];\n                        settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                        settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                    }\n\n                    // Save our new settings\n                    $this.data('autoNumeric', settings);\n                } else {\n                    return this;\n                }\n\n                // original settings saved for use when eDec & nSep options are being used\n                settings = originalSettings(settings);\n                var holder = getHolder($this, settings);\n\n                // checks for non-supported input types\n                if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n                    throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric', settings.debug);\n                }\n\n                // checks for non-supported tags\n                if (!isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.prop('tagName').toLowerCase() !== 'input') {\n                    throwError('The <' + $this.prop('tagName').toLowerCase() + '> tag is not supported by autoNumeric', settings.debug);\n                }\n\n                //TODO Replace the two next tests with a `validateOptions()` function\n                // checks if the decimal and thousand are characters are the same\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec [' + settings.aDec + '] and the thousand separator aSep [' + settings.aSep + '] are the same character', settings.debug);\n                }\n\n                // checks the extended decimal places \"eDec\" is greater than the normal decimal places \"mDec\"\n                if (settings.eDec < settings.mDec && settings.eDec !== null) {\n                    throwError('autoNumeric will not function properly when the extended decimal places eDec [' + settings.eDec + '] is greater than the mDec [' + settings.mDec + '] value', settings.debug);\n                }\n\n                // routine to format default value on page load\n                if (settings.runOnce === false && settings.aForm) {\n                    var setValue = true;\n                    if ($input) {\n                        var currentValue = $this.val();\n\n                        /*\n                         * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n                         * precedence and should get formatted on init (if that this input value is a valid number and that the\n                         * developer wants it formatted on init (cf. `settings.aForm`)). Note; this is true whatever the developer\n                         * has set for `data-an-default` in the html (asp.net users).\n                         *\n                         * In other words : if `anDefault` is not null, it means the developer is trying to prevent postback problems.\n                         * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n                         * changed the input value, and then it means we should not overwrite his own decision to do so.\n                         * Hence, if `anDefault` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n                         * we should ignore `anDefault` altogether.\n                         */\n                        if (settings.aForm && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                            // Check if the `value` is valid or not\n                            var testedCurrentValue = parseFloat(currentValue.replace(',', '.')); //TODO Replace whatever locale character is used by a '.', and not only the comma ','\n                            if (!isNaN(testedCurrentValue) && Infinity !== testedCurrentValue) {\n                                $this.autoNumeric('set', testedCurrentValue);\n                                setValue = false;\n                            } else {\n                                // If not, inform the developer that nothing usable has been provided\n                                throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.', false);\n                            }\n                        } else {\n                            /* Checks for :\n                             * - page reload from back button, and\n                             * - ASP.net form post back\n                             *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                             *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                             */\n                            //TODO Replace whatever locale character is used by a '.', and not only the comma ',', based on the locale used by the user\n                            if (settings.anDefault !== null && settings.anDefault.toString() !== currentValue || settings.anDefault === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !$.isNumeric(currentValue.replace(',', '.'))) {\n                                if (settings.eDec !== null && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (settings.aScale && settings.aStor) {\n                                    settings.rawValue = autoSave($this, settings, 'get');\n                                }\n                                if (!settings.aStor) {\n                                    var toStrip = void 0;\n                                    if (settings.nBracket !== null && settings.aNeg !== '') {\n                                        settings.onOff = true;\n                                        toStrip = negativeBracket(currentValue, settings);\n                                    } else {\n                                        toStrip = currentValue;\n                                    }\n                                    settings.rawValue = (settings.pNeg === 's' || settings.pSign === 's' && settings.pNeg !== 'p') && settings.aNeg !== '' && contains(currentValue, '-') ? '-' + autoStrip(toStrip, settings) : autoStrip(toStrip, settings);\n                                }\n                                setValue = false;\n                            }\n                        }\n\n                        if (currentValue === '') {\n                            switch (settings.wEmpty) {\n                                case 'focus':\n                                    setValue = false;\n                                    break;\n                                case 'always':\n                                    $this.val(settings.aSign);\n                                    setValue = false;\n                                    break;\n                                case 'zero':\n                                    $this.autoNumeric('set', '0');\n                                    setValue = false;\n                                    break;\n                                default:\n                                //\n                            }\n                        } else if (setValue && currentValue === $this.attr('value')) {\n                            $this.autoNumeric('set', currentValue);\n                        }\n                    }\n\n                    if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n                        if (settings.anDefault !== null) {\n                            if (settings.anDefault === $this.text()) {\n                                $this.autoNumeric('set', $this.text());\n                            }\n                        } else {\n                            $this.autoNumeric('set', $this.text());\n                        }\n                    }\n                }\n\n                settings.runOnce = true;\n\n                //TODO Extract the event listeners to another function\n                // input types supported \"text\", \"hidden\", \"tel\" and no type\n                if ($input) {\n                    $this.on('focusin.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = true;\n                        if ($settings.nBracket !== null && $settings.aNeg !== '') {\n                            $this.val(negativeBracket($this.val(), $settings));\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = '';\n                            $settings.aSign = '';\n                        }\n\n                        var result = void 0;\n                        if ($settings.eDec) {\n                            $settings.mDec = $settings.eDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ($settings.aScale) {\n                            $settings.mDec = $settings.oDec;\n                            $this.autoNumeric('set', $settings.rawValue);\n                        } else if ((result = autoStrip($this.val(), $settings)) !== $settings.rawValue) {\n                            $this.autoNumeric('set', result);\n                        }\n\n                        holder.inVal = $this.val();\n                        holder.lastVal = holder.inVal;\n                        var onEmpty = checkEmpty(holder.inVal, $settings, true);\n                        if (onEmpty !== null && onEmpty !== '' && $settings.wEmpty === 'focus') {\n                            $this.val(onEmpty);\n                        }\n                    });\n\n                    $this.on('keydown.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        if (holder.that.readOnly) {\n                            holder.processed = true;\n                            return true;\n                        }\n\n                        /* // The code below allows the \"enter\" keydown to throw a change() event\n                        if (e.keyCode === keyCode.Enter && holder.inVal !== $this.val()) {\n                            $this.change();\n                            holder.inVal = $this.val();\n                        } */\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            holder.processed = true;\n                            return true;\n                        }\n                        if (holder.processAlways()) {\n                            holder.processed = true;\n                            holder.formatQuick(e);\n                            var _currentValue = $this.val();\n                            if (_currentValue !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event in deletion character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return false;\n                        }\n                        holder.formatted = false;\n                        return true;\n                    });\n\n                    $this.on('keypress.autoNumeric', function (e) {\n                        // Firefox fix for Shift && insert paste event\n                        if (e.shiftKey && e.keyCode === keyCode.Insert) {\n                            return;\n                        }\n                        holder = getHolder($this);\n                        var processed = holder.processed;\n                        holder.init(e);\n                        if (holder.skipAlways(e)) {\n                            return true;\n                        }\n                        if (processed) {\n                            e.preventDefault();\n                            return false;\n                        }\n                        if (holder.processAlways() || holder.processKeypress()) {\n                            holder.formatQuick(e);\n                            var _currentValue2 = $this.val();\n                            if (_currentValue2 !== holder.lastVal && holder.settingsClone.throwInput) {\n                                // throws input event on adding character\n                                $this.trigger('input');\n                            }\n                            holder.lastVal = _currentValue2;\n                            holder.settingsClone.throwInput = true;\n                            e.preventDefault();\n                            return;\n                        }\n                        holder.formatted = false;\n                    });\n\n                    $this.on('keyup.autoNumeric', function (e) {\n                        holder = getHolder($this);\n                        holder.init(e);\n                        var skip = holder.skipAlways(e);\n                        var tab = holder.kdCode;\n                        holder.kdCode = 0;\n                        delete holder.valuePartsBeforePaste;\n\n                        // added to properly place the caret when only the currency sign is present\n                        if ($this[0].value === holder.settingsClone.aSign) {\n                            if (holder.settingsClone.pSign === 's') {\n                                setElementSelection(this, 0, 0);\n                            } else {\n                                setElementSelection(this, holder.settingsClone.aSign.length, holder.settingsClone.aSign.length);\n                            }\n                        } else if (tab === keyCode.Tab) {\n                            setElementSelection(this, 0, $this.val().length);\n                        }\n                        if ($this[0].value === holder.settingsClone.aSuffix) {\n                            setElementSelection(this, 0, 0);\n                        }\n                        if (holder.settingsClone.rawValue === '' && holder.settingsClone.aSign !== '' && holder.settingsClone.aSuffix !== '') {\n                            setElementSelection(this, 0, 0);\n                        }\n\n                        // saves the extended decimal to preserve the data when navigating away from the page\n                        if (holder.settingsClone.eDec !== null && holder.settingsClone.aStor) {\n                            autoSave($this, settings, 'set');\n                        }\n                        if (skip) {\n                            return true;\n                        }\n                        if (this.value === '') {\n                            return true;\n                        }\n                        if (!holder.formatted) {\n                            holder.formatQuick(e);\n                        }\n                    });\n\n                    $this.on('focusout.autoNumeric', function () {\n                        holder = getHolder($this);\n                        var value = $this.val();\n                        var origValue = value;\n                        var $settings = holder.settingsClone;\n                        $settings.onOff = false;\n                        if ($settings.aStor) {\n                            autoSave($this, $settings, 'set');\n                        }\n                        if ($settings.nSep === true) {\n                            $settings.aSep = $settings.oSep;\n                            $settings.aSign = $settings.oSign;\n                        }\n                        if ($settings.eDec !== null) {\n                            $settings.mDec = $settings.oDec;\n                            $settings.aPad = $settings.oPad;\n                            $settings.nBracket = $settings.oBracket;\n                        }\n                        value = autoStrip(value, $settings);\n                        if (value !== '') {\n                            if ($settings.trailingNegative) {\n                                value = '-' + value;\n                                $settings.trailingNegative = false;\n                            }\n\n                            var _autoCheck3 = autoCheck(value, $settings),\n                                _autoCheck4 = _slicedToArray(_autoCheck3, 2),\n                                minTest = _autoCheck4[0],\n                                maxTest = _autoCheck4[1];\n\n                            if (checkEmpty(value, $settings) === null && minTest && maxTest) {\n                                value = fixNumber(value, $settings.aDec, $settings.aNeg);\n                                $settings.rawValue = value;\n                                if ($settings.aScale) {\n                                    value = value / $settings.scaleFactor;\n                                    value = value.toString();\n                                }\n                                $settings.mDec = $settings.aScale && $settings.aScale[1] ? +$settings.scaleDecimal : $settings.mDec;\n                                value = autoRound(value, $settings);\n                                value = presentNumber(value, $settings);\n                            } else {\n                                if (!minTest) {\n                                    $this.trigger('autoNumeric:minExceeded');\n                                }\n                                if (!maxTest) {\n                                    $this.trigger('autoNumeric:maxExceeded');\n                                }\n                                value = $settings.rawValue;\n                            }\n                        } else {\n                            if ($settings.wEmpty === 'zero') {\n                                $settings.rawValue = '0';\n                                value = autoRound('0', $settings);\n                            } else {\n                                $settings.rawValue = '';\n                            }\n                        }\n                        var groupedValue = checkEmpty(value, $settings, false);\n                        if (groupedValue === null) {\n                            groupedValue = autoGroup(value, $settings);\n                        }\n                        if (groupedValue !== origValue) {\n                            groupedValue = $settings.scaleSuffix ? groupedValue + $settings.scaleSuffix : groupedValue;\n                            $this.val(groupedValue);\n                        }\n                        if (groupedValue !== holder.inVal) {\n                            $this.change();\n                            delete holder.inVal;\n                        }\n                    });\n\n                    $this.on('paste', function (e) {\n                        //FIXME After a paste, the caret is put on the far right of the input, it should be set to something like `newCaretPosition = oldCaretPosition + pasteText.length;`, while taking into account the thousand separators and the decimal character\n                        e.preventDefault();\n                        holder = getHolder($this);\n                        function prepare(text) {\n                            return autoStrip(text, holder.settingsClone).replace(holder.settingsClone.aDec, '.');\n                        }\n\n                        function isValid(text) {\n                            return text !== '' && !isNaN(text);\n                        }\n\n                        var oldRawValue = $this.autoNumeric('get');\n                        var currentValue = this.value || '';\n                        var selectionStart = this.selectionStart || 0;\n                        var selectionEnd = this.selectionEnd || 0;\n                        var prefix = currentValue.substring(0, selectionStart);\n                        var suffix = currentValue.substring(selectionEnd, currentValue.length);\n                        var pastedText = prepare(e.originalEvent.clipboardData.getData('text/plain'));\n                        if (isValid(pastedText)) {\n                            var newValue = prepare(prefix + Number(pastedText).valueOf() + suffix);\n                            if (isValid(newValue) && Number(oldRawValue).valueOf() !== Number(newValue).valueOf()) {\n                                $this.autoNumeric('set', newValue);\n                                $this.trigger('input');\n                            }\n                        } else {\n                            this.selectionStart = selectionEnd;\n                        }\n                    });\n\n                    $this.closest('form').on('submit.autoNumeric', function () {\n                        holder = getHolder($this);\n                        if (holder) {\n                            var $settings = holder.settingsClone;\n                            if ($settings.unSetOnSubmit) {\n                                $this.val($settings.rawValue);\n                            }\n                        }\n                    });\n                }\n            });\n        },\n\n\n        /**\n         * method to remove settings and stop autoNumeric() - does not remove the formatting\n         * $(someSelector).autoNumeric(\"destroy\"); // destroys autoNumeric\n         * no parameters accepted\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    autoSave($this, settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * method to clear the value and sessionStorage or cookie depending on browser supports\n         * $(someSelector).autoNumeric(\"wipe\"); // removes session storage and cookies from memory\n         * no parameters accepted\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    autoSave($this, settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings\n         * It can be called multiple times if needed\n         * The options passed as a parameter is an object that contains the settings (ie. {aSep: \".\", aDec: \",\", aSign: ' '})\n         *\n         * @usage $(someSelector).autoNumeric(\"update\", {options}); // updates the settings\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"update\" method', true);\n                }\n                var strip = $this.autoNumeric('get');\n                settings = $.extend(settings, options);\n\n                if (settings.aScale !== null) {\n                    settings.scaleFactor = +settings.aScale[0];\n                    settings.scaleDecimal = settings.aScale[1] ? +settings.aScale[1] : null;\n                    settings.scaleSuffix = settings.aScale[2] ? settings.aScale[2] : '';\n                }\n                settings = originalSettings(settings);\n                getHolder($this, settings, true);\n\n                if (settings.aDec === settings.aSep) {\n                    throwError('autoNumeric will not function properly when the decimal character aDec: \"' + settings.aDec + '\" and thousand separator aSep: \"' + settings.aSep + '\" are the same character', settings.debug);\n                }\n                $this.data('autoNumeric', settings);\n\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * $(someSelector).autoNumeric('set', 'value'); // formats the value being passed as the second parameter\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         */\n        set: function set(valueIn) {\n            return $(this).each(function () {\n                if (valueIn === null || isUndefined(valueIn)) {\n                    return;\n                }\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n                var value = valueIn.toString();\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method', true);\n                }\n\n                // allows locale decimal separator to be a comma - no thousand separator allowed\n                value = fromLocale(value);\n\n                // Throws an error if the value being set is not numeric\n                if (!$.isNumeric(Number(value))) {\n                    throwError('The value \"' + value + '\" being \"set\" is not numeric and has caused a error to be thrown', settings.debug);\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _autoCheck5 = autoCheck(value, settings),\n                        _autoCheck6 = _slicedToArray(_autoCheck5, 2),\n                        minTest = _autoCheck6[0],\n                        maxTest = _autoCheck6[1];\n\n                    if (minTest && maxTest) {\n                        if ($input && (!settings.eDec || !settings.aScale)) {\n                            settings.rawValue = value;\n                        }\n\n                        // checks if the value falls within the min max range\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            if (settings.aScale && !settings.onOff) {\n                                value = value / settings.scaleFactor;\n                                value = value.toString();\n                                settings.mDec = settings.scaleDecimal;\n                            }\n                            value = autoRound(value, settings);\n                            if (settings.eDec === null && settings.aScale === null) {\n                                settings.rawValue = value;\n                            }\n                            value = presentNumber(value, settings);\n                            value = autoGroup(value, settings);\n                        }\n                        if (settings.aStor && (settings.eDec !== null || settings.aScale !== null)) {\n                            autoSave($this, settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        autoSave($this, settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n                        throwError('The value [' + attemptedValue + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings for this element', settings.debug);\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.onOff && settings.scaleSuffix) {\n                    value = value + settings.scaleSuffix;\n                }\n                if ($input) {\n                    return $this.val(value);\n                }\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * method to un-format inputs - handy to use right before form submission\n         * $(someSelector).autoNumeric('unSet'); // no parameter accepted\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.onOff = true;\n                    $this.val($this.autoNumeric('get'));\n                }\n            });\n        },\n\n\n        /**\n         * method to re-format inputs - handy to use right after form submission\n         * $(someSelector).autoNumeric('reSet'); // no parameters accepted\n         * this is called after the 'unSet' method to reformat the input\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = autoGet($(this));\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * method to get the unformatted that accepts up to one parameter\n         * $(someSelector).autoNumeric('get'); no parameter supported\n         * by defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        get: function get() {\n            var $this = autoGet($(this));\n            var settings = $this.data('autoNumeric');\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var value = '';\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method', true);\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric', settings.debug);\n            }\n\n            if (settings.eDec || settings.aScale) {\n                value = settings.rawValue;\n            } else {\n                if (!(/\\d/.test(value) || Number(value) === 0) && settings.wEmpty === 'focus') {\n                    return '';\n                }\n                if (value !== '' && settings.nBracket !== null) {\n                    settings.onOff = true;\n                    value = negativeBracket(value, settings);\n                }\n                if (settings.runOnce || settings.aForm === false) {\n                    value = autoStrip(value, settings);\n                }\n                value = fixNumber(value, settings.aDec, settings.aNeg);\n            }\n\n            if (Number(value) === 0 && settings.lZero !== 'keep') {\n                value = '0';\n            }\n            if (settings.localeOutput) {\n                value = toLocale(value, settings.localeOutput);\n            }\n\n            // returned Numeric String\n            //TODO Shouldn't we return `Number(value)` since the goal of `get` is to get the raw javascript value?\n            return value;\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!isArray(this) || this.length !== 1 || !this[0].hasOwnProperty('value')) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" => please see option \"localeOutput\" for details\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns the object with autoNumeric settings for those who need to look under the hood\n         * $(someSelector).autoNumeric('getSettings'); // no parameters accepted\n         * $(someSelector).autoNumeric('getSettings').aDec; // return the aDec setting as a string - ant valid setting can be used\n         */\n        getSettings: function getSettings() {\n            var $this = autoGet($(this));\n\n            return $this.eq(0).data('autoNumeric');\n        }\n    };\n\n    /**\n     * autoNumeric function\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            //TODO First validate the options passed as an argument, before using `init`\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric', true);\n    };\n\n    /**\n     * Defaults are public - these can be overridden by the following:\n     * HTML5 data attributes\n     * Options passed by the 'init' or 'update' methods\n     * Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n     */\n    $.fn.autoNumeric.defaults = {\n        /* allowed thousand separator characters\n         * comma = \",\"\n         * period \"full stop\" = \".\"\n         * apostrophe is escaped = \"\\\"\"\n         * space = \" \"\n         * none = \"\"\n         * NOTE: do not use numeric characters\n         */\n        aSep: ',',\n\n        /* when true => when the input has focus only the decimal character is visible\n         */\n        nSep: false,\n\n        /* digital grouping for the thousand separator used in Format\n         * dGroup: \"2\", results in 99,99,99,999 India's lakhs\n         * dGroup: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n         * dGroup: \"3\", results in 999,999,999 default\n         * dGroup: \"4\", results in 9999,9999,9999 used in some Asian countries\n         */\n        dGroup: '3',\n\n        /* allowed decimal separator characters\n         * period \"full stop\" = \".\"\n         * comma = \",\"\n         */\n        aDec: '.',\n\n        /* allow to declare alternative decimal separator which is automatically replaced by aDec\n         * developed for countries the use a comma \",\" as the decimal character\n         * and have keyboards\\numeric pads that have a period 'full stop' as the decimal characters (Spain is an example)\n         */\n        altDec: null,\n\n        /* aSign = allowed currency symbol\n         * Must be in quotes aSign: \"$\"\n         * space to the right of the currency symbol aSign: '$ '\n         * space to the left of the currency symbol aSign: ' $'\n         */\n        aSign: '',\n\n        /* pSign = placement of currency sign as a p=prefix or s=suffix\n         * for prefix pSign: \"p\" (default)\n         * for suffix pSign: \"s\"\n         */\n        pSign: 'p',\n\n        /* placement of negative sign relative to the aSign option l=left, r=right, p=prefix & s=suffix\n         * -1,234.56  => default no options required\n         * -$1,234.56 => {aSign: \"$\"}\n         * $-1,234.56 => {aSign: \"$\", pNeg: \"r\"}\n         * -1,234.56$ => {aSign: \"$\", pSign: \"s\", pNeg: \"p\"}\n         * 1,234.56-  => {pNeg: \"s\"}\n         * $1,234.56- => {aSign: \"$\", pNeg: \"s\"}\n         * 1,234.56-$ => {aSign: \"$\", pSign: \"s\"}\n         * 1,234.56$- => {aSign: \"$\", pSign: \"s\", pNeg: \"r\"}\n         */\n        pNeg: 'l',\n\n        /* Additional suffix\n         * Must be in quotes aSuffix: 'gross', a space is allowed aSuffix: ' dollars'\n         * Numeric characters and negative sign not allowed'\n         */\n        aSuffix: '',\n\n        /* override min max limits'\n         * oLimits: \"ceiling\" adheres to vMax and ignores vMin settings\n         * oLimits: \"floor\" adheres to vMin and ignores vMax settings\n         * oLimits: \"ignore\" ignores both vMin & vMax\n         */\n        oLimits: null,\n\n        /* maximum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be larger than vMin\n         */\n        vMax: '9999999999999.99',\n\n        /* minimum possible value\n         * value must be enclosed in quotes and use the period for the decimal point\n         * value must be smaller than vMax\n         */\n        vMin: '-9999999999999.99',\n\n        /* Maximum number of decimal places = used to override decimal places set by the vMin & vMax values\n         * value must be enclosed in quotes example mDec: \"3\",\n         */\n        mDec: null,\n\n        /* Expanded decimal places visible when input has focus - example:\n         * {eDec: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n         * the \"get\" method returns the extended decimal places\n         */\n        eDec: null,\n\n        /* Scaled number displayed when input does not have focus example with the following:\n         * {aScale: [\"1000\", \"0\", \"K\"]}  => with focus \"1,000.00\" without focus \"1K\"\n         * [\"divisor\", \"decimal places\", \"symbol\"]\n         * divisor value - does not need to be whole number - please understand that Javascript has limited accuracy in math\n         * the \"get\" method returns the full value and scaled value.\n         * decimal places \"optional\" when not in focus - if omitted the decimal places will be the same when the input has focus\n         * Symbol \"optional\" displayed when the input does not have focus - NOTE: if a symbol is used you MUST also specify the decimal places\n         * value must be enclosed in quotes example mDec: \"3\"\n         */\n        aScale: null,\n\n        /* Set to true to allow the eDec value to be saved with sessionStorage\n         * if ie 6 or 7 the value will be saved as a session cookie\n         */\n        aStor: false,\n\n        /* method used for rounding\n         * mRound: \"s\", Round-Half-Up Symmetric (default)\n         * mRound: \"A\", Round-Half-Up Asymmetric\n         * mRound: \"s\", Round-Half-Down Symmetric (lower case s)\n         * mRound: \"A\", Round-Half-Down Asymmetric (lower case a)\n         * mRound: \"B\", Round-Half-Even \"Bankers Rounding\"\n         * mRound: \"U\", Round Up \"Round-Away-From-Zero\"\n         * mRound: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n         * mRound: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n         * mRound: \"F\", Round to Floor \"Toward Negative Infinity\"\n         * mRound: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n         * mRound: \"U05\" Rounds up to next .05\n         * mRound: \"D05\" Rounds down to next .05\n         */\n        mRound: 's',\n\n        /* controls decimal padding\n         * aPad: true - always Pad decimals with zeros\n         * aPad: false - does not pad with zeros.\n         * aPad: `some number` - pad decimals with zero to number different from mDec\n         * thanks to Jonas Johansson for the suggestion\n         */\n        aPad: true,\n\n        /* places brackets on negative value -$ 999.99 to (999.99)\n         * visible only when the field does NOT have focus the left and right symbols should be enclosed in quotes and separated by a comma\n         * nBracket: null - (default)\n         * nBracket: '(,)', nBracket: '[,]', nBracket: '<,>' or nBracket: '{,}'\n         */\n        nBracket: null,\n\n        /* Displayed on empty string \"\"\n         * wEmpty: \"focus\" - (default) currency sign displayed and the input receives focus\n         * wEmpty: \"press\" - currency sign displays on any key being pressed\n         * wEmpty: \"always\" - always displays the currency sign only\n         * wEmpty: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or with a currency sign\n         */\n        //TODO Add an option to display the currency sign only on hover (if the input is empty)\n        wEmpty: 'focus',\n\n        /* controls leading zero behavior\n         * lZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n         * lZero: \"deny\", - allows only one leading zero on values less than one\n         * lZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n         */\n        lZero: 'allow',\n\n        /* determine if the default value will be formatted on initialization.\n         * true = automatically formats the default value on initialization\n         * false = will not format the default value\n         */\n        aForm: true,\n\n        /* determine if the select all keyboard command will select\n         * the complete input text or only the input numeric value\n         * if the currency symbol is between the numeric value and the negative sign only the numeric value will selected\n         */\n        sNumber: false,\n\n        /* helper option for ASP.NET postback\n         * should be the value of the unformatted default value\n         * examples:\n         * no default value=\"\" {anDefault: \"\"}\n         * value=1234.56 {anDefault: '1234.56'}\n         */\n        anDefault: null,\n\n        /* removes formatting on submit event\n         * this output format: positive nnnn.nn, negative -nnnn.nn\n         * review the 'unSet' method for other formats\n         */\n        unSetOnSubmit: false,\n\n        /* allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n         * null => nnnn.nn or -nnnn.nn default\n         * \",\"  => nnnn,nn or -nnnn,nn can als be \"-,\"\n         * \".-\" => nnnn.nn or nnnn.nn-\n         * \",-\" => nnnn,nn or nnnn,nn-\n         */\n        localeOutput: null,\n\n        /* error handling function\n         * true => all errors are thrown - helpful in site development\n         * false => throws errors when calling methods prior to the supported element has been initialized be autoNumeric\n         */\n        debug: false\n    };\n\n    getDefaultConfig = function getDefaultConfig() {\n        return $.fn.autoNumeric.defaults;\n    };\n\n    /**\n     * public function that allows formatting without an element trigger\n     */\n    autoFormat = function autoFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        value = value.toString();\n        value = fromLocale(value);\n        if (Number(value) < 0) {\n            settings.aNeg = '-';\n        }\n        if (settings.mDec === null) {\n            var vMax = settings.vMax.toString().split('.');\n            var vMin = !settings.vMin && settings.vMin !== 0 ? [] : settings.vMin.toString().split('.');\n            settings.mDec = decLength(vMin, vMax);\n        }\n\n        var _autoCheck7 = autoCheck(value, settings),\n            _autoCheck8 = _slicedToArray(_autoCheck7, 2),\n            minTest = _autoCheck8[0],\n            maxTest = _autoCheck8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            sendCustomEvent('autoFormat.autoNumeric', 'Range test failed');\n            throwError('The value [' + value + '] being set falls outside the vMin [' + settings.vMin + '] and vMax [' + settings.vMax + '] settings', settings.debug);\n        }\n        value = autoRound(value, settings);\n        value = presentNumber(value, settings);\n        value = autoGroup(value, settings);\n\n        return value;\n    };\n\n    $.fn.autoFormat = autoFormat;\n\n    /**\n     * public function that allows unformatting without an element\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        var settings = $.extend({}, $.fn.autoNumeric.defaults, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.aDec;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n        if (value.charAt(0) === '-') {\n            settings.aNeg = '-';\n        } else if (settings.nBracket && settings.nBracket.split(',')[0] === value.charAt(0)) {\n            settings.aNeg = '-';\n            settings.onOff = true;\n            value = negativeBracket(value, settings);\n        }\n        value = value.replace(autoStrip, '');\n        value = value.replace(',', '.');\n        if (settings.localeOutput) {\n            value = toLocale(value, settings.localeOutput);\n        }\n\n        return Number(value);\n    };\n\n    $.fn.autoUnformat = autoUnFormat;\n\n    /**\n     * Create a custom event.\n     * cf. https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {CustomEvent}\n     */\n    function createCustomEvent(eventName, detail) {\n        /* let eventInfo = new CustomEventInit(); //This should be used instead, but IE does not support 'CustomEventInit' yet\n        eventInfo.detail = detail;\n        return new CustomEvent(eventName, eventInfo); */\n        return new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n    }\n\n    /**\n     * Create a custom event and immediately broadcast it.\n     *\n     * @param eventName string\n     * @param detail\n     * @returns {boolean}\n     */\n    function sendCustomEvent(eventName) {\n        var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        return document.dispatchEvent(createCustomEvent(eventName, detail));\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig\n\n};\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImtleUNvZGUiLCJCYWNrc3BhY2UiLCJUYWIiLCJFbnRlciIsIlNoaWZ0IiwiQ3RybCIsIkFsdCIsIlBhdXNlQnJlYWsiLCJDYXBzTG9jayIsIkVzYyIsIlNwYWNlIiwiUGFnZVVwIiwiUGFnZURvd24iLCJFbmQiLCJIb21lIiwiTGVmdEFycm93IiwiVXBBcnJvdyIsIlJpZ2h0QXJyb3ciLCJEb3duQXJyb3ciLCJJbnNlcnQiLCJEZWxldGUiLCJudW0wIiwibnVtMSIsIm51bTIiLCJudW0zIiwibnVtNCIsIm51bTUiLCJudW02IiwibnVtNyIsIm51bTgiLCJudW05IiwiYSIsImIiLCJjIiwiZCIsImUiLCJmIiwiZyIsImgiLCJpIiwiaiIsImsiLCJsIiwibSIsIm4iLCJvIiwicCIsInEiLCJyIiwicyIsInQiLCJ1IiwidiIsInciLCJ4IiwieSIsInoiLCJXaW5kb3dzIiwiUmlnaHRDbGljayIsIm51bXBhZDAiLCJudW1wYWQxIiwibnVtcGFkMiIsIm51bXBhZDMiLCJudW1wYWQ0IiwibnVtcGFkNSIsIm51bXBhZDYiLCJudW1wYWQ3IiwibnVtcGFkOCIsIm51bXBhZDkiLCJNdWx0aXBseU51bXBhZCIsIlBsdXNOdW1wYWQiLCJNaW51c051bXBhZCIsIkRvdE51bXBhZCIsIlNsYXNoTnVtcGFkIiwiRjEiLCJGMiIsIkYzIiwiRjQiLCJGNSIsIkY2IiwiRjciLCJGOCIsIkY5IiwiRjEwIiwiRjExIiwiRjEyIiwiTnVtTG9jayIsIlNjcm9sbExvY2siLCJNeUNvbXB1dGVyIiwiTXlDYWxjdWxhdG9yIiwiU2VtaWNvbG9uIiwiRXF1YWwiLCJDb21tYSIsIkh5cGhlbiIsIkRvdCIsIlNsYXNoIiwiQmFja3F1b3RlIiwiTGVmdEJyYWNrZXQiLCJCYWNrc2xhc2giLCJSaWdodEJyYWNrZXQiLCJRdW90ZSIsIkNvbW1hbmQiLCJpc1VuZGVmaW5lZCIsInZhbHVlIiwiaXNVbmRlZmluZWRPck51bGxPckVtcHR5IiwiaXNTdHJpbmciLCJzdHIiLCJTdHJpbmciLCJjb250YWlucyIsIm5lZWRsZSIsImluZGV4T2YiLCJpc0luQXJyYXkiLCJhcnJheSIsImlzQXJyYXkiLCJhcnIiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJBcnJheSIsIkVycm9yIiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibGVuZ3RoIiwidGV4dCIsIm1vdmVTdGFydCIsImVuZCIsInN0YXJ0Iiwic2VsZWN0aW9uRW5kIiwic2V0RWxlbWVudFNlbGVjdGlvbiIsInJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwidGhyb3dFcnJvciIsIm1lc3NhZ2UiLCJkZWJ1ZyIsInJ1bkNhbGxiYWNrcyIsIiR0aGlzIiwic2V0dGluZ3MiLCIkIiwiZWFjaCIsInZhbCIsImF1dG9OdW1lcmljIiwiZGVjTGVuZ3RoIiwidk1pbiIsInZNYXgiLCJ2TWF4TGVuZ3RoIiwidk1pbkxlbmd0aCIsIk1hdGgiLCJtYXgiLCJhdXRvQ29kZSIsInNwbGl0IiwiYU5lZyIsInJlcGxhY2UiLCJtSW50UG9zIiwibUludE5lZyIsIm1EZWMiLCJvRGVjIiwiTnVtYmVyIiwic2NhbGVEZWNpbWFsIiwiYWx0RGVjIiwiYURlYyIsImFTZXAiLCJhTmVnUmVnIiwiYU5lZ1JlZ0F1dG9TdHJpcCIsInNraXBGaXJzdEF1dG9TdHJpcCIsIlJlZ0V4cCIsInNraXBMYXN0QXV0b1N0cmlwIiwiYWxsb3dlZCIsImFsbG93ZWRBdXRvU3RyaXAiLCJudW1SZWdBdXRvU3RyaXAiLCJhdXRvU3RyaXAiLCJhU2lnbiIsImFTdWZmaXgiLCJwTmVnIiwicFNpZ24iLCJ0cmFpbGluZ05lZ2F0aXZlIiwibWF0Y2giLCJqb2luIiwibFplcm8iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwiZGVjaW1hbFBhcnQiLCJtb2RpZmllZEludGVnZXJQYXJ0IiwiY2hhckF0Iiwic2xpY2UiLCJvbk9mZiIsInN0cmlwUmVnIiwibmVnYXRpdmVCcmFja2V0IiwibkJyYWNrZXQiLCJmaXJzdEJyYWNrZXQiLCJsYXN0QnJhY2tldCIsImZyb21Mb2NhbGUiLCJsYXN0SW5kZXhPZiIsInRvTG9jYWxlIiwibG9jYWxlIiwiZml4TnVtYmVyIiwicHJlc2VudE51bWJlciIsImNoZWNrRW1wdHkiLCJpdiIsInNpZ25PbkVtcHR5Iiwid0VtcHR5IiwiYXV0b0dyb3VwIiwic3RyaXAiLCJlbXB0eSIsImlzTmVnIiwiZGlnaXRhbEdyb3VwIiwiZEdyb3VwIiwidGVzdCIsInN1YnN0cmluZyIsInJhd1ZhbHVlIiwidHJ1bmNhdGVaZXJvcyIsIml2Um91bmRlZCIsInJEZWMiLCJyZWdleCIsImF1dG9Sb3VuZCIsIm1Sb3VuZCIsInJvdW5kIiwiY2VpbCIsImZsb29yIiwicmVzdWx0IiwiYVBhZCIsImRQb3MiLCJ2ZFBvcyIsImNEZWMiLCJ6ZXJvcyIsInJMZW5ndGgiLCJ0Um91bmQiLCJvZGQiLCJpdkFycmF5IiwidHJ1bmNhdGVEZWNpbWFsIiwicGFzdGUiLCJtb2RpZmllZERlY2ltYWxQYXJ0IiwicGFyc2VTdHIiLCJuTCIsInNlYXJjaCIsInRlc3RNaW5NYXgiLCJ4YyIsInljIiwieE5lZyIsImF1dG9DaGVjayIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsIm9MaW1pdHMiLCJhdXRvR2V0Iiwib2JqIiwiZ2V0SG9sZGVyIiwiJHRoYXQiLCJ1cGRhdGUiLCJkYXRhIiwiaG9sZGVyIiwiQXV0b051bWVyaWNIb2xkZXIiLCJnZXQiLCJvcmlnaW5hbFNldHRpbmdzIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwicmVhZENvb2tpZSIsIm5hbWUiLCJuYW1lRVEiLCJjYSIsImNvb2tpZSIsInN0b3JhZ2VUZXN0IiwibW9kIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImF1dG9TYXZlIiwidG9EbyIsImFTdG9yIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCJmb3JtYXR0ZWQiLCJzZXR0aW5nc0Nsb25lIiwiaW5pdCIsImN0cmxLZXkiLCJjbWRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJ0eXBlIiwia2RDb2RlIiwid2hpY2giLCJwcm9jZXNzZWQiLCJzZXRTZWxlY3Rpb24iLCJzZXRSZWFsIiwibWluIiwic2V0UG9zaXRpb24iLCJwb3MiLCJnZXRCZWZvcmVBZnRlciIsImxlZnQiLCJyaWdodCIsImdldEJlZm9yZUFmdGVyU3RyaXBlZCIsIm5vcm1hbGl6ZVBhcnRzIiwibmV3VmFsdWUiLCJzZXRWYWx1ZVBhcnRzIiwiYWR2ZW50IiwicGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsInRyaWdnZXIiLCJzaWduUG9zaXRpb24iLCJhU2lnbkxlbiIsImhhc05lZyIsInZhbHVlTGVuIiwiZXhwYW5kU2VsZWN0aW9uT25TaWduIiwiY2hlY2tQYXN0ZSIsInZhbHVlUGFydHNCZWZvcmVQYXN0ZSIsIm9sZFBhcnRzIiwibW9kaWZpZWRMZWZ0UGFydCIsInN1YnN0ciIsInNraXBBbHdheXMiLCJzTnVtYmVyIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJhU3VmZml4TGVuIiwic3RhcnRKdW1wIiwicHJvY2Vzc1RyYWlsaW5nIiwiY2FyZXRGaXgiLCJCb29sZWFuIiwicHJvY2Vzc0Fsd2F5cyIsInRocm93SW5wdXQiLCJwcm9jZXNzS2V5cHJlc3MiLCJjQ29kZSIsImZyb21DaGFyQ29kZSIsImZvcm1hdFF1aWNrIiwibGVmdExlbmd0aCIsImt1Q29kZSIsInN1YlBhcnRzIiwibGVmdEFyIiwic2hpZnQiLCJwdXNoIiwic2lnblBhcnRzIiwiZXNjYXBlQ2hyIiwiZXNjYXBlZFBhcnRzIiwibWluaVBhcnRzIiwibGVmdFJlZyIsIm5ld0xlZnQiLCJfZ2V0U3RyaW5nT3JBcnJheSIsImdldEFycmF5QmVoYXZpb3IiLCJmb3JtSW5kZXgiLCJpbmRleCIsImFsbEZvcm1FbGVtZW50cyIsImFpSW5kZXgiLCJzY0luZGV4IiwiclN1Ym1pdHRlclR5cGVzIiwiclN1Ym1pdHRhYmxlIiwickNoZWNrYWJsZVR5cGUiLCJyTm9uQXV0b051bWVyaWNUeXBlcyIsImNvdW50IiwiZmllbGQiLCJsb2NhbE5hbWUiLCJkaXNhYmxlZCIsImNoZWNrZWQiLCJmb3JtRmllbGRzIiwic2VyaWFsaXplQXJyYXkiLCJzY0VsZW1lbnQiLCJpbkFycmF5IiwidGVzdElucHV0IiwibG9jYWxlT3V0cHV0Iiwic2VyaWFsaXplIiwiZm9ybVBhcnRzIiwiaW5wdXROYW1lIiwiaW5wdXRWYWx1ZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm1ldGhvZHMiLCJvcHRpb25zIiwidGFnRGF0YSIsIiRpbnB1dCIsImlzIiwiZXh0ZW5kIiwiZm4iLCJkZWZhdWx0cyIsInJ1bk9uY2UiLCJ0YWdMaXN0Iiwia2V5IiwiYVNjYWxlIiwic2NhbGVGYWN0b3IiLCJzY2FsZVN1ZmZpeCIsInByb3AiLCJ0b0xvd2VyQ2FzZSIsImVEZWMiLCJhRm9ybSIsInNldFZhbHVlIiwiY3VycmVudFZhbHVlIiwiYXR0ciIsInRlc3RlZEN1cnJlbnRWYWx1ZSIsInBhcnNlRmxvYXQiLCJpc05hTiIsIkluZmluaXR5IiwiYW5EZWZhdWx0IiwiaXNOdW1lcmljIiwidG9TdHJpcCIsIm9uIiwiJHNldHRpbmdzIiwiblNlcCIsImluVmFsIiwibGFzdFZhbCIsIm9uRW1wdHkiLCJyZWFkT25seSIsInNraXAiLCJ0YWIiLCJvcmlnVmFsdWUiLCJncm91cGVkVmFsdWUiLCJjaGFuZ2UiLCJwcmVwYXJlIiwiaXNWYWxpZCIsIm9sZFJhd1ZhbHVlIiwicHJlZml4Iiwic3VmZml4IiwicGFzdGVkVGV4dCIsIm9yaWdpbmFsRXZlbnQiLCJjbGlwYm9hcmREYXRhIiwiZ2V0RGF0YSIsInZhbHVlT2YiLCJjbG9zZXN0IiwidW5TZXRPblN1Ym1pdCIsImRlc3Ryb3kiLCJyZW1vdmVEYXRhIiwib2ZmIiwid2lwZSIsInNldCIsInZhbHVlSW4iLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldEZvcm1hdHRlZCIsImhhc093blByb3BlcnR5IiwiZ2V0U3RyaW5nIiwiZ2V0QXJyYXkiLCJnZXRTZXR0aW5ncyIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsInNlbmRDdXN0b21FdmVudCIsImF1dG9VbmZvcm1hdCIsImNyZWF0ZUN1c3RvbUV2ZW50IiwiZXZlbnROYW1lIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsInBhcmFtcyIsImV2dCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiRXZlbnQiLCJmb3JtYXQiLCJ1bkZvcm1hdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsSUFBSUEsbUJBQUo7QUFDQSxJQUFJQyxxQkFBSjtBQUNBLElBQUlDLHlCQUFKOztBQUVBOztBQUVDLFdBQVNDLE9BQVQsRUFBa0I7QUFDZjtBQUNKLFFBQUksSUFBSixFQUFnRDtBQUM1QztBQUNBQyxRQUFBLGlDQUFPLENBQUMsc0JBQUQsQ0FBUCxvQ0FBbUJELE9BQW5CO0FBQ0gsS0FIRCxNQUdPLElBQUksUUFBT0UsTUFBUCx5Q0FBT0EsTUFBUCxPQUFrQixRQUFsQixJQUE4QkEsT0FBT0MsT0FBekMsRUFBa0Q7QUFDckQ7QUFDQUQsZUFBT0MsT0FBUCxHQUFpQkgsUUFB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QXFCLGFBQXJCLENBQVo7QUFDQUQsZ0JBQUlFLGVBQUosQ0FBb0JKLEtBQXBCLEVBQTJCQyxPQUFPSixPQUFsQyxFQUEyQ0ksT0FBT0gsVUFBbEQsRUFBOERHLE9BQU9OLE1BQXJFO0FBQ0EsbUJBQU9PLEdBQVA7QUFDSDs7QUFFRE4sb0JBQVl0VixTQUFaLEdBQXdCdEgsT0FBT3FkLEtBQVAsQ0FBYS9WLFNBQXJDO0FBQ0F0SCxlQUFPNGMsV0FBUCxHQUFxQkEsV0FBckI7QUFDSCxLQWREO0FBZUgsQ0E5eEZBLENBQUQ7O0FBZ3lGQTs7O2tCQUdlO0FBQ1hVLFlBQVU5ZCxVQURDO0FBRVgrZCxjQUFVOWQsWUFGQztBQUdYQzs7QUFIVyxDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogYXV0b051bWVyaWMuanNcbiogQGF1dGhvcjogQm9iIEtub3RoZVxuKiBAY29udHJpYnV0b3JzOiBTb2tvbG92IFl1cmEgYW5kIG90aGVyIEdpdGh1YiB1c2Vyc1xuKiBAdmVyc2lvbjogMi4wIC0gMjAxNi0xMS0xNiBVVEMtMTAgMjM6MDBcbipcbiogQ3JlYXRlZCBieSBSb2JlcnQgSi4gS25vdGhlIG9uIDIwMDktMDgtMDkuIFBsZWFzZSByZXBvcnQgYW55IGJ1Z3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL0JvYktub3RoZS9hdXRvTnVtZXJpY1xuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMDkgUm9iZXJ0IEouIEtub3RoZSBodHRwOi8vd3d3LmRlY29ycGxhbml0LmNvbS9wbHVnaW4vXG4qXG4qIFRoZSBNSVQgTGljZW5zZSAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXG4qXG4qIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4qIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4qIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiogY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3ViIGxpY2Vuc2UsIGFuZC9vciBzZWxsXG4qIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuKiBjb25kaXRpb25zOlxuKlxuKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4qIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4qIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4qIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLFxuKiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5sZXQgYXV0b0Zvcm1hdDtcbmxldCBhdXRvVW5Gb3JtYXQ7XG5sZXQgZ2V0RGVmYXVsdENvbmZpZztcblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbihmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgLy9UT0RPIFRoaXMgc3VyZWx5IGNhbiBiZSBpbXByb3ZlZCBieSBsZXR0aW5nIHdlYnBhY2sgdGFrZSBjYXJlIG9mIGdlbmVyYXRpbmcgdGhpcyBVTUQgcGFydFxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgLy8gTm9kZS9Db21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XG59IGVsc2Uge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xuICAgIGZhY3Rvcnkod2luZG93LmpRdWVyeSk7XG59XG59KCQgPT4ge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICAgICAqL1xuICAgIGNvbnN0IGtleUNvZGUgPSB7XG4gICAgICAgIEJhY2tzcGFjZTogICAgICA4LFxuICAgICAgICBUYWI6ICAgICAgICAgICAgOSxcbiAgICAgICAgRW50ZXI6ICAgICAgICAgIDEzLFxuICAgICAgICBTaGlmdDogICAgICAgICAgMTYsXG4gICAgICAgIEN0cmw6ICAgICAgICAgICAxNyxcbiAgICAgICAgQWx0OiAgICAgICAgICAgIDE4LFxuICAgICAgICBQYXVzZUJyZWFrOiAgICAgMTksXG4gICAgICAgIENhcHNMb2NrOiAgICAgICAyMCxcbiAgICAgICAgRXNjOiAgICAgICAgICAgIDI3LFxuICAgICAgICBTcGFjZTogICAgICAgICAgMzIsXG4gICAgICAgIFBhZ2VVcDogICAgICAgICAzMyxcbiAgICAgICAgUGFnZURvd246ICAgICAgIDM0LFxuICAgICAgICBFbmQ6ICAgICAgICAgICAgMzUsXG4gICAgICAgIEhvbWU6ICAgICAgICAgICAzNixcbiAgICAgICAgTGVmdEFycm93OiAgICAgIDM3LFxuICAgICAgICBVcEFycm93OiAgICAgICAgMzgsXG4gICAgICAgIFJpZ2h0QXJyb3c6ICAgICAzOSxcbiAgICAgICAgRG93bkFycm93OiAgICAgIDQwLFxuICAgICAgICBJbnNlcnQ6ICAgICAgICAgNDUsXG4gICAgICAgIERlbGV0ZTogICAgICAgICA0NixcbiAgICAgICAgbnVtMDogICAgICAgICAgIDQ4LFxuICAgICAgICBudW0xOiAgICAgICAgICAgNDksXG4gICAgICAgIG51bTI6ICAgICAgICAgICA1MCxcbiAgICAgICAgbnVtMzogICAgICAgICAgIDUxLFxuICAgICAgICBudW00OiAgICAgICAgICAgNTIsXG4gICAgICAgIG51bTU6ICAgICAgICAgICA1MyxcbiAgICAgICAgbnVtNjogICAgICAgICAgIDU0LFxuICAgICAgICBudW03OiAgICAgICAgICAgNTUsXG4gICAgICAgIG51bTg6ICAgICAgICAgICA1NixcbiAgICAgICAgbnVtOTogICAgICAgICAgIDU3LFxuICAgICAgICBhOiAgICAgICAgICAgICAgNjUsXG4gICAgICAgIGI6ICAgICAgICAgICAgICA2NixcbiAgICAgICAgYzogICAgICAgICAgICAgIDY3LFxuICAgICAgICBkOiAgICAgICAgICAgICAgNjgsXG4gICAgICAgIGU6ICAgICAgICAgICAgICA2OSxcbiAgICAgICAgZjogICAgICAgICAgICAgIDcwLFxuICAgICAgICBnOiAgICAgICAgICAgICAgNzEsXG4gICAgICAgIGg6ICAgICAgICAgICAgICA3MixcbiAgICAgICAgaTogICAgICAgICAgICAgIDczLFxuICAgICAgICBqOiAgICAgICAgICAgICAgNzQsXG4gICAgICAgIGs6ICAgICAgICAgICAgICA3NSxcbiAgICAgICAgbDogICAgICAgICAgICAgIDc2LFxuICAgICAgICBtOiAgICAgICAgICAgICAgNzcsXG4gICAgICAgIG46ICAgICAgICAgICAgICA3OCxcbiAgICAgICAgbzogICAgICAgICAgICAgIDc5LFxuICAgICAgICBwOiAgICAgICAgICAgICAgODAsXG4gICAgICAgIHE6ICAgICAgICAgICAgICA4MSxcbiAgICAgICAgcjogICAgICAgICAgICAgIDgyLFxuICAgICAgICBzOiAgICAgICAgICAgICAgODMsXG4gICAgICAgIHQ6ICAgICAgICAgICAgICA4NCxcbiAgICAgICAgdTogICAgICAgICAgICAgIDg1LFxuICAgICAgICB2OiAgICAgICAgICAgICAgODYsXG4gICAgICAgIHc6ICAgICAgICAgICAgICA4NyxcbiAgICAgICAgeDogICAgICAgICAgICAgIDg4LFxuICAgICAgICB5OiAgICAgICAgICAgICAgODksXG4gICAgICAgIHo6ICAgICAgICAgICAgICA5MCxcbiAgICAgICAgV2luZG93czogICAgICAgIDkxLFxuICAgICAgICBSaWdodENsaWNrOiAgICAgOTMsXG4gICAgICAgIG51bXBhZDA6ICAgICAgICA5NixcbiAgICAgICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgICAgICBudW1wYWQyOiAgICAgICAgOTgsXG4gICAgICAgIG51bXBhZDM6ICAgICAgICA5OSxcbiAgICAgICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICAgICAgbnVtcGFkNTogICAgICAgIDEwMSxcbiAgICAgICAgbnVtcGFkNjogICAgICAgIDEwMixcbiAgICAgICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICAgICAgbnVtcGFkODogICAgICAgIDEwNCxcbiAgICAgICAgbnVtcGFkOTogICAgICAgIDEwNSxcbiAgICAgICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICAgICAgUGx1c051bXBhZDogICAgIDEwNyxcbiAgICAgICAgTWludXNOdW1wYWQ6ICAgIDEwOSxcbiAgICAgICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICAgICAgU2xhc2hOdW1wYWQ6ICAgIDExMSxcbiAgICAgICAgRjE6ICAgICAgICAgICAgIDExMixcbiAgICAgICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICAgICAgRjM6ICAgICAgICAgICAgIDExNCxcbiAgICAgICAgRjQ6ICAgICAgICAgICAgIDExNSxcbiAgICAgICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICAgICAgRjY6ICAgICAgICAgICAgIDExNyxcbiAgICAgICAgRjc6ICAgICAgICAgICAgIDExOCxcbiAgICAgICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICAgICAgRjk6ICAgICAgICAgICAgIDEyMCxcbiAgICAgICAgRjEwOiAgICAgICAgICAgIDEyMSxcbiAgICAgICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICAgICAgRjEyOiAgICAgICAgICAgIDEyMyxcbiAgICAgICAgTnVtTG9jazogICAgICAgIDE0NCxcbiAgICAgICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICAgICAgTXlDb21wdXRlcjogICAgIDE4MixcbiAgICAgICAgTXlDYWxjdWxhdG9yOiAgIDE4MyxcbiAgICAgICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICAgICAgRXF1YWw6ICAgICAgICAgIDE4NyxcbiAgICAgICAgQ29tbWE6ICAgICAgICAgIDE4OCxcbiAgICAgICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICAgICAgRG90OiAgICAgICAgICAgIDE5MCxcbiAgICAgICAgU2xhc2g6ICAgICAgICAgIDE5MSxcbiAgICAgICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICAgICAgTGVmdEJyYWNrZXQ6ICAgIDIxOSxcbiAgICAgICAgQmFja3NsYXNoOiAgICAgIDIyMCxcbiAgICAgICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICAgICAgUXVvdGU6ICAgICAgICAgIDIyMixcbiAgICAgICAgQ29tbWFuZDogICAgICAgIDIyNCxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCgwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWQsIG51bGwgb3IgZW1wdHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYXMgU3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaXMgdGhlIHN0cmluZyBgc3RyYCBjb250YWlucyB0aGUgc3RyaW5nIGBuZWVkbGVgXG4gICAgICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBjb2VyY2UgdGhlIHBhcmFtZXRlcnMgdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmVlZGxlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udGFpbnMoc3RyLCBuZWVkbGUpIHtcbiAgICAgICAgaWYgKCFpc1N0cmluZyhzdHIpIHx8ICFpc1N0cmluZyhuZWVkbGUpIHx8IHN0ciA9PT0gJycgfHwgbmVlZGxlID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgbmVlZGxlYCBpcyBpbiB0aGUgYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHBhcmFtIHsqfSBuZWVkbGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0luQXJyYXkobmVlZGxlLCBhcnJheSkge1xuICAgICAgICBpZiAoIWlzQXJyYXkoYXJyYXkpIHx8IGFycmF5ID09PSBbXSB8fCBpc1VuZGVmaW5lZChuZWVkbGUpIHx8IG5lZWRsZSA9PT0gJycgfHwgbmVlZGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGFuIEFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGFyclxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Knxib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXkoYXJyKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoW10pID09PSAnW29iamVjdCBBcnJheV0nKSB7IC8vIE1ha2Ugc3VyZSBhbiBhcnJheSBoYXMgYSBjbGFzcyBhdHRyaWJ1dGUgb2YgW29iamVjdCBBcnJheV1cbiAgICAgICAgICAgIC8vIFRlc3QgcGFzc2VkLCBub3cgY2hlY2sgaWYgaXMgYW4gQXJyYXlcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFycikgfHwgKHR5cGVvZiBhcnIgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndG9TdHJpbmcgbWVzc2FnZSBjaGFuZ2VkIGZvciBPYmplY3QgQXJyYXknKTsgLy8gVmVyaWZ5IHRoYXQgdGhlIHN0cmluZyByZXR1cm5lZCBieSBgdG9TdHJpbmdgIGRvZXMgbm90IGNoYW5nZSBpbiB0aGUgZnV0dXJlIChjZi4gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvODM2NTIxNSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgcm91dGluZSBmb3IgZ2V0dGluZyBzZWxlY3RlZCByYW5nZS9jdXJzb3IgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0aW9uKHRoYXQpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7fTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3QgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmxlbmd0aCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHNlbGVjdC5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIC10aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICBwb3NpdGlvbi5lbmQgPSBzZWxlY3QudGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBwb3NpdGlvbi5zdGFydCA9IHBvc2l0aW9uLmVuZCAtIHBvc2l0aW9uLmxlbmd0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gdGhhdC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHRoYXQuc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MgYnJvd3NlciByb3V0aW5lIGZvciBzZXR0aW5nIHNlbGVjdGVkIHJhbmdlL2N1cnNvciBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEVsZW1lbnRTZWxlY3Rpb24odGhhdCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gdGhhdC5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgICAgICAgcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgZW5kKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgc3RhcnQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICB0aGF0LnNlbGVjdGlvbkVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIGhhbmRsZSBlcnJvcnMgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKG1lc3NhZ2UsIGRlYnVnKSB7XG4gICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcnVuIGNhbGxiYWNrcyBpbiBwYXJhbWV0ZXJzIGlmIGFueVxuICAgICAqIGFueSBwYXJhbWV0ZXIgY291bGQgYmUgYSBjYWxsYmFjazpcbiAgICAgKiAtIGEgZnVuY3Rpb24sIHdoaWNoIGludm9rZWQgd2l0aCBqUXVlcnkgZWxlbWVudCwgcGFyYW1ldGVycyBhbmQgdGhpcyBwYXJhbWV0ZXIgbmFtZSBhbmQgcmV0dXJucyBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgKiAtIGEgbmFtZSBvZiBmdW5jdGlvbiwgYXR0YWNoZWQgdG8gJChzZWxlY3RvcikuYXV0b051bWVyaWMuZnVuY3Rpb25OYW1lKCl7fSAtIHdoaWNoIHdhcyBjYWxsZWQgcHJldmlvdXNseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJ1bkNhbGxiYWNrcygkdGhpcywgc2V0dGluZ3MpIHtcbiAgICAgICAgLy8gbG9vcHMgdGhyb3VnaCB0aGUgc2V0dGluZ3Mgb2JqZWN0IChvcHRpb24gYXJyYXkpIHRvIGZpbmQgdGhlIGZvbGxvd2luZ1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrLCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSB2YWwoJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxscyB0aGUgYXR0YWNoZWQgZnVuY3Rpb24gZnJvbSB0aGUgaHRtbDUgZGF0YSBleGFtcGxlOiBkYXRhLWEtc2lnbj1cImZ1bmN0aW9uTmFtZVwiXG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba10gPSAkdGhpcy5hdXRvTnVtZXJpY1t2YWxdKCR0aGlzLCBzZXR0aW5ncywgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgZGVjaW1hbCBsZW5ndGggZnJvbSB0aGUgdk1pbiB2TWF4IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpIHtcbiAgICAgICAgbGV0IHZNYXhMZW5ndGggPSAwO1xuICAgICAgICBsZXQgdk1pbkxlbmd0aCA9IDA7XG4gICAgICAgIGlmICh2TWF4WzFdKSB7XG4gICAgICAgICAgICB2TWF4TGVuZ3RoID0gdk1heFsxXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZNaW5bMV0pIHtcbiAgICAgICAgICAgIHZNaW5MZW5ndGggPSB2TWluWzFdLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2TWF4TGVuZ3RoLCB2TWluTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJpbmcgdXNlciBkZWZpbmVkIG9wdGlvbnMgZm9yIGZ1cnRoZXIgdXNhZ2VcbiAgICAgKiBtZXJnZSB0aGVtIHdpdGggZGVmYXVsdHMgYXBwcm9wcmlhdGVseVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Db2RlKCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICBydW5DYWxsYmFja3MoJHRoaXMsIHNldHRpbmdzKTtcbiAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBjb25zdCB2TWluID0gKCFzZXR0aW5ncy52TWluICYmIHNldHRpbmdzLnZNaW4gIT09IDApID8gW10gOiBzZXR0aW5ncy52TWluLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgc2V0dGluZ3MuYU5lZyA9IHNldHRpbmdzLnZNaW4gPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHZNYXhbMF0gPSB2TWF4WzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHZNaW5bMF0gPSB2TWluWzBdLnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIHNldHRpbmdzLm1JbnRQb3MgPSBNYXRoLm1heCh2TWF4WzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heCh2TWluWzBdLmxlbmd0aCwgMSk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tRGVjID09PSBudWxsKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICAgICAgc2V0dGluZ3Mub0RlYyA9IHNldHRpbmdzLm1EZWM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gTnVtYmVyKHNldHRpbmdzLm1EZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURlY2ltYWwpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLm1EZWMgPSBzZXR0aW5ncy5zY2FsZURlY2ltYWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgYWx0ZXJuYXRpdmUgZGVjaW1hbCBzZXBhcmF0b3Iga2V5XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgPT09IG51bGwgJiYgc2V0dGluZ3MubURlYyA+IDApIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLicgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJywnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJywnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5hRGVjID09PSAnLCcgJiYgc2V0dGluZ3MuYVNlcCAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWx0RGVjID0gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FjaGUgcmVnZXhwcyBmb3IgYXV0b1N0cmlwXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5hTmVnID9gKFstXFxcXCR7c2V0dGluZ3MuYU5lZ31dPylgIDonKC0/KSc7XG4gICAgICAgIHNldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXAgPSBhTmVnUmVnO1xuICAgICAgICBzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9W14tJHsoc2V0dGluZ3MuYU5lZz9gXFxcXCR7c2V0dGluZ3MuYU5lZ31gOicnKX1cXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkXS4qPyhcXFxcZHxcXFxcJHtzZXR0aW5ncy5hRGVjfVxcXFxkKWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYChcXFxcZFxcXFwke3NldHRpbmdzLmFEZWN9PylbXlxcXFwke3NldHRpbmdzLmFEZWN9XFxcXGRdXFxcXEQqJGApO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgW14ke2FsbG93ZWR9XWAsICdnaScpO1xuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuYURlY30/KFxcXFxkK1xcXFwke3NldHRpbmdzLmFEZWN9XFxcXGQrKXwoXFxcXGQqKD86XFxcXCR7c2V0dGluZ3MuYURlY31cXFxcZCopPykpYCk7XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN0cmlwIGFsbCB1bndhbnRlZCBjaGFyYWN0ZXJzIGFuZCBsZWF2ZSBvbmx5IGEgbnVtYmVyIGFsZXJ0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1N0cmlwKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU2lnbiAhPT0gJycpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFTaWduLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTdWZmaXgpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzdWZmaXhcbiAgICAgICAgICAgIHdoaWxlIChjb250YWlucyhzLCBzZXR0aW5ncy5hU3VmZml4KSkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYVN1ZmZpeCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmlyc3QgcmVwbGFjZSBhbnl0aGluZyBiZWZvcmUgZGlnaXRzXG4gICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwLCAnJDEkMicpO1xuXG4gICAgICAgIGlmICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIGNvbnRhaW5zKHMsICctJykgJiYgcyAhPT0gJycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlbiByZXBsYWNlIGFueXRoaW5nIGFmdGVyIGRpZ2l0c1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLnNraXBMYXN0QXV0b1N0cmlwLCAnJDEnKTtcblxuICAgICAgICAvLyB0aGVuIHJlbW92ZSBhbnkgdW5pbnRlcmVzdGVkIGNoYXJhY3RlcnNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hbGxvd2VkQXV0b1N0cmlwLCAnJyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuYWx0RGVjLCBzZXR0aW5ncy5hRGVjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBvbmx5IG51bWJlciBzdHJpbmdcbiAgICAgICAgY29uc3QgbSA9IHMubWF0Y2goc2V0dGluZ3MubnVtUmVnQXV0b1N0cmlwKTtcbiAgICAgICAgcyA9IG0gPyBbbVsxXSwgbVsyXSwgbVszXV0uam9pbignJykgOiAnJztcbiAgICAgICAgaWYgKHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnIHx8IHNldHRpbmdzLmxaZXJvID09PSAna2VlcCcpIHtcbiAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmFEZWMpO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkSW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgIGlmIChjb250YWlucyhtb2RpZmllZEludGVnZXJQYXJ0LCBzZXR0aW5ncy5hTmVnKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5yZXBsYWNlKHNldHRpbmdzLmFOZWcsICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIHBvc2l0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50UG9zICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgIGlmIChuU2lnbiAhPT0gJycgJiYgbW9kaWZpZWRJbnRlZ2VyUGFydC5sZW5ndGggPiBzZXR0aW5ncy5tSW50TmVnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEludGVnZXJQYXJ0ID0gbW9kaWZpZWRJbnRlZ2VyUGFydC5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5sWmVybyA9PT0gJ2RlbnknKSB8fCAoc2V0dGluZ3MubFplcm8gPT09ICdhbGxvdycgJiYgc2V0dGluZ3Mub25PZmYgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gVXNpbmcgdGhpcyByZWdleCB2ZXJzaW9uIGBeJHtzZXR0aW5ncy5hTmVnUmVnQXV0b1N0cmlwfTAqKFxcXFxkfCQpYCBlbnRpcmVseSBjbGVhciB0aGUgaW5wdXQgb24gYmx1clxuICAgICAgICAgICAgbGV0IHN0cmlwUmVnID0gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGQpYDtcbiAgICAgICAgICAgIHN0cmlwUmVnID0gbmV3IFJlZ0V4cChzdHJpcFJlZyk7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHN0cmlwUmVnLCAnJDEkMicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcGxhY2VzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICgoc2V0dGluZ3MucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdEJyYWNrZXQsIGxhc3RCcmFja2V0XSA9IHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9uT2ZmKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5hTmVnLCAnJyk7XG4gICAgICAgICAgICAgICAgcyA9IGZpcnN0QnJhY2tldCArIHMgKyBsYXN0QnJhY2tldDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mub25PZmYgJiYgcy5jaGFyQXQoMCkgPT09IGZpcnN0QnJhY2tldCkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZmlyc3RCcmFja2V0LCBzZXR0aW5ncy5hTmVnKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGxhc3RCcmFja2V0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IGxvY2FsZSBmb3JtYXQgdG8gSmF2YXNjcmlwdCBudW1lcmljIHN0cmluZ1xuICAgICAqIGFsbG93cyBsb2NhbGUgZGVjaW1hbCBzZXBhcmF0b3IgdG8gYmUgYSBwZXJpb2Qgb3IgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZCBvZiBjdXJyZW5jeSBzaWducyBhbGxvd2VkXG4gICAgICogJzEyMzQuNTYnICAgIE9LXG4gICAgICogJy0xMjM0LjU2JyAgIE9LXG4gICAgICogJzEyMzQuNTYtJyAgIE9LXG4gICAgICogJzEyMzQsNTYnICAgIE9LXG4gICAgICogJy0xMjM0LDU2JyAgIE9LXG4gICAgICogJzEyMzQsNTYtJyAgIE9LXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUxvY2FsZShzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBpZiAoY29udGFpbnMocywgJy0nKSAmJiBzLmxhc3RJbmRleE9mKCctJykgPT09IHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgIHMgPSAnLScgKyBzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50XG4gICAgICogc2VlIFwibG9jYWxlT3V0cHV0XCIgb3B0aW9uIGZvciBkZXRlcm1pbmVcbiAgICAgKiBudWxsID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gZGVmYXVsdFxuICAgICAqIFwiLFwiICA9PiBubm5uLG5uIG9yIC1ubm5uLG5uIGNhbiBhbHMgYmUgXCItLFwiXG4gICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgKiBcIiwtXCIgPT4gbm5ubixubiBvciBubm5uLG5uLVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG9jYWxlKHZhbHVlLCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gJy4tJykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb250YWlucyh2YWx1ZSwgJy0nKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlID09PSAnLCcgfHwgbG9jYWxlID09PSAnLSwnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUgPT09ICcsLScpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgnLicsICcsJyk7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5zKHZhbHVlLCAnLScpID8gdmFsdWUucmVwbGFjZSgnLScsICcnKSArICctJyA6IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgbnVtYmVyIHN0cmluZyB0byBiZSBjb252ZXJ0ZWQgdG8gcmVhbCBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaXhOdW1iZXIocywgYURlYywgYU5lZykge1xuICAgICAgICBpZiAoYURlYyAmJiBhRGVjICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYURlYywgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYU5lZyAmJiBhTmVnICE9PSAnLScpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYU5lZywgJy0nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXMubWF0Y2goL1xcZC8pKSB7XG4gICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXBhcmUgcmVhbCBudW1iZXIgdG8gYmUgY29udmVydGVkIHRvIG91ciBmb3JtYXRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVzZW50TnVtYmVyKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hTmVnICYmIHNldHRpbmdzLmFOZWcgIT09ICctJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLScsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5hRGVjICYmIHNldHRpbmdzLmFEZWMgIT09ICcuJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZSgnLicsIHNldHRpbmdzLmFEZWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0byBjaGVjayBmb3IgZW1wdHkgdmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0VtcHR5KGl2LCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGl2ID09PSAnJyB8fCBpdiA9PT0gc2V0dGluZ3MuYU5lZykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLndFbXB0eSA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLnBOZWcgPT09ICdsJykgPyBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYVN1ZmZpeCA6IHNldHRpbmdzLmFTaWduICsgaXYgKyBzZXR0aW5ncy5hU3VmZml4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl2O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJpdmF0ZSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgb3VyIG51bWJlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9Hcm91cChpdiwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpdiA9IGF1dG9TdHJpcChpdiwgc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmICFjb250YWlucyhpdiwgJy0nKSkge1xuICAgICAgICAgICAgaXYgPSAnLScgKyBpdjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbXB0eSA9IGNoZWNrRW1wdHkoaXYsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaXNOZWcgPSBjb250YWlucyhpdiwgJy0nKTtcbiAgICAgICAgaWYgKGlzTmVnKSB7XG4gICAgICAgICAgICBpdiA9IGl2LnJlcGxhY2UoJy0nLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtcHR5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRpZ2l0YWxHcm91cCA9ICcnO1xuICAgICAgICBzZXR0aW5ncy5kR3JvdXAgPSBzZXR0aW5ncy5kR3JvdXAudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzInKSB7XG4gICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZCkoXFxkezJ9PykrKSQvO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRHcm91cCA9PT0gJzJzJykge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XG4gICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3MuZEdyb3VwID09PSAnNCcpIHtcbiAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezR9PykrKSQvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKChcXGR7M30/KSspJC87XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzcGxpdHMgdGhlIHN0cmluZyBhdCB0aGUgZGVjaW1hbCBzdHJpbmdcbiAgICAgICAgbGV0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gaXYuc3BsaXQoc2V0dGluZ3MuYURlYyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hbHREZWMgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGl2LnNwbGl0KHNldHRpbmdzLmFsdERlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLmFTZXAgIT09ICcnKSB7XG4gICAgICAgICAgICAvLyByZS1pbnNlcnRzIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdmlhIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlnaXRhbEdyb3VwLnRlc3QoaW50ZWdlclBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaW50ZWdlclBhcnQgPSBpbnRlZ2VyUGFydC5yZXBsYWNlKGRpZ2l0YWxHcm91cCwgYCQxJHtzZXR0aW5ncy5hU2VwfSQyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldHRpbmdzLm1EZWMgIT09IDAgJiYgIWlzVW5kZWZpbmVkKGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxQYXJ0Lmxlbmd0aCA+IHNldHRpbmdzLm1EZWMpIHtcbiAgICAgICAgICAgICAgICBkZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5tRGVjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gam9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0ICsgc2V0dGluZ3MuYURlYyArIGRlY2ltYWxQYXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2hvbGUgbnVtYmVycyBvbmx5XG4gICAgICAgICAgICBpdiA9IGludGVnZXJQYXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3AnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hTmVnICsgc2V0dGluZ3MuYVNpZ24gKyBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBpdiA9IHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZyArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYVNpZ24gKyBpdiArIHNldHRpbmdzLmFOZWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBzZXR0aW5ncy5hU2lnbiArIGl2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNOZWcgJiYgc2V0dGluZ3MucE5lZyA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduICsgc2V0dGluZ3MuYU5lZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05lZyAmJiBzZXR0aW5ncy5wTmVnID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBpdiA9IGl2ICsgc2V0dGluZ3MuYU5lZyArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmVnICYmIHNldHRpbmdzLnBOZWcgPT09ICdwJykge1xuICAgICAgICAgICAgICAgIGl2ID0gc2V0dGluZ3MuYU5lZyArIGl2ICsgc2V0dGluZ3MuYVNpZ247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmVnKSB7XG4gICAgICAgICAgICAgICAgaXYgPSBpdiArIHNldHRpbmdzLmFTaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgcGxhY2VzIGJyYWNrZXRzXG4gICAgICAgIGlmIChzZXR0aW5ncy5uQnJhY2tldCAhPT0gbnVsbCAmJiAoc2V0dGluZ3MucmF3VmFsdWUgPCAwIHx8IGl2LmNoYXJBdCgwKSA9PT0gJy0nKSkge1xuICAgICAgICAgICAgaXYgPSBuZWdhdGl2ZUJyYWNrZXQoaXYsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGl2ICsgc2V0dGluZ3MuYVN1ZmZpeDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcnVuY2F0ZSBub3QgbmVlZGVkIHplcm9zXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHJEZWMpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZWdleCA9IC8oXFwuXFxkKD86XFxkKlsxLTldKT8pMCokLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgKFxcXFwuXFxcXGR7JHtyRGVjfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcbiAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UocmVnZXgsICckMScpO1xuICAgICAgICBpZiAockRlYyA9PT0gMCkge1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaXZSb3VuZGVkLnJlcGxhY2UoL1xcLiQvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXZSb3VuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJvdW5kIG51bWJlciBhZnRlciBzZXR0aW5nIGJ5IHBhc3Rpbmcgb3IgJCgpLmF1dG9OdW1lcmljU2V0KClcbiAgICAgKiBwcml2YXRlIGZ1bmN0aW9uIGZvciByb3VuZCB0aGUgbnVtYmVyXG4gICAgICogcGxlYXNlIG5vdGUgdGhpcyBoYW5kbGVkIGFzIHRleHQgLSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlc1xuICAgICAqIGFsc28gdGhpcyBvZmZlcnMgbXVsdGlwbGUgcm91bmRpbmcgbWV0aG9kcyB0aGF0IGFyZSBub3QgZWFzaWx5IGFjY29tcGxpc2hlZCBpbiBKYXZhU2NyaXB0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1JvdW5kKGl2LCBzZXR0aW5ncykgeyAvLyB2YWx1ZSB0byBzdHJpbmdcbiAgICAgICAgaXYgPSAoaXYgPT09ICcnKSA/ICcwJyA6IGl2LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5tUm91bmQgPT09ICdOMDUnIHx8IHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0NIRicgfHwgc2V0dGluZ3MubVJvdW5kID09PSAnVTA1JyB8fCBzZXR0aW5ncy5tUm91bmQgPT09ICdEMDUnKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm1Sb3VuZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ04wNSc6XG4gICAgICAgICAgICAgICAgICAgIGl2ID0gKE1hdGgucm91bmQoaXYgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVTA1JzpcbiAgICAgICAgICAgICAgICAgICAgaXYgPSAoTWF0aC5jZWlsKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICBpdiA9IChNYXRoLmZsb29yKGl2ICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGl2LCAnLicpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaXYgKyAnLjAwJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoIC0gaXYuaW5kZXhPZignLicpIDwgMykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl2ICsgJzAnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXZSb3VuZGVkID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgIGxldCByRGVjO1xuXG4gICAgICAgIGlmICh0eXBlb2Yoc2V0dGluZ3MuYVBhZCkgPT09ICdib29sZWFuJyB8fCBzZXR0aW5ncy5hUGFkID09PSBudWxsKSB7XG4gICAgICAgICAgICByRGVjID0gc2V0dGluZ3MuYVBhZD9zZXR0aW5ncy5tRGVjOjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByRGVjID0gTnVtYmVyKHNldHRpbmdzLmFQYWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBpdiAoaW5wdXQgVmFsdWUpaXMgYSBuZWdhdGl2ZSB2YWx1ZVxuICAgICAgICBpZiAoaXYuY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG5TaWduID0gJy0nO1xuXG4gICAgICAgICAgICAvLyByZW1vdmVzIHRoZSBuZWdhdGl2ZSBzaWduIHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYXBwZW5kIGEgemVybyBpZiBmaXJzdCBjaGFyYWN0ZXIgaXMgbm90IGEgZGlnaXQgKHRoZW4gaXQgaXMgbGlrZWx5IHRvIGJlIGEgZG90XG4gICAgICAgIGlmICghaXYubWF0Y2goL15cXGQvKSkge1xuICAgICAgICAgICAgaXYgPSAnMCcgKyBpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIHplcm8gLSBpZiB6ZXJvIG5vIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKG5TaWduID09PSAnLScgJiYgTnVtYmVyKGl2KSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaW1zIGxlYWRpbmcgemVybydzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpdikgPiAwICYmIHNldHRpbmdzLmxaZXJvICE9PSAna2VlcCcpIHx8IChpdi5sZW5ndGggPiAwICYmIHNldHRpbmdzLmxaZXJvID09PSAnYWxsb3cnKSkge1xuICAgICAgICAgICAgaXYgPSBpdi5yZXBsYWNlKC9eMCooXFxkKS8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZFBvcyA9IGl2Lmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgLy8gdmlydHVhbCBkZWNpbWFsIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHZkUG9zID0gKGRQb3MgPT09IC0xKSA/IGl2Lmxlbmd0aCAtIDEgOiBkUG9zO1xuXG4gICAgICAgIC8vIGNoZWNrcyBkZWNpbWFsIHBsYWNlcyB0byBkZXRlcm1pbmUgaWYgcm91bmRpbmcgaXMgcmVxdWlyZWQgOlxuICAgICAgICAvLyBjaGVjayBpZiBubyByb3VuZGluZyBpcyByZXF1aXJlZFxuICAgICAgICBsZXQgY0RlYyA9IChpdi5sZW5ndGggLSAxKSAtIHZkUG9zO1xuICAgICAgICBpZiAoY0RlYyA8PSBzZXR0aW5ncy5tRGVjKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHBhZCB3aXRoIHplcm9zXG4gICAgICAgICAgICBpdlJvdW5kZWQgPSBpdjtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgckRlYykge1xuICAgICAgICAgICAgICAgIGlmIChkUG9zID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gc2V0dGluZ3MuYURlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHplcm9zID0gJzAwMDAwMCc7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNEZWMgPCByRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHJEZWMgLSBjRGVjKTtcbiAgICAgICAgICAgICAgICAgICAgaXZSb3VuZGVkICs9IHplcm9zO1xuICAgICAgICAgICAgICAgICAgICBjRGVjICs9IHplcm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNEZWMgPiByRGVjKSB7XG4gICAgICAgICAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdlJvdW5kZWQsIHJEZWMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHJEZWMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpdlJvdW5kZWQgPSBpdlJvdW5kZWQucmVwbGFjZSgvXFwuJC8sICcnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIoaXZSb3VuZGVkKSA9PT0gMCkgPyBpdlJvdW5kZWQgOiBuU2lnbiArIGl2Um91bmRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvdW5kZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgYWZ0ZXIgcm91bmRpbmdcbiAgICAgICAgY29uc3Qgckxlbmd0aCA9IGRQb3MgKyBzZXR0aW5ncy5tRGVjOyAvL1RPRE8gTW9kaWZ5IGBkUG9zYCBoZXJlIGlmIGl0J3Mgbm90IGludGVuZGVkIHRoYXQgaXQgY2FuIGJlIGVxdWFsIHRvICctMSdcbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGl2LmNoYXJBdChyTGVuZ3RoICsgMSkpO1xuICAgICAgICBjb25zdCBvZGQgPSAoaXYuY2hhckF0KHJMZW5ndGgpID09PSAnLicpID8gKGl2LmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpdi5jaGFyQXQockxlbmd0aCkgJSAyKTtcbiAgICAgICAgbGV0IGl2QXJyYXkgPSBpdi5zdWJzdHJpbmcoMCwgckxlbmd0aCArIDEpLnNwbGl0KCcnKTtcbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgdXAgc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdzJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gc3ltbWV0cmljXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdBJyAmJiBuU2lnbiA9PT0gJycpICB8fCAvLyBSb3VuZCBoYWxmIGRvd24gYXN5bW1ldHJpYyBwb3NpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQicpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA9PT0gNSAmJiBzZXR0aW5ncy5tUm91bmQgPT09ICdCJyAmJiBvZGQgPT09IDEpICAgfHwgLy8gUm91bmQgaGFsZiBldmVuIFwiQmFua2VyJ3MgUm91bmRpbmdcIlxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLm1Sb3VuZCA9PT0gJ0YnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIHRvIGZsb29yIHRvd2FyZCBuZWdhdGl2ZSBpbmZpbml0ZVxuICAgICAgICAgICAgKHRSb3VuZCA+IDAgJiYgc2V0dGluZ3MubVJvdW5kID09PSAnVScpKSB7ICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXAgYXdheSBmcm9tIHplcm9cbiAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRoZSBsYXN0IGRpZ2l0IGlmIHJlcXVpcmVkLCBhbmQgY29udGludWUgdW50aWwgbm8gbW9yZSA5J3MgYXJlIGZvdW5kXG4gICAgICAgICAgICBmb3IgKGkgPSAoaXZBcnJheS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSAhPT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGl2QXJyYXlbaV0gPSAraXZBcnJheVtpXSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdkFycmF5W2ldIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyByZXR1cm4gcm91bmRlZCB2YWx1ZVxuICAgICAgICBpdlJvdW5kZWQgPSB0cnVuY2F0ZVplcm9zKGl2QXJyYXkuam9pbignJyksIHJEZWMpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZURlY2ltYWwocywgc2V0dGluZ3MsIHBhc3RlKSB7XG4gICAgICAgIGNvbnN0IGFEZWMgPSBzZXR0aW5ncy5hRGVjO1xuICAgICAgICBjb25zdCBtRGVjID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgcyA9IChwYXN0ZSA9PT0gJ3Bhc3RlJykgPyBhdXRvUm91bmQocywgc2V0dGluZ3MpIDogcztcbiAgICAgICAgaWYgKGFEZWMgJiYgbURlYykge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KGFEZWMpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gbURlYykge1xuICAgICAgICAgICAgICAgIGlmIChtRGVjID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc3Vic3RyaW5nKDAsIG1EZWMpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHthRGVjfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSB2TWluLCB2TWF4ICYgdGhlIGlucHV0IHZhbHVlIHRvIHByZXBhcmUgZm9yIHRlc3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSB2YWx1ZSBmYWxscyB3aXRoaW4gdGhlIG1pbiAvIG1heCByYW5nZVxuICAgICAqIFJldHVybiBhbiBvYmplY3QgZXhhbXBsZTogdk1pbjogXCI5OTk5OTk5OTk5OTk5OTkuOTlcIiByZXR1cm5zIHRoZSBmb2xsb3dpbmcgXCJ7czogLTEsIGU6IDEyLCBjOiBBcnJheVsxNV19XCJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGFkYXB0ZWQgZnJvbSBCaWcuanMgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnLmpzL1xuICAgICAqIE1hbnkgdGhhbmtzIHRvIE1pa2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTtcbiAgICAgICAgbGV0IGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBsZXQgbkw7XG4gICAgICAgIGxldCBqO1xuXG4gICAgICAgIC8vIE1pbnVzIHplcm8/XG4gICAgICAgIGlmIChuID09PSAwICYmIDEgLyBuIDwgMCkge1xuICAgICAgICAgICAgbiA9ICctMCc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgc2lnbi4gMSBwb3NpdGl2ZSwgLTEgbmVnYXRpdmVcbiAgICAgICAgbiA9IG4udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG4uY2hhckF0KDApID09PSAnLScpIHtcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKDEpO1xuICAgICAgICAgICAgeC5zID0gLTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4LnMgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cbiAgICAgICAgZSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZSA+IC0xKSB7XG4gICAgICAgICAgICBuID0gbi5yZXBsYWNlKCcuJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGVuZ3RoIG9mIHN0cmluZyBpZiBubyBkZWNpbWFsIGNoYXJhY3RlclxuICAgICAgICBpZiAoZSA8IDApIHtcbiAgICAgICAgICAgIC8vIEludGVnZXJcbiAgICAgICAgICAgIGUgPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zXG4gICAgICAgIGkgPSAobi5zZWFyY2goL1sxLTldL2kpID09PSAtMSkgPyBuLmxlbmd0aCA6IG4uc2VhcmNoKC9bMS05XS9pKTtcbiAgICAgICAgbkwgPSBuLmxlbmd0aDtcbiAgICAgICAgaWYgKGkgPT09IG5MKSB7XG4gICAgICAgICAgICAvLyBaZXJvXG4gICAgICAgICAgICB4LmUgPSAwO1xuICAgICAgICAgICAgeC5jID0gWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGogPSBuTCAtIDE7IG4uY2hhckF0KGopID09PSAnMCc7IGogLT0gMSkge1xuICAgICAgICAgICAgICAgIG5MIC09IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuTCAtPSAxO1xuXG4gICAgICAgICAgICAvLyBEZWNpbWFsIGxvY2F0aW9uXG4gICAgICAgICAgICB4LmUgPSBlIC0gaSAtIDE7XG4gICAgICAgICAgICB4LmMgPSBbXTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gYXJyYXkgb2YgZGlnaXRzIHdpdGhvdXQgbGVhZGluZy90cmFpbGluZyB6ZXJvc1xuICAgICAgICAgICAgZm9yIChlID0gMDsgaSA8PSBuTDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgeC5jW2VdID0gK24uY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHRvIHRlc3QgaWYgdGhlIGlucHV0IHZhbHVlIGZhbGxzIHdpdGggdGhlIE1pbiAvIE1heCBzZXR0aW5nc1xuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvblxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvXG4gICAgICogTWFueSB0aGFua3MgdG8gTWlrZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlc3RNaW5NYXgoeSwgeCkge1xuICAgICAgICBjb25zdCB4YyA9IHguYztcbiAgICAgICAgY29uc3QgeWMgPSB5LmM7XG4gICAgICAgIGxldCBpID0geC5zO1xuICAgICAgICBsZXQgaiA9IHkucztcbiAgICAgICAgbGV0IGsgPSB4LmU7XG4gICAgICAgIGxldCBsID0geS5lO1xuXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICgheGNbMF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAheWNbMF0/MDotajtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaWducyBkaWZmZXI/XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4TmVnID0gaSA8IDA7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHNcbiAgICAgICAgaWYgKGsgIT09IGwpIHtcbiAgICAgICAgICAgIHJldHVybiAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG4gICAgICAgIGkgPSAtMTtcbiAgICAgICAgayA9IHhjLmxlbmd0aDtcbiAgICAgICAgbCA9IHljLmxlbmd0aDtcbiAgICAgICAgaiA9IChrIDwgbCkgPyBrIDogbDtcblxuICAgICAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0XG4gICAgICAgIGZvciAoaSArPSAxOyBpIDwgajsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeGNbaV0gIT09IHljW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh4Y1tpXSA+IHljW2ldIF4geE5lZyk/MTotMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXBhcmUgbGVuZ3Roc1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoayA9PT0gbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IChrID4gbCBeIHhOZWcpPzE6LTE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNraW5nIHRoYXQgbnVtYmVyIHNhdGlzZnkgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLnZNaW4gYW5kIHNldHRpbmdzLnZNYXhcbiAgICAgKiBhbmQgdGhlIHN0cmluZyBsZW5ndGggZG9lcyBub3QgZXhjZWVkIHRoZSBkaWdpdHMgaW4gc2V0dGluZ3Mudk1pbiBhbmQgc2V0dGluZ3Mudk1heFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF1dG9DaGVjayhzLCBzZXR0aW5ncykge1xuICAgICAgICBzID0gcy50b1N0cmluZygpO1xuICAgICAgICBzID0gcy5yZXBsYWNlKCcsJywgJy4nKTtcbiAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWluKTtcbiAgICAgICAgY29uc3QgbWF4UGFyc2UgPSBwYXJzZVN0cihzZXR0aW5ncy52TWF4KTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm9MaW1pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2VpbGluZyc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdHJ1ZSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0ZXN0TWluTWF4KG1pblBhcnNlLCB2YWxQYXJzZSkgPiAtMSwgdGVzdE1pbk1heChtYXhQYXJzZSwgdmFsUGFyc2UpIDwgMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoYW5rcyB0byBBbnRob255ICYgRXZhbiBDXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b0dldChvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnIHx8IG9iaiBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgb2JqID0gb2JqLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9dL2csICdcXFxcXScpO1xuICAgICAgICAgICAgb2JqID0gJyMnICsgb2JqLnJlcGxhY2UoLyg6fFxcLikvZywgJ1xcXFwkMScpO1xuICAgICAgICAgICAgLy8gcG9zc2libGUgbW9kaWZpY2F0aW9uIHRvIHJlcGxhY2UgdGhlIGFib3ZlIDIgbGluZXNcbiAgICAgICAgICAgIC8vIG9iaiA9ICcjJyArIG9iai5yZXBsYWNlKC8oWzsmLFxcLlxcK1xcKlxcfic6XCJcXCFcXF4jJCVAXFxbXFxdXFwoXFwpPT5cXHxdKS9nLCAnXFxcXCQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJChvYmopO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRvIGF0dGFjaCBkYXRhIHRvIHRoZSBlbGVtZW50XG4gICAgICogYW5kIGltaXRhdGUgdGhlIGhvbGRlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcigkdGhhdCwgc2V0dGluZ3MsIHVwZGF0ZSkge1xuICAgICAgICBsZXQgZGF0YSA9ICR0aGF0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgICAgICAgJHRoYXQuZGF0YSgnYXV0b051bWVyaWMnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaG9sZGVyID0gZGF0YS5ob2xkZXI7XG4gICAgICAgIGlmICgoaXNVbmRlZmluZWQoaG9sZGVyKSAmJiBzZXR0aW5ncykgfHwgdXBkYXRlKSB7XG4gICAgICAgICAgICBob2xkZXIgPSBuZXcgQXV0b051bWVyaWNIb2xkZXIoJHRoYXQuZ2V0KDApLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBkYXRhLmhvbGRlciA9IGhvbGRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3JpZ2luYWwgc2V0dGluZ3Mgc2F2ZWQgZm9yIHVzZSB3aGVuIGVEZWMgJiBuU2VwIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvcmlnaW5hbFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MubURlYztcbiAgICAgICAgc2V0dGluZ3Mub1BhZCAgICAgPSBzZXR0aW5ncy5hUGFkO1xuICAgICAgICBzZXR0aW5ncy5vQnJhY2tldCA9IHNldHRpbmdzLm5CcmFja2V0O1xuICAgICAgICBzZXR0aW5ncy5vU2VwICAgICA9IHNldHRpbmdzLmFTZXA7XG4gICAgICAgIHNldHRpbmdzLm9TaWduICAgID0gc2V0dGluZ3MuYVNpZ247XG5cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBlRGVjICYgblNlcCBvcHRpb25zIGFyZSBiZWluZyB1c2VkXG4gICAgICogdGFrZW4gZnJvbSBRdWlya3Ntb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVhZENvb2tpZShuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVFUSA9IG5hbWUgKyAnPSc7XG4gICAgICAgIGNvbnN0IGNhID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG4gICAgICAgIGxldCBjID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2EubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PT0gJyAnKSB7XG4gICAgICAgICAgICAgICAgYyA9IGMuc3Vic3RyaW5nKDEsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjLmluZGV4T2YobmFtZUVRKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHNlc3Npb25TdG9yYWdlIGlzIHN1cHBvcnRlZCAtIHRha2VuIGZyb20gbW9kZXJuaXpyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RvcmFnZVRlc3QoKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9ICdtb2Rlcm5penInO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShtb2QsIG1vZCk7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKG1vZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gYnJvd3NlciBzdXBwb3J0XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCB0b0RvKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9ICgkdGhpc1swXS5uYW1lICE9PSAnJyAmJiAhaXNVbmRlZmluZWQoJHRoaXNbMF0ubmFtZSkpID9gQVVUT18ke2RlY29kZVVSSUNvbXBvbmVudCgkdGhpc1swXS5uYW1lKX1gIDpgQVVUT18keyR0aGlzWzBdLmlkfWA7XG4gICAgICAgICAgICBsZXQgZGF0ZTtcbiAgICAgICAgICAgIGxldCBleHBpcmVzO1xuXG4gICAgICAgICAgICAvLyBzZXRzIGNvb2tpZSBmb3IgYnJvd3NlciB0aGF0IGRvIG5vdCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlIElFIDYgJiBJRSA3XG4gICAgICAgICAgICBpZiAoc3RvcmFnZVRlc3QoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke3N0b3JlZE5hbWV9PSR7c2V0dGluZ3MucmF3VmFsdWV9OyBleHBpcmVzPSA7IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnd2lwZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArICgtMSAqIDI0ICogNjAgKiA2MCAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGlyZXMgPSAnOyBleHBpcmVzPScgKyBkYXRlLnRvVVRDU3RyaW5nKCk7IC8vIE5vdGUgOiBgdG9HTVRTdHJpbmcoKWAgaGFzIGJlZW4gZGVwcmVjYXRlZCAoY2YuIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9HTVRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0nJyA7JHtleHBpcmVzfTsgcGF0aD0vYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRDb29raWUoc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvRG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIEF1dG9OdW1lcmljSG9sZGVyKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy50aGF0ID0gdGhhdDtcbiAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICB9XG5cbiAgICBBdXRvTnVtZXJpY0hvbGRlci5wcm90b3R5cGUgPSB7XG4gICAgICAgIGluaXQoZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGhhdC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NDbG9uZSA9IGF1dG9Db2RlKHRoaXMuJHRoYXQsIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5jdHJsS2V5ID0gZS5jdHJsS2V5O1xuICAgICAgICAgICAgdGhpcy5jbWRLZXkgPSBlLm1ldGFLZXk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0S2V5ID0gZS5zaGlmdEtleTtcblxuICAgICAgICAgICAgLy8ga2V5cHJlc3MgZXZlbnQgb3ZlcndyaXRlcyBtZWFuaW5nZnVsIHZhbHVlIG9mIGUua2V5Q29kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCk7XG4gICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgfHwgZS50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZENvZGUgPSBlLmtleUNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndoaWNoID0gZS53aGljaDtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFNlbGVjdGlvbihzdGFydCwgZW5kLCBzZXRSZWFsKSB7XG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBlbmQgLSBzdGFydCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQoc2V0UmVhbCkgfHwgc2V0UmVhbCkge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlcigpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgdGhpcy5zZWxlY3Rpb24uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB2YWx1ZS5zdWJzdHJpbmcodGhpcy5zZWxlY3Rpb24uZW5kLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRCZWZvcmVBZnRlclN0cmlwZWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyKCk7XG4gICAgICAgICAgICBsZWZ0ID0gYXV0b1N0cmlwKGxlZnQsIHRoaXMuc2V0dGluZ3NDbG9uZSk7XG4gICAgICAgICAgICByaWdodCA9IGF1dG9TdHJpcChyaWdodCwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWNvbnRhaW5zKGxlZnQsICctJykpIHtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gJy0nICsgbGVmdDtcbiAgICAgICAgICAgICAgICByaWdodCA9IChyaWdodCA9PT0gJy0nKSA/ICcnIDogcmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0cmlwIHBhcnRzIGZyb20gZXhjZXNzIGNoYXJhY3RlcnMgYW5kIGxlYWRpbmcgemVyb2VzXG4gICAgICAgICAqL1xuICAgICAgICBub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gcHJldmVudHMgbXVsdGlwbGUgbGVhZGluZyB6ZXJvcyBmcm9tIGJlaW5nIGVudGVyZWRcbiAgICAgICAgICAgIGxlZnQgPSBhdXRvU3RyaXAobGVmdCwgc2V0dGluZ3NDbG9uZSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBhRGVjLFxuICAgICAgICAgICAgcmlnaHQgPSBhdXRvU3RyaXAocmlnaHQsIHNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhY29udGFpbnMobGVmdCwgJy0nKSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChsZWZ0ID09PSAnJyB8fCBsZWZ0ID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIHNldHRpbmdzQ2xvbmUubFplcm8gPT09ICdkZW55Jykge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodCA+ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQucmVwbGFjZSgvXjAqKFxcZCkvLCAnJDEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5hRGVjfWApKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldCBwYXJ0IG9mIG51bWJlciB0byB2YWx1ZSBrZWVwaW5nIHBvc2l0aW9uIG9mIGN1cnNvclxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgYWR2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLm5vcm1hbGl6ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgIGlmIChtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gdHJ1bmNhdGVEZWNpbWFsKHRoaXMubmV3VmFsdWUsIHNldHRpbmdzQ2xvbmUsIGFkdmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUucmF3VmFsdWUgPSB0ZXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA+IHRoaXMubmV3VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gdGhpcy5uZXdWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24ocG9zaXRpb24sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciBleHBhbmRTZWxlY3Rpb25PblNpZ25cbiAgICAgICAgICogcmV0dXJucyBzaWduIHBvc2l0aW9uIG9mIGEgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBzaWduUG9zaXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgYVNpZ24gPSBzZXR0aW5nc0Nsb25lLmFTaWduO1xuICAgICAgICAgICAgY29uc3QgdGhhdCA9IHRoaXMudGhhdDtcbiAgICAgICAgICAgIGlmIChhU2lnbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTaWduTGVuID0gYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzTmVnID0gc2V0dGluZ3NDbG9uZS5hTmVnICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUuYU5lZztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc05lZyA/IFsxLCBhU2lnbkxlbiArIDFdIDogWzAsIGFTaWduTGVuXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGF0LnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlTGVuIC0gYVNpZ25MZW4sIHZhbHVlTGVuXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFsxMDAwLCAtMV07XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGV4cGFuZHMgc2VsZWN0aW9uIHRvIGNvdmVyIHdob2xlIHNpZ25cbiAgICAgICAgICogcHJldmVudHMgcGFydGlhbCBkZWxldGlvbi9jb3B5aW5nL292ZXJ3cml0aW5nIG9mIGEgc2lnblxuICAgICAgICAgKi9cbiAgICAgICAgZXhwYW5kU2VsZWN0aW9uT25TaWduKHNldFJlYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25Qb3NpdGlvbiA9IHRoaXMuc2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gaWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0sIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oc2lnblBvc2l0aW9uWzFdLCBzZWxlY3Rpb24uZW5kLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2Ugc2VsZWN0IHdpdGggd2hvbGUgc2lnblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogdHJ5IHRvIHN0cmlwIHBhc3RlZCB2YWx1ZSB0byBkaWdpdHNcbiAgICAgICAgICovXG4gICAgICAgIGNoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBzdHJpcCBwYXN0ZWQgdmFsdWUgZmlyc3RcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBhdXRvU3RyaXAobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0VmFsdWVQYXJ0cyhtb2RpZmllZExlZnRQYXJ0LCByaWdodCwgJ3Bhc3RlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG9sZFBhcnRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKG9sZFBhcnRzWzBdLmxlbmd0aCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5c1xuICAgICAgICAgKiBpZiByZXR1cm5zIHRydWUsIGZ1cnRoZXIgcHJvY2Vzc2luZyBpcyBub3QgcGVyZm9ybWVkXG4gICAgICAgICAqL1xuICAgICAgICBza2lwQWx3YXlzKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtkQ29kZSA9IHRoaXMua2RDb2RlO1xuICAgICAgICAgICAgY29uc3Qgd2hpY2ggPSB0aGlzLndoaWNoO1xuICAgICAgICAgICAgY29uc3QgY3RybEtleSA9IHRoaXMuY3RybEtleTtcbiAgICAgICAgICAgIGNvbnN0IGNtZEtleSA9IHRoaXMuY21kS2V5O1xuXG4gICAgICAgICAgICAvLyBjYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0S2V5ID0gdGhpcy5zaGlmdEtleTtcbiAgICAgICAgICAgIGlmICgoKGN0cmxLZXkgfHwgY21kS2V5KSAmJiBlLnR5cGUgPT09ICdrZXl1cCcgJiYgIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkgfHwgKHNoaWZ0S2V5ICYmIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBza2lwIEZ4IGtleXMsIHdpbmRvd3Mga2V5cywgb3RoZXIgc3BlY2lhbCBrZXlzXG4gICAgICAgICAgICBpZiAoKGtkQ29kZSA+PSBrZXlDb2RlLkYxICYmIGtkQ29kZSA8PSBrZXlDb2RlLkYxMikgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiBrZENvZGUgPD0ga2V5Q29kZS5SaWdodENsaWNrKSB8fFxuICAgICAgICAgICAgICAgIChrZENvZGUgPj0ga2V5Q29kZS5UYWIgJiYga2RDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcbiAgICAgICAgICAgICAgICAoa2RDb2RlIDwga2V5Q29kZS5CYWNrc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAod2hpY2ggPT09IDAgfHwgd2hpY2ggPT09IGtkQ29kZSkpIHx8XG4gICAgICAgICAgICAgICAga2RDb2RlID09PSBrZXlDb2RlLk51bUxvY2sgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgICAgIGtkQ29kZSA9PT0ga2V5Q29kZS5JbnNlcnQgfHxcbiAgICAgICAgICAgICAgICBrZENvZGUgPT09IGtleUNvZGUuQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBzZWxlY3QgYWxsIChhKVxuICAgICAgICAgICAgaWYgKChjdHJsS2V5IHx8IGNtZEtleSkgJiYga2RDb2RlID09PSBrZXlDb2RlLmEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU2lnbkxlbiA9IHRoaXMuc2V0dGluZ3MuYVNpZ24ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWNvbnRhaW5zKHRoaXMudGhhdC52YWx1ZSwgJy0nKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhU3VmZml4TGVuID0gdGhpcy5zZXR0aW5ncy5hU3VmZml4Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcFNpZ24gPSB0aGlzLnNldHRpbmdzLnBTaWduO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwTmVnID0gdGhpcy5zZXR0aW5ncy5wTmVnO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gKHBOZWcgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgYVNpZ25MZW4gPiAwKT9hU2lnbkxlbiArIDE6YVNpZ25MZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAocFNpZ24gPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBhU3VmZml4TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwTmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IHZhbHVlTGVuIC0gKGFTdWZmaXhMZW4gKyBhU2lnbkxlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSAoYVNpZ25MZW4gPiAwKT92YWx1ZUxlbiAtIChhU2lnbkxlbiArIG5lZ0xlbiArIGFTdWZmaXhMZW4pOnZhbHVlTGVuIC0gKGFTaWduTGVuICsgYVN1ZmZpeExlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChhU2lnbkxlbiArIGFTdWZmaXhMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLnRoYXQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgY29weSAoYylcbiAgICAgICAgICAgIGlmICgoY3RybEtleSB8fCBjbWRLZXkpICYmIChrZENvZGUgPT09IGtleUNvZGUuYyB8fCBrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTZWxlY3Rpb25PblNpZ24oKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gcHJldmVudCB3cm9uZyBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUudiB8fCBrZENvZGUgPT09IGtleUNvZGUuSW5zZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlUGFydHNCZWZvcmVQYXN0ZSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlLnR5cGUgPT09ICdrZXlkb3duJyB8fCBlLnR5cGUgPT09ICdrZXlwcmVzcycgfHwga2RDb2RlID09PSBrZXlDb2RlLmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjdHJsS2V5IHx8IGNtZEtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBqdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgICAgICBpZiAoa2RDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyB8fCBrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFTZXAgPSB0aGlzLnNldHRpbmdzQ2xvbmUuYVNlcDtcbiAgICAgICAgICAgICAgICBjb25zdCBhRGVjID0gdGhpcy5zZXR0aW5nc0Nsb25lLmFEZWM7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRKdW1wID0gdGhpcy5zZWxlY3Rpb24uc3RhcnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nICYmICF0aGlzLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZENvZGUgPT09IGtleUNvZGUuTGVmdEFycm93ICYmICh2YWx1ZS5jaGFyQXQoc3RhcnRKdW1wIC0gMikgPT09IGFTZXAgfHwgdmFsdWUuY2hhckF0KHN0YXJ0SnVtcCAtIDIpID09PSBhRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbihzdGFydEp1bXAgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZENvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJiAodmFsdWUuY2hhckF0KHN0YXJ0SnVtcCArIDEpID09PSBhU2VwIHx8IHZhbHVlLmNoYXJBdChzdGFydEp1bXAgKyAxKSA9PT0gYURlYykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24oc3RhcnRKdW1wICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBrZENvZGUgPj0ga2V5Q29kZS5QYWdlRG93biAmJiBrZENvZGUgPD0ga2V5Q29kZS5Eb3duQXJyb3c7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzVHJhaWxpbmcoW2xlZnQsIHJpZ2h0XSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCAtIDEpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSB0aGlzLnZhbHVlLmxlbmd0aCAtIHNldHRpbmdzQ2xvbmUuYVN1ZmZpeC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkgJiYgc2V0dGluZ3NDbG9uZS5hU3VmZml4ICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgKyBzZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgJy0nKSAmJiB0aGlzLnZhbHVlLmNoYXJBdCh0aGlzLnNlbGVjdGlvbi5zdGFydCkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4odGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykgKyBzZXR0aW5nc0Nsb25lLmFOZWcubGVuZ3RoKSAmJiBjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYU5lZykpIHx8ICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFswXSA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBCb29sZWFuKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpICsgc2V0dGluZ3NDbG9uZS5hTmVnLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnLScgJiYgdGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gKHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpIC0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMCwgbGVmdC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZWZ0ICE9PSAnJyAmJiAhY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gQm9vbGVhbih0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hU2lnbikgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogcHJvY2VzcyBkZWxldGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0Fsd2F5cygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAodGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IHRoaXMua2RDb2RlID09PSBrZXlDb2RlLkRlbGV0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBsZWZ0O1xuICAgICAgICAgICAgICAgIGxldCByaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoc2V0dGluZ3NDbG9uZS5wU2lnbiA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3MnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgKHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ2wnIHx8IHNldHRpbmdzQ2xvbmUucE5lZyA9PT0gJ3InKSkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnModGhpcy52YWx1ZSwgJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2xlZnQsIHJpZ2h0XSA9IHRoaXMucHJvY2Vzc1RyYWlsaW5nKFtsZWZ0LCByaWdodF0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMua2RDb2RlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFNlbGVjdGlvbk9uU2lnbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLmdldEJlZm9yZUFmdGVyU3RyaXBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBwcm9jZXNzIGluc2VydGlvbiBvZiBjaGFyYWN0ZXJzXG4gICAgICAgICAqIHJldHVybnMgdHJ1ZSBpZiBwcm9jZXNzaW5nIHBlcmZvcm1lZFxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2Vzc0tleXByZXNzKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGNDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLndoaWNoKTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5nZXRCZWZvcmVBZnRlclN0cmlwZWQoKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHJ1bGVzIHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGtleSBpcyBwcmVzc2VkIGFsd2F5cyB1c2UgbnVtZXJpYyBwYWQgZG90IHRvIGluc2VydCBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG5vIGRlY2ltYWwgcGFydCBhbGxvd2VkXG4gICAgICAgICAgICBpZiAoY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYURlYyB8fCAoc2V0dGluZ3NDbG9uZS5hbHREZWMgJiYgY0NvZGUgPT09IHNldHRpbmdzQ2xvbmUuYWx0RGVjKSB8fCAoKGNDb2RlID09PSAnLicgfHwgY0NvZGUgPT09ICcsJykgJiYgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5tRGVjIHx8ICFzZXR0aW5nc0Nsb25lLmFEZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGJlZm9yZSBhTmVnIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmFOZWcgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFsbG93IGRlY2ltYWwgY2hhcmFjdGVyIGlmIG90aGVyIGRlY2ltYWwgY2hhcmFjdGVyIHByZXNlbnRcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdCwgc2V0dGluZ3NDbG9uZS5hRGVjKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJpZ2h0LmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5hRGVjKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuYURlYykgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5hRGVjLCByaWdodCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByZXZlbnQgbWludXMgaWYgbm90IGFsbG93ZWRcbiAgICAgICAgICAgIGlmICgoY0NvZGUgPT09ICctJyB8fCBjQ29kZSA9PT0gJysnKSAmJiBzZXR0aW5nc0Nsb25lLmFOZWcgPT09ICctJykge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjYXJldCBpcyBhbHdheXMgYWZ0ZXIgbWludXNcbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgPT09ICdzJykgfHwgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgIT09ICdwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLmFOZWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBzaWduIG9mIG51bWJlciwgcmVtb3ZlIHBhcnQgaWYgc2hvdWxkXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LmNoYXJBdCgwKSA9PT0gJy0nIHx8IGNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdCA9PT0gJycgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUuYU5lZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLmFOZWc7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlIHNpZ24gb2YgbnVtYmVyLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLmFOZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGNDb2RlID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5hTmVnICsgbGVmdCA6IGxlZnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZVBhcnRzKGxlZnQsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdHJ5IHRvIGluc2VydCBkaWdpdCBiZWZvcmUgbWludXNcbiAgICAgICAgICAgIGlmIChjQ29kZSA+PSAnMCcgJiYgY0NvZGUgPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYU5lZyAmJiBsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5hTmVnKSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5hTmVnO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS52TWF4IDw9IDAgJiYgc2V0dGluZ3NDbG9uZS52TWluIDwgc2V0dGluZ3NDbG9uZS52TWF4ICYmICFjb250YWlucyh0aGlzLnZhbHVlLCBzZXR0aW5nc0Nsb25lLmFOZWcpICYmIGNDb2RlICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUuYU5lZyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgY0NvZGUsIHJpZ2h0LCBudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJldmVudCBhbnkgb3RoZXIgY2hhcmFjdGVyXG4gICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvcm1hdHRpbmcgb2YganVzdCBwcm9jZXNzZWQgdmFsdWUgd2l0aCBrZWVwaW5nIG9mIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgZm9ybWF0UXVpY2soZSkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRMZW5ndGggPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga3VDb2RlID0gZS5rZXlDb2RlO1xuICAgICAgICAgICAgbGV0IFtsZWZ0XSA9IHRoaXMuZ2V0QmVmb3JlQWZ0ZXJTdHJpcGVkKCk7XG5cbiAgICAgICAgICAgIC8vIG5vIGdyb3VwaW5nIHNlcGFyYXRvciBhbmQgbm8gY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmFTZXAgID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2VwICE9PSAnJyAgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNlcCkpKSAmJlxuICAgICAgICAgICAgICAgIChzZXR0aW5nc0Nsb25lLmFTaWduID09PSAnJyB8fCAoc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgIWNvbnRhaW5zKGxlZnRMZW5ndGgsIHNldHRpbmdzQ2xvbmUuYVNpZ24pKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgW3N1YlBhcnRzXSA9IGxlZnRMZW5ndGguc3BsaXQoc2V0dGluZ3NDbG9uZS5hRGVjKTtcbiAgICAgICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMoc3ViUGFydHMsICctJykpIHtcbiAgICAgICAgICAgICAgICAgICAgblNpZ24gPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgIHN1YlBhcnRzID0gc3ViUGFydHMucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBzdHJpcCBsZWFkaW5nIHplcm8gb24gcG9zaXRpdmUgdmFsdWUgaWYgbmVlZFxuICAgICAgICAgICAgICAgIGlmIChuU2lnbiA9PT0gJycgJiYgc3ViUGFydHMubGVuZ3RoID4gc2V0dGluZ3NDbG9uZS5tSW50UG9zICYmIGxlZnQuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gc3RyaXAgbGVhZGluZyB6ZXJvIG9uIG5lZ2F0aXZlIHZhbHVlIGlmIG5lZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVmdCA9IG5TaWduICsgbGVmdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdXRvR3JvdXAodGhpcy52YWx1ZSwgdGhpcy5zZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgcmVnZXhwIHdoaWNoIHNlYXJjaGVzIGZvciBjdXJzb3IgcG9zaXRpb24gZnJvbSB1bmZvcm1hdHRlZCBsZWZ0IHBhcnRcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0QXIgPSBsZWZ0LnNwbGl0KCcnKTtcblxuICAgICAgICAgICAgICAgIC8vIGZpeGVzIGNhcmV0IHBvc2l0aW9uIHdpdGggdHJhaWxpbmcgbWludXMgc2lnblxuICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycgfHwgKHNldHRpbmdzQ2xvbmUucFNpZ24gPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLnBOZWcgIT09ICdwJykpICYmIGxlZnRBclswXSA9PT0gJy0nICYmIHNldHRpbmdzQ2xvbmUuYU5lZyAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAnbCcgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncycgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycgJiYgc2V0dGluZ3NDbG9uZS5wTmVnID09PSAncicgJiYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlIHx8IGt1Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJiBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmFTaWduLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZUNociA9IFsnXFxcXCcsICdeJywgJyQnLCAnLicsICd8JywgJz8nLCAnKicsICcrJywgJygnLCAnKScsICdbJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVkUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pUGFydHMgPSBzaWduUGFydHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheShtaW5pUGFydHMsIGVzY2FwZUNocikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVkUGFydHMucHVzaChtaW5pUGFydHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGt1Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5rZENvZGUgPT09IGtleUNvZGUuQmFja3NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVzaGluZyB0aGUgZXNjYXBlZCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9IEJvb2xlYW4oZS50eXBlID09PSAna2V5ZG93bicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZWZ0QXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWZ0QXJbaV0ubWF0Y2goJ1xcXFxkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRBcltpXSA9ICdcXFxcJyArIGxlZnRBcltpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRSZWcgPSBuZXcgUmVnRXhwKCdeLio/JyArIGxlZnRBci5qb2luKCcuKj8nKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBzZWFyY2ggY3Vyc29yIHBvc2l0aW9uIGluIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0xlZnQgPSB2YWx1ZS5tYXRjaChsZWZ0UmVnKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3TGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IG5ld0xlZnRbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBqdXN0IGJlZm9yZSBzaWduIHdoaWNoIGlzIGluIHByZWZpeCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChwb3NpdGlvbiA9PT0gMCAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IHNldHRpbmdzQ2xvbmUuYU5lZykgfHwgKHBvc2l0aW9uID09PSAxICYmIHZhbHVlLmNoYXJBdCgwKSA9PT0gc2V0dGluZ3NDbG9uZS5hTmVnKSkgJiYgc2V0dGluZ3NDbG9uZS5hU2lnbiAmJiBzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGggKyAodmFsdWUuY2hhckF0KDApID09PSAnLScgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5hU2lnbiAmJiBzZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5hU2lnbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuYVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgY291bGQgbm90IGZpbmQgYSBwbGFjZSBmb3IgY3Vyc29yIGFuZCBoYXZlIGEgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbGFjZSBjYXJldCBiZWZvcmUgc3VmZml4XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiAtPSBzZXR0aW5nc0Nsb25lLmFTdWZmaXgubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBmYWN0b3Jpc2UgdGhlIGBnZXRTdHJpbmcoKWAgYW5kIGBnZXRBcnJheSgpYCBmdW5jdGlvbnMgc2luY2UgdGhleSBzaGFyZSBxdWl0ZSBhIGxvdCBvZiBjb2RlLlxuICAgICAqXG4gICAgICogVGhlIFwiZ2V0U3RyaW5nXCIgbWV0aG9kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYSB0ZXh0IHN0cmluZyBpbiBzdGFuZGFyZCBVUkwtZW5jb2RlZCBub3RhdGlvbi5cbiAgICAgKiBUaGUgXCJnZXRBcnJheVwiIG1ldGhvZCBvbiB0aGUgb3RoZXIgaGFuZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemVBcnJheSgpIG1ldGhvZCB0aGF0IGNyZWF0ZXMgYXJyYXkgb3Igb2JqZWN0cyB0aGF0IGNhbiBiZSBlbmNvZGVkIGFzIGEgSlNPTiBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoYXQpKTtcbiAgICAgICAgY29uc3QgZm9ybUluZGV4ID0gJCgnZm9ybScpLmluZGV4KCR0aGlzKTtcbiAgICAgICAgY29uc3QgYWxsRm9ybUVsZW1lbnRzID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pYClbMF07XG4gICAgICAgIGNvbnN0IGFpSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBhbGwgaW5wdXQgaW5kZXhcbiAgICAgICAgY29uc3Qgc2NJbmRleCA9IFtdO1xuXG4gICAgICAgIC8vIHN1Y2Nlc3NmdWwgY29udHJvbCBpbmRleFxuICAgICAgICBjb25zdCByU3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByU3VibWl0dGFibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7XG5cbiAgICAgICAgLy8gZnJvbSBqUXVlcnkgc2VyaWFsaXplIG1ldGhvZFxuICAgICAgICBjb25zdCByQ2hlY2thYmxlVHlwZSA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pO1xuICAgICAgICBjb25zdCByTm9uQXV0b051bWVyaWNUeXBlcyA9IC9eKD86YnV0dG9ufGNoZWNrYm94fGNvbG9yfGRhdGV8ZGF0ZXRpbWV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8ZmlsZXxpbWFnZXxtb250aHxudW1iZXJ8cGFzc3dvcmR8cmFkaW98cmFuZ2V8cmVzZXR8c2VhcmNofHN1Ym1pdHx0aW1lfHVybHx3ZWVrKS9pO1xuXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICAgICAgLy8gaW5kZXggb2Ygc3VjY2Vzc2Z1bCBlbGVtZW50c1xuICAgICAgICAkLmVhY2goYWxsRm9ybUVsZW1lbnRzLCAoaSwgZmllbGQpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lICE9PSAnJyAmJiByU3VibWl0dGFibGUudGVzdChmaWVsZC5sb2NhbE5hbWUpICYmICFyU3VibWl0dGVyVHlwZXMudGVzdChmaWVsZC50eXBlKSAmJiAhZmllbGQuZGlzYWJsZWQgJiYgKGZpZWxkLmNoZWNrZWQgfHwgIXJDaGVja2FibGVUeXBlLnRlc3QoZmllbGQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY0luZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpbmRleCBvZiBhbGwgaW5wdXRzIHRhZ3MgZXhjZXB0IGNoZWNrYm94XG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIChmaWVsZC50eXBlID09PSAnJyB8fCBmaWVsZC50eXBlID09PSAndGV4dCcgfHwgZmllbGQudHlwZSA9PT0gJ2hpZGRlbicgfHwgZmllbGQudHlwZSA9PT0gJ3RlbCcpKSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKGNvdW50KTtcbiAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhaUluZGV4LnB1c2goLTEpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZC5sb2NhbE5hbWUgPT09ICdpbnB1dCcgJiYgck5vbkF1dG9OdW1lcmljVHlwZXMudGVzdChmaWVsZC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGdldEFycmF5QmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1GaWVsZHMgPSAkdGhpcy5zZXJpYWxpemVBcnJheSgpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybUZpZWxkcywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gJC5pbkFycmF5KGksIHNjSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLnZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXQnLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGZvcm1GaWVsZHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBnZXRTdHJpbmcoKSBiZWhhdmlvclxuICAgICAgICAgICAgY29uc3QgZm9ybUZpZWxkcyA9ICR0aGlzLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgY29uc3QgZm9ybVBhcnRzID0gZm9ybUZpZWxkcy5zcGxpdCgnJicpO1xuXG4gICAgICAgICAgICAkLmVhY2goZm9ybVBhcnRzLCBpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbaW5wdXROYW1lLCBpbnB1dFZhbHVlXSA9IGZvcm1QYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9ICQuaW5BcnJheShpLCBzY0luZGV4KTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSB2YWxpZCBlbGVtZW50XG4gICAgICAgICAgICAgICAgaWYgKHNjRWxlbWVudCA+IC0xICYmIGFpSW5kZXhbc2NFbGVtZW50XSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RJbnB1dCA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KSBpbnB1dDplcSgke2FpSW5kZXhbc2NFbGVtZW50XX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdGVzdElucHV0LmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRJbnB1dFZhbHVlID0gdGVzdElucHV0LmF1dG9OdW1lcmljKCdnZXQnLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVBhcnRzW2ldID0gYCR7aW5wdXROYW1lfT0ke21vZGlmaWVkSW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtUGFydHMuam9pbignJicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kcyBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNcbiAgICAgKi9cbiAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGluaXRpYXRlIGF1dG9OdW1lcmljIGFuZCBhdHRhY2ggdGhlIHNldHRpbmdzIChvcHRpb25zIGNhbiBiZSBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIpXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdpbml0Jyk7ICAgICAgICAgICAgLy8gaW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoKTsgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIGRlZmF1bHRzXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcsIHtvcHRpb25zfSk7IC8vIGluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggb3B0aW9uc1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoe29wdGlvbnN9KTsgICAgICAgICAvLyBpbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9ICQodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBhdHRlbXB0IHRvIGdyYWIgSFRNTDUgZGF0YSwgaWYgdGhleSBkb24ndCBleGlzdCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBzdXBwb3J0ZWQgaW5wdXQgdHlwZVxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MsIGlmIHRoZXkgZG9uJ3QgZXhpc3QgcmV0dXJucyBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgbGV0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkbid0IGdyYWIgc2V0dGluZ3MsIGNyZWF0ZSB0aGVtIGZyb20gZGVmYXVsdHMgYW5kIHBhc3NlZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgJC5mbi5hdXRvTnVtZXJpYy5kZWZhdWx0cywgdGFnRGF0YSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25PZmYgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd1ZhbHVlICAgICAgICA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93SW5wdXQgICAgICA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpcCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdiJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY2FwdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2NpdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnY29uc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpdicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RmbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2R0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZW0nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoMScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2gyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoNCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2g1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaDYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdpbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdrZGInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3B0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAncCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3EnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2FtcGxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9uZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIGRlZmF1bHRzLCB0YWdEYXRhIGFuZCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRGVjID09PSBzZXR0aW5ncy5hU2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBhdXRvTnVtZXJpYyB3aWxsIG5vdCBmdW5jdGlvbiBwcm9wZXJseSB3aGVuIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBhRGVjIFske3NldHRpbmdzLmFEZWN9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwIFske3NldHRpbmdzLmFTZXB9XSBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHNldHRpbmdzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gQm9vbGVhbih2YWx1ZSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGtleSAhPT0gJ2FTY2FsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFTY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NhbGVGYWN0b3IgPSArc2V0dGluZ3MuYVNjYWxlWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NhbGVEZWNpbWFsID0gKHNldHRpbmdzLmFTY2FsZVsxXSkgPyArc2V0dGluZ3MuYVNjYWxlWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlU3VmZml4ID0gKHNldHRpbmdzLmFTY2FsZVsyXSkgPyBzZXR0aW5ncy5hU2NhbGVbMl0gOiAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgb3VyIG5ldyBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBvcmlnaW5hbCBzZXR0aW5ncyBzYXZlZCBmb3IgdXNlIHdoZW4gZURlYyAmIG5TZXAgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gb3JpZ2luYWxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgbGV0IGhvbGRlciA9IGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBub24tc3VwcG9ydGVkIGlucHV0IHR5cGVzXG4gICAgICAgICAgICAgICAgaWYgKCEkaW5wdXQgJiYgJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCB0YWdzXG4gICAgICAgICAgICAgICAgaWYgKCFpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpICYmICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpICE9PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSA8JHskdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKX0+IHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vVE9ETyBSZXBsYWNlIHRoZSB0d28gbmV4dCB0ZXN0cyB3aXRoIGEgYHZhbGlkYXRlT3B0aW9ucygpYCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgZGVjaW1hbCBhbmQgdGhvdXNhbmQgYXJlIGNoYXJhY3RlcnMgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09IHNldHRpbmdzLmFTZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYURlYyBbJHtzZXR0aW5ncy5hRGVjfV0gYW5kIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgYVNlcCBbJHtzZXR0aW5ncy5hU2VwfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3RlcmAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVja3MgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzIFwiZURlY1wiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbm9ybWFsIGRlY2ltYWwgcGxhY2VzIFwibURlY1wiXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVEZWMgPCBzZXR0aW5ncy5tRGVjICYmIHNldHRpbmdzLmVEZWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXMgZURlYyBbJHtzZXR0aW5ncy5lRGVjfV0gaXMgZ3JlYXRlciB0aGFuIHRoZSBtRGVjIFske3NldHRpbmdzLm1EZWN9XSB2YWx1ZWAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyByb3V0aW5lIHRvIGZvcm1hdCBkZWZhdWx0IHZhbHVlIG9uIHBhZ2UgbG9hZFxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydW5PbmNlID09PSBmYWxzZSAmJiBzZXR0aW5ncy5hRm9ybSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoYXQgdGhpcyBpbnB1dCB2YWx1ZSBpcyBhIHZhbGlkIG51bWJlciBhbmQgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRldmVsb3BlciB3YW50cyBpdCBmb3JtYXR0ZWQgb24gaW5pdCAoY2YuIGBzZXR0aW5ncy5hRm9ybWApKS4gTm90ZTsgdGhpcyBpcyB0cnVlIHdoYXRldmVyIHRoZSBkZXZlbG9wZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGhhcyBzZXQgZm9yIGBkYXRhLWFuLWRlZmF1bHRgIGluIHRoZSBodG1sIChhc3AubmV0IHVzZXJzKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgZGV2ZWxvcGVyIGlzIHRyeWluZyB0byBwcmV2ZW50IHBvc3RiYWNrIHByb2JsZW1zLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQnV0IGlmIGBpbnB1dC52YWx1ZWAgaXMgc2V0IHRvIGEgbnVtYmVyLCBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsIHRoZW4gaXQgbWVhbnMgdGhlIGRldiBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGNoYW5nZWQgdGhlIGlucHV0IHZhbHVlLCBhbmQgdGhlbiBpdCBtZWFucyB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSBoaXMgb3duIGRlY2lzaW9uIHRvIGRvIHNvLlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSGVuY2UsIGlmIGBhbkRlZmF1bHRgIGlzIG5vdCBudWxsLCBidXQgYGlucHV0LnZhbHVlYCBpcyBhIG51bWJlciBhbmQgYCR0aGlzLmF0dHIoJ3ZhbHVlJylgIGlzIG5vdCBzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSBzaG91bGQgaWdub3JlIGBhbkRlZmF1bHRgIGFsdG9nZXRoZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hRm9ybSAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBgdmFsdWVgIGlzIHZhbGlkIG9yIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RlZEN1cnJlbnRWYWx1ZSA9IHBhcnNlRmxvYXQoY3VycmVudFZhbHVlLnJlcGxhY2UoJywnLCAnLicpKTsgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odGVzdGVkQ3VycmVudFZhbHVlKSAmJiBJbmZpbml0eSAhPT0gdGVzdGVkQ3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCB0ZXN0ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90LCBpbmZvcm0gdGhlIGRldmVsb3BlciB0aGF0IG5vdGhpbmcgdXNhYmxlIGhhcyBiZWVuIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHtjdXJyZW50VmFsdWV9XSB1c2VkIGluIHRoZSBpbnB1dCBpcyBub3QgYSB2YWxpZCB2YWx1ZSBhdXRvTnVtZXJpYyBjYW4gd29yayB3aXRoLmAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBDaGVja3MgZm9yIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAtIHBhZ2UgcmVsb2FkIGZyb20gYmFjayBidXR0b24sIGFuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gQVNQLm5ldCBmb3JtIHBvc3QgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqICAgICAgVGhlIGZvbGxvd2luZyBIVE1MIGRhdGEgYXR0cmlidXRlIGlzIFJFUVVJUkVEIChkYXRhLWFuLWRlZmF1bHQ9XCJzYW1lIHZhbHVlIGFzIHRoZSB2YWx1ZSBhdHRyaWJ1dGVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiAgICAgIGV4YW1wbGU6IDxhc3A6VGV4dEJveCBydW5hdD1cInNlcnZlclwiIGlkPVwic29tZUlEXCIgdGV4dD1cIjEyMzQuNTZcIiBkYXRhLWFuLWRlZmF1bHQ9XCIxMjM0LjU2XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFJlcGxhY2Ugd2hhdGV2ZXIgbG9jYWxlIGNoYXJhY3RlciBpcyB1c2VkIGJ5IGEgJy4nLCBhbmQgbm90IG9ubHkgdGhlIGNvbW1hICcsJywgYmFzZWQgb24gdGhlIGxvY2FsZSB1c2VkIGJ5IHRoZSB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChzZXR0aW5ncy5hbkRlZmF1bHQgIT09IG51bGwgJiYgc2V0dGluZ3MuYW5EZWZhdWx0LnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09IG51bGwgJiYgY3VycmVudFZhbHVlICE9PSAnJyAmJiBjdXJyZW50VmFsdWUgIT09ICR0aGlzLmF0dHIoJ3ZhbHVlJykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICEkLmlzTnVtZXJpYyhjdXJyZW50VmFsdWUucmVwbGFjZSgnLCcsICcuJykpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCAmJiBzZXR0aW5ncy5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICdnZXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICYmIHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYVN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5CcmFja2V0ICE9PSBudWxsICYmIHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBuZWdhdGl2ZUJyYWNrZXQoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaXAgPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICgoc2V0dGluZ3MucE5lZyA9PT0gJ3MnIHx8IChzZXR0aW5ncy5wU2lnbiA9PT0gJ3MnICYmIHNldHRpbmdzLnBOZWcgIT09ICdwJykpICYmIHNldHRpbmdzLmFOZWcgIT09ICcnICYmIGNvbnRhaW5zKGN1cnJlbnRWYWx1ZSwgJy0nKSk/Jy0nICsgYXV0b1N0cmlwKHRvU3RyaXAsIHNldHRpbmdzKTphdXRvU3RyaXAodG9TdHJpcCwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2V0dGluZ3Mud0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChzZXR0aW5ncy5hU2lnbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3plcm8nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICcwJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFuRGVmYXVsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hbkRlZmF1bHQgPT09ICR0aGlzLnRleHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAkdGhpcy50ZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvL1RPRE8gRXh0cmFjdCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRvIGFub3RoZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBpbnB1dCB0eXBlcyBzdXBwb3J0ZWQgXCJ0ZXh0XCIsIFwiaGlkZGVuXCIsIFwidGVsXCIgYW5kIG5vIHR5cGVcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdmb2N1c2luLmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwgJiYgJHNldHRpbmdzLmFOZWcgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKG5lZ2F0aXZlQnJhY2tldCgkdGhpcy52YWwoKSwgJHNldHRpbmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLm5TZXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5lRGVjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm1EZWMgPSAkc2V0dGluZ3MuZURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoJHNldHRpbmdzLmFTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5tRGVjID0gJHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChyZXN1bHQgPSBhdXRvU3RyaXAoJHRoaXMudmFsKCksICRzZXR0aW5ncykpICE9PSAkc2V0dGluZ3MucmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluVmFsID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGhvbGRlci5pblZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci5pblZhbCwgJHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgJHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbChvbkVtcHR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgJHRoaXMub24oJ2tleWRvd24uYXV0b051bWVyaWMnLCBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogLy8gVGhlIGNvZGUgYmVsb3cgYWxsb3dzIHRoZSBcImVudGVyXCIga2V5ZG93biB0byB0aHJvdyBhIGNoYW5nZSgpIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09PSBrZXlDb2RlLkVudGVyICYmIGhvbGRlci5pblZhbCAhPT0gJHRoaXMudmFsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuaW5WYWwgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5pbml0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5za2lwQWx3YXlzKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnByb2Nlc3NBbHdheXMoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlci5mb3JtYXRRdWljayhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSAkdGhpcy52YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRWYWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhyb3dzIGlucHV0IGV2ZW50IGluIGRlbGV0aW9uIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLm9uKCdrZXlwcmVzcy5hdXRvTnVtZXJpYycsIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBmaXggZm9yIFNoaWZ0ICYmIGluc2VydCBwYXN0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkgJiYgZS5rZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBob2xkZXIucHJvY2Vzc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNraXBBbHdheXMoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5wcm9jZXNzQWx3YXlzKCkgfHwgaG9sZGVyLnByb2Nlc3NLZXlwcmVzcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aHJvd3MgaW5wdXQgZXZlbnQgb24gYWRkaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIubGFzdFZhbCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIuc2V0dGluZ3NDbG9uZS50aHJvd0lucHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigna2V5dXAuYXV0b051bWVyaWMnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmluaXQoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lwID0gaG9sZGVyLnNraXBBbHdheXMoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWIgPSBob2xkZXIua2RDb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmtkQ29kZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLnZhbHVlUGFydHNCZWZvcmVQYXN0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkZWQgdG8gcHJvcGVybHkgcGxhY2UgdGhlIGNhcmV0IHdoZW4gb25seSB0aGUgY3VycmVuY3kgc2lnbiBpcyBwcmVzZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnBTaWduID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbih0aGlzLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTaWduLmxlbmd0aCwgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVNpZ24ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYiA9PT0ga2V5Q29kZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsICR0aGlzLnZhbCgpLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRoaXNbMF0udmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmFTdWZmaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU2lnbiAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuYVN1ZmZpeCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlcyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCB0byBwcmVzZXJ2ZSB0aGUgZGF0YSB3aGVuIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuZURlYyAhPT0gbnVsbCAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5hU3Rvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9TYXZlKCR0aGlzLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFob2xkZXIuZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyLmZvcm1hdFF1aWNrKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbignZm9jdXNvdXQuYXV0b051bWVyaWMnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob2xkZXIgPSBnZXRIb2xkZXIoJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMudmFsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm9uT2ZmID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmFTdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsICRzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy5uU2VwID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLmFTZXAgPSAkc2V0dGluZ3Mub1NlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MuYVNpZ24gPSAkc2V0dGluZ3Mub1NpZ247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmVEZWMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICRzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5hUGFkID0gJHNldHRpbmdzLm9QYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHNldHRpbmdzLm5CcmFja2V0ID0gJHNldHRpbmdzLm9CcmFja2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJy0nICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tFbXB0eSh2YWx1ZSwgJHNldHRpbmdzKSA9PT0gbnVsbCAmJiBtaW5UZXN0ICYmIG1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsICRzZXR0aW5ncy5hRGVjLCAkc2V0dGluZ3MuYU5lZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzZXR0aW5ncy5yYXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLmFTY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSAvICRzZXR0aW5ncy5zY2FsZUZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MubURlYyA9ICgkc2V0dGluZ3MuYVNjYWxlICYmICRzZXR0aW5ncy5hU2NhbGVbMV0pID8gKyRzZXR0aW5ncy5zY2FsZURlY2ltYWwgOiAkc2V0dGluZ3MubURlYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsICRzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJlc2VudE51bWJlcih2YWx1ZSwgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy53RW1wdHkgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYXV0b1JvdW5kKCcwJywgJHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgJHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCAkc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKCRzZXR0aW5ncy5zY2FsZVN1ZmZpeCkgPyBncm91cGVkVmFsdWUgKyAkc2V0dGluZ3Muc2NhbGVTdWZmaXggOiBncm91cGVkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKGdyb3VwZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIuaW5WYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy5jaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaG9sZGVyLmluVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vbigncGFzdGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZJWE1FIEFmdGVyIGEgcGFzdGUsIHRoZSBjYXJldCBpcyBwdXQgb24gdGhlIGZhciByaWdodCBvZiB0aGUgaW5wdXQsIGl0IHNob3VsZCBiZSBzZXQgdG8gc29tZXRoaW5nIGxpa2UgYG5ld0NhcmV0UG9zaXRpb24gPSBvbGRDYXJldFBvc2l0aW9uICsgcGFzdGVUZXh0Lmxlbmd0aDtgLCB3aGlsZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvbGRlciA9IGdldEhvbGRlcigkdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBwcmVwYXJlKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b1N0cmlwKHRleHQsIGhvbGRlci5zZXR0aW5nc0Nsb25lKS5yZXBsYWNlKGhvbGRlci5zZXR0aW5nc0Nsb25lLmFEZWMsICcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVmFsaWQodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0ICE9PSAnJyAmJiAhaXNOYU4odGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZFJhd1ZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy52YWx1ZSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvblN0YXJ0ID0gdGhpcy5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uRW5kID0gdGhpcy5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGN1cnJlbnRWYWx1ZS5zdWJzdHJpbmcoMCwgc2VsZWN0aW9uU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQsIGN1cnJlbnRWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVkVGV4dCA9IHByZXBhcmUoZS5vcmlnaW5hbEV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKHBhc3RlZFRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBwcmVwYXJlKHByZWZpeCArIE51bWJlcihwYXN0ZWRUZXh0KS52YWx1ZU9mKCkgKyBzdWZmaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkKG5ld1ZhbHVlKSAmJiBOdW1iZXIob2xkUmF3VmFsdWUpLnZhbHVlT2YoKSAhPT0gTnVtYmVyKG5ld1ZhbHVlKS52YWx1ZU9mKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignaW5wdXQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnQgPSBzZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9sZGVyID0gZ2V0SG9sZGVyKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCAkc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHNldHRpbmdzLnVuU2V0T25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCRzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlbW92ZSBzZXR0aW5ncyBhbmQgc3RvcCBhdXRvTnVtZXJpYygpIC0gZG9lcyBub3QgcmVtb3ZlIHRoZSBmb3JtYXR0aW5nXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcImRlc3Ryb3lcIik7IC8vIGRlc3Ryb3lzIGF1dG9OdW1lcmljXG4gICAgICAgICAqIG5vIHBhcmFtZXRlcnMgYWNjZXB0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGFuZCBzZXNzaW9uU3RvcmFnZSBvciBjb29raWUgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwid2lwZVwiKTsgLy8gcmVtb3ZlcyBzZXNzaW9uIHN0b3JhZ2UgYW5kIGNvb2tpZXMgZnJvbSBtZW1vcnlcbiAgICAgICAgICogbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKi9cbiAgICAgICAgd2lwZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBhdXRvU2F2ZSgkdGhpcywgc2V0dGluZ3MsICd3aXBlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IHVwZGF0ZXMgdGhlIGF1dG9OdW1lcmljIHNldHRpbmdzXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkXG4gICAgICAgICAqIFRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlciBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc2V0dGluZ3MgKGllLiB7YVNlcDogXCIuXCIsIGFEZWM6IFwiLFwiLCBhU2lnbjogJ+KCrCAnfSlcbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYyhcInVwZGF0ZVwiLCB7b3B0aW9uc30pOyAvLyB1cGRhdGVzIHRoZSBzZXR0aW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJ1cGRhdGVcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZChzZXR0aW5ncywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnNjYWxlRmFjdG9yID0gK3NldHRpbmdzLmFTY2FsZVswXTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NhbGVEZWNpbWFsID0gKHNldHRpbmdzLmFTY2FsZVsxXSkgPyArc2V0dGluZ3MuYVNjYWxlWzFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc2NhbGVTdWZmaXggPSAoc2V0dGluZ3MuYVNjYWxlWzJdKSA/IHNldHRpbmdzLmFTY2FsZVsyXSA6ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXR0aW5ncyA9IG9yaWdpbmFsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGdldEhvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmFEZWMgPT09IHNldHRpbmdzLmFTZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgYXV0b051bWVyaWMgd2lsbCBub3QgZnVuY3Rpb24gcHJvcGVybHkgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYURlYzogXCIke3NldHRpbmdzLmFEZWN9XCIgYW5kIHRob3VzYW5kIHNlcGFyYXRvciBhU2VwOiBcIiR7c2V0dGluZ3MuYVNlcH1cIiBhcmUgdGhlIHNhbWUgY2hhcmFjdGVyYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3NldCcsICd2YWx1ZScpOyAvLyBmb3JtYXRzIHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIGlzIHBhc3NlZCBhcyBhIHN0cmluZywgaXQgY2FuIGJlIGFuIGludGVnZXIgJzEyMzQnIG9yIGEgZG91YmxlICcxMjM0LjU2Nzg5J1xuICAgICAgICAgKiBhbmQgbXVzdCBjb250YWluIG9ubHkgbnVtYmVycyBhbmQgb25lIGRlY2ltYWwgKHBlcmlvZCkgY2hhcmFjdGVyXG4gICAgICAgICAqL1xuICAgICAgICBzZXQodmFsdWVJbikge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVJbiA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZCh2YWx1ZUluKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlSW4udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBJbml0aWFsaXppbmcgYXV0b051bWVyaWMgaXMgcmVxdWlyZWQgcHJpb3IgdG8gY2FsbGluZyB0aGUgXCJzZXRcIiBtZXRob2RgLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgbG9jYWxlIGRlY2ltYWwgc2VwYXJhdG9yIHRvIGJlIGEgY29tbWEgLSBubyB0aG91c2FuZCBzZXBhcmF0b3IgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGJlaW5nIHNldCBpcyBub3QgbnVtZXJpY1xuICAgICAgICAgICAgICAgIGlmICghJC5pc051bWVyaWMoTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHZhbHVlIFwiJHt2YWx1ZX1cIiBiZWluZyBcInNldFwiIGlzIG5vdCBudW1lcmljIGFuZCBoYXMgY2F1c2VkIGEgZXJyb3IgdG8gYmUgdGhyb3duYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0ICYmICghc2V0dGluZ3MuZURlYyB8fCAhc2V0dGluZ3MuYVNjYWxlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gbWF4IHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGlucHV0IHx8IGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuYVNjYWxlICYmICFzZXR0aW5ncy5vbk9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVGYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MubURlYyA9IHNldHRpbmdzLnNjYWxlRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyA9PT0gbnVsbCAmJiBzZXR0aW5ncy5hU2NhbGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvR3JvdXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5hU3RvciAmJiAoc2V0dGluZ3MuZURlYyAhPT0gbnVsbCB8fCBzZXR0aW5ncy5hU2NhbGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1NhdmUoJHRoaXMsIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMudHJpZ2dlcignYXV0b051bWVyaWM6bWF4RXhjZWVkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHthdHRlbXB0ZWRWYWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3MgZm9yIHRoaXMgZWxlbWVudGAsIHNldHRpbmdzLmRlYnVnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vbk9mZiAmJiBzZXR0aW5ncy5zY2FsZVN1ZmZpeCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlICsgc2V0dGluZ3Muc2NhbGVTdWZmaXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYmVmb3JlIGZvcm0gc3VibWlzc2lvblxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ3VuU2V0Jyk7IC8vIG5vIHBhcmFtZXRlciBhY2NlcHRlZFxuICAgICAgICAgKiBieSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogbG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gYXV0b0dldCgkKHRoaXMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogbWV0aG9kIHRvIHJlLWZvcm1hdCBpbnB1dHMgLSBoYW5keSB0byB1c2UgcmlnaHQgYWZ0ZXIgZm9ybSBzdWJtaXNzaW9uXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygncmVTZXQnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiB0aGlzIGlzIGNhbGxlZCBhZnRlciB0aGUgJ3VuU2V0JyBtZXRob2QgdG8gcmVmb3JtYXQgdGhlIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBhdXRvR2V0KCQodGhpcykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudmFsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBtZXRob2QgdG8gZ2V0IHRoZSB1bmZvcm1hdHRlZCB0aGF0IGFjY2VwdHMgdXAgdG8gb25lIHBhcmFtZXRlclxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldCcpOyBubyBwYXJhbWV0ZXIgc3VwcG9ydGVkXG4gICAgICAgICAqIGJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBsb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcImxvY2FsZU91dHB1dFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwiZ2V0XCIgbWV0aG9kYCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZWxlbWVudCB0eXBlIHRoZW4gdXNlIC5lcSgwKSBzZWxlY3RvciB0byBncmFiIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBzZWxlY3RvclxuICAgICAgICAgICAgaWYgKCRpbnB1dCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHRoaXMuZXEoMCkudmFsKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnRleHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIFwiPCR7JHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCl9PlwiIHRhZyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCwgc2V0dGluZ3MuZGVidWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZURlYyB8fCBzZXR0aW5ncy5hU2NhbGUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoISgoL1xcZC8pLnRlc3QodmFsdWUpIHx8IE51bWJlcih2YWx1ZSkgPT09IDApICYmIHNldHRpbmdzLndFbXB0eSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgJiYgc2V0dGluZ3MubkJyYWNrZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25PZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5lZ2F0aXZlQnJhY2tldCh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucnVuT25jZSB8fCBzZXR0aW5ncy5hRm9ybSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBhdXRvU3RyaXAodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBmaXhOdW1iZXIodmFsdWUsIHNldHRpbmdzLmFEZWMsIHNldHRpbmdzLmFOZWcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3MubG9jYWxlT3V0cHV0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgTnVtZXJpYyBTdHJpbmdcbiAgICAgICAgICAgIC8vVE9ETyBTaG91bGRuJ3Qgd2UgcmV0dXJuIGBOdW1iZXIodmFsdWUpYCBzaW5jZSB0aGUgZ29hbCBvZiBgZ2V0YCBpcyB0byBnZXQgdGhlIHJhdyBqYXZhc2NyaXB0IHZhbHVlP1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgZm9ybWF0dGVkIHZhbHVlIG9mIHRoZSBhdXRvTnVtZXJpYyBlbGVtZW50LlxuICAgICAgICAgKiBAdXNhZ2UgYU5JbnB1dC5hdXRvTnVtZXJpYygnZ2V0Rm9ybWF0dGVkJykpXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGb3JtYXR0ZWQoKSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgYHRoaXNbMF1gIGV4aXN0cyBhcyB3ZWxsIGFzIGAudmFsdWVgIGJlZm9yZSB0cnlpbmcgdG8gYWNjZXNzIHRoYXQgcHJvcGVydHlcbiAgICAgICAgICAgIGlmICghaXNBcnJheSh0aGlzKSB8fCB0aGlzLmxlbmd0aCAhPT0gMSB8fCAhdGhpc1swXS5oYXNPd25Qcm9wZXJ0eSgndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoJ1VuYWJsZSB0byBnZXQgdGhlIGZvcm1hdHRlZCBzdHJpbmcgZnJvbSB0aGUgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMF0udmFsdWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldFN0cmluZ1wiIG1ldGhvZCB1c2VzIGpRdWVyeSdzIC5zZXJpYWxpemUoKSBtZXRob2QgdGhhdCBjcmVhdGVzIGEgdGV4dCBzdHJpbmcgaW4gc3RhbmRhcmQgVVJMLWVuY29kZWQgbm90YXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgICAgICogQnkgZGVmYXVsdHMgdmFsdWVzIHJldHVybmVkIGFzIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kXG4gICAgICAgICAqIExvY2FsZSBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQgXCIxMjM0LjU2LVwiIG9yIFwiMTIzNCw1NlwiIG9yIFwiLTEyMzQsNTYgb3IgXCIxMjM0LDU2LVwiID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwibG9jYWxlT3V0cHV0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgPT4gcGxlYXNlIHNlZSBvcHRpb24gXCJsb2NhbGVPdXRwdXRcIiBmb3IgZGV0YWlsc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2dldFN0cmluZ09yQXJyYXkodHJ1ZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSAnZ2V0U2V0dGluZ3MnIGZ1bmN0aW9uIHJldHVybnMgdGhlIG9iamVjdCB3aXRoIGF1dG9OdW1lcmljIHNldHRpbmdzIGZvciB0aG9zZSB3aG8gbmVlZCB0byBsb29rIHVuZGVyIHRoZSBob29kXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0U2V0dGluZ3MnKTsgLy8gbm8gcGFyYW1ldGVycyBhY2NlcHRlZFxuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuYURlYzsgLy8gcmV0dXJuIHRoZSBhRGVjIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnQgdmFsaWQgc2V0dGluZyBjYW4gYmUgdXNlZFxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGF1dG9HZXQoJCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiAkdGhpcy5lcSgwKS5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICB9LFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhdXRvTnVtZXJpYyBmdW5jdGlvblxuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMgPSBmdW5jdGlvbihtZXRob2QsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyB8fCAhbWV0aG9kKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3B0aW9ucyBoYXZlIGJlZW4gcGFzc2VkIGRpcmVjdGx5LCB3aXRob3V0IHVzaW5nIGEgbmFtZWQgbWV0aG9kXG4gICAgICAgICAgICAvL1RPRE8gRmlyc3QgdmFsaWRhdGUgdGhlIG9wdGlvbnMgcGFzc2VkIGFzIGFuIGFyZ3VtZW50LCBiZWZvcmUgdXNpbmcgYGluaXRgXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kcy5pbml0LmFwcGx5KHRoaXMsIFttZXRob2RdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93RXJyb3IoYE1ldGhvZCBcIiR7bWV0aG9kfVwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYXV0b051bWVyaWNgLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgYXJlIHB1YmxpYyAtIHRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBmb2xsb3dpbmc6XG4gICAgICogSFRNTDUgZGF0YSBhdHRyaWJ1dGVzXG4gICAgICogT3B0aW9ucyBwYXNzZWQgYnkgdGhlICdpbml0JyBvciAndXBkYXRlJyBtZXRob2RzXG4gICAgICogVXNlIGpRdWVyeSdzIGAkLmV4dGVuZGAgbWV0aG9kIGZvciBnbG9iYWwgY2hhbmdlcyAtIGFsc28gYSBncmVhdCB3YXkgdG8gcGFzcyBBU1AuTkVUIGN1cnJlbnQgY3VsdHVyZSBzZXR0aW5nc1xuICAgICAqL1xuICAgICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qIGFsbG93ZWQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnNcbiAgICAgICAgICogY29tbWEgPSBcIixcIlxuICAgICAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICAgICAqIGFwb3N0cm9waGUgaXMgZXNjYXBlZCA9IFwiXFxcIlwiXG4gICAgICAgICAqIHNwYWNlID0gXCIgXCJcbiAgICAgICAgICogbm9uZSA9IFwiXCJcbiAgICAgICAgICogTk9URTogZG8gbm90IHVzZSBudW1lcmljIGNoYXJhY3RlcnNcbiAgICAgICAgICovXG4gICAgICAgIGFTZXA6ICcsJyxcblxuICAgICAgICAvKiB3aGVuIHRydWUgPT4gd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzIG9ubHkgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIHZpc2libGVcbiAgICAgICAgICovXG4gICAgICAgIG5TZXA6IGZhbHNlLFxuXG4gICAgICAgIC8qIGRpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcbiAgICAgICAgICogZEdyb3VwOiBcIjJcIiwgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xuICAgICAgICAgKiBkR3JvdXA6IFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXG4gICAgICAgICAqIGRHcm91cDogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxuICAgICAgICAgKiBkR3JvdXA6IFwiNFwiLCByZXN1bHRzIGluIDk5OTksOTk5OSw5OTk5IHVzZWQgaW4gc29tZSBBc2lhbiBjb3VudHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGRHcm91cDogJzMnLFxuXG4gICAgICAgIC8qIGFsbG93ZWQgZGVjaW1hbCBzZXBhcmF0b3IgY2hhcmFjdGVyc1xuICAgICAgICAgKiBwZXJpb2QgXCJmdWxsIHN0b3BcIiA9IFwiLlwiXG4gICAgICAgICAqIGNvbW1hID0gXCIsXCJcbiAgICAgICAgICovXG4gICAgICAgIGFEZWM6ICcuJyxcblxuICAgICAgICAvKiBhbGxvdyB0byBkZWNsYXJlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIHdoaWNoIGlzIGF1dG9tYXRpY2FsbHkgcmVwbGFjZWQgYnkgYURlY1xuICAgICAgICAgKiBkZXZlbG9wZWQgZm9yIGNvdW50cmllcyB0aGUgdXNlIGEgY29tbWEgXCIsXCIgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAqIGFuZCBoYXZlIGtleWJvYXJkc1xcbnVtZXJpYyBwYWRzIHRoYXQgaGF2ZSBhIHBlcmlvZCAnZnVsbCBzdG9wJyBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXJzIChTcGFpbiBpcyBhbiBleGFtcGxlKVxuICAgICAgICAgKi9cbiAgICAgICAgYWx0RGVjOiBudWxsLFxuXG4gICAgICAgIC8qIGFTaWduID0gYWxsb3dlZCBjdXJyZW5jeSBzeW1ib2xcbiAgICAgICAgICogTXVzdCBiZSBpbiBxdW90ZXMgYVNpZ246IFwiJFwiXG4gICAgICAgICAqIHNwYWNlIHRvIHRoZSByaWdodCBvZiB0aGUgY3VycmVuY3kgc3ltYm9sIGFTaWduOiAnJCAnXG4gICAgICAgICAqIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgYVNpZ246ICcgJCdcbiAgICAgICAgICovXG4gICAgICAgIGFTaWduOiAnJyxcblxuICAgICAgICAvKiBwU2lnbiA9IHBsYWNlbWVudCBvZiBjdXJyZW5jeSBzaWduIGFzIGEgcD1wcmVmaXggb3Igcz1zdWZmaXhcbiAgICAgICAgICogZm9yIHByZWZpeCBwU2lnbjogXCJwXCIgKGRlZmF1bHQpXG4gICAgICAgICAqIGZvciBzdWZmaXggcFNpZ246IFwic1wiXG4gICAgICAgICAqL1xuICAgICAgICBwU2lnbjogJ3AnLFxuXG4gICAgICAgIC8qIHBsYWNlbWVudCBvZiBuZWdhdGl2ZSBzaWduIHJlbGF0aXZlIHRvIHRoZSBhU2lnbiBvcHRpb24gbD1sZWZ0LCByPXJpZ2h0LCBwPXByZWZpeCAmIHM9c3VmZml4XG4gICAgICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXG4gICAgICAgICAqIC0kMSwyMzQuNTYgPT4ge2FTaWduOiBcIiRcIn1cbiAgICAgICAgICogJC0xLDIzNC41NiA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInJcIn1cbiAgICAgICAgICogLTEsMjM0LjU2JCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCIsIHBOZWc6IFwicFwifVxuICAgICAgICAgKiAxLDIzNC41Ni0gID0+IHtwTmVnOiBcInNcIn1cbiAgICAgICAgICogJDEsMjM0LjU2LSA9PiB7YVNpZ246IFwiJFwiLCBwTmVnOiBcInNcIn1cbiAgICAgICAgICogMSwyMzQuNTYtJCA9PiB7YVNpZ246IFwiJFwiLCBwU2lnbjogXCJzXCJ9XG4gICAgICAgICAqIDEsMjM0LjU2JC0gPT4ge2FTaWduOiBcIiRcIiwgcFNpZ246IFwic1wiLCBwTmVnOiBcInJcIn1cbiAgICAgICAgICovXG4gICAgICAgIHBOZWc6ICdsJyxcblxuICAgICAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBhU3VmZml4OiAnZ3Jvc3MnLCBhIHNwYWNlIGlzIGFsbG93ZWQgYVN1ZmZpeDogJyBkb2xsYXJzJ1xuICAgICAgICAgKiBOdW1lcmljIGNoYXJhY3RlcnMgYW5kIG5lZ2F0aXZlIHNpZ24gbm90IGFsbG93ZWQnXG4gICAgICAgICAqL1xuICAgICAgICBhU3VmZml4OiAnJyxcblxuICAgICAgICAvKiBvdmVycmlkZSBtaW4gbWF4IGxpbWl0cydcbiAgICAgICAgICogb0xpbWl0czogXCJjZWlsaW5nXCIgYWRoZXJlcyB0byB2TWF4IGFuZCBpZ25vcmVzIHZNaW4gc2V0dGluZ3NcbiAgICAgICAgICogb0xpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gdk1pbiBhbmQgaWdub3JlcyB2TWF4IHNldHRpbmdzXG4gICAgICAgICAqIG9MaW1pdHM6IFwiaWdub3JlXCIgaWdub3JlcyBib3RoIHZNaW4gJiB2TWF4XG4gICAgICAgICAqL1xuICAgICAgICBvTGltaXRzOiBudWxsLFxuXG4gICAgICAgIC8qIG1heGltdW0gcG9zc2libGUgdmFsdWVcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIHZNaW5cbiAgICAgICAgICovXG4gICAgICAgIHZNYXg6ICc5OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gdk1heFxuICAgICAgICAgKi9cbiAgICAgICAgdk1pbjogJy05OTk5OTk5OTk5OTk5Ljk5JyxcblxuICAgICAgICAvKiBNYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyA9IHVzZWQgdG8gb3ZlcnJpZGUgZGVjaW1hbCBwbGFjZXMgc2V0IGJ5IHRoZSB2TWluICYgdk1heCB2YWx1ZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIixcbiAgICAgICAgICovXG4gICAgICAgIG1EZWM6IG51bGwsXG5cbiAgICAgICAgLyogRXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgdmlzaWJsZSB3aGVuIGlucHV0IGhhcyBmb2N1cyAtIGV4YW1wbGU6XG4gICAgICAgICAqIHtlRGVjOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgICAgICogdGhlIFwiZ2V0XCIgbWV0aG9kIHJldHVybnMgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzXG4gICAgICAgICAqL1xuICAgICAgICBlRGVjOiBudWxsLFxuXG4gICAgICAgIC8qIFNjYWxlZCBudW1iZXIgZGlzcGxheWVkIHdoZW4gaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1cyBleGFtcGxlIHdpdGggdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICoge2FTY2FsZTogW1wiMTAwMFwiLCBcIjBcIiwgXCJLXCJdfSAgPT4gd2l0aCBmb2N1cyBcIjEsMDAwLjAwXCIgd2l0aG91dCBmb2N1cyBcIjFLXCJcbiAgICAgICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICAgICAqIGRpdmlzb3IgdmFsdWUgLSBkb2VzIG5vdCBuZWVkIHRvIGJlIHdob2xlIG51bWJlciAtIHBsZWFzZSB1bmRlcnN0YW5kIHRoYXQgSmF2YXNjcmlwdCBoYXMgbGltaXRlZCBhY2N1cmFjeSBpbiBtYXRoXG4gICAgICAgICAqIHRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlIGFuZCBzY2FsZWQgdmFsdWUuXG4gICAgICAgICAqIGRlY2ltYWwgcGxhY2VzIFwib3B0aW9uYWxcIiB3aGVuIG5vdCBpbiBmb2N1cyAtIGlmIG9taXR0ZWQgdGhlIGRlY2ltYWwgcGxhY2VzIHdpbGwgYmUgdGhlIHNhbWUgd2hlbiB0aGUgaW5wdXQgaGFzIGZvY3VzXG4gICAgICAgICAqIFN5bWJvbCBcIm9wdGlvbmFsXCIgZGlzcGxheWVkIHdoZW4gdGhlIGlucHV0IGRvZXMgbm90IGhhdmUgZm9jdXMgLSBOT1RFOiBpZiBhIHN5bWJvbCBpcyB1c2VkIHlvdSBNVVNUIGFsc28gc3BlY2lmeSB0aGUgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgZXhhbXBsZSBtRGVjOiBcIjNcIlxuICAgICAgICAgKi9cbiAgICAgICAgYVNjYWxlOiBudWxsLFxuXG4gICAgICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBlRGVjIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgICAgICogaWYgaWUgNiBvciA3IHRoZSB2YWx1ZSB3aWxsIGJlIHNhdmVkIGFzIGEgc2Vzc2lvbiBjb29raWVcbiAgICAgICAgICovXG4gICAgICAgIGFTdG9yOiBmYWxzZSxcblxuICAgICAgICAvKiBtZXRob2QgdXNlZCBmb3Igcm91bmRpbmdcbiAgICAgICAgICogbVJvdW5kOiBcInNcIiwgUm91bmQtSGFsZi1VcCBTeW1tZXRyaWMgKGRlZmF1bHQpXG4gICAgICAgICAqIG1Sb3VuZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAgICAgKiBtUm91bmQ6IFwic1wiLCBSb3VuZC1IYWxmLURvd24gU3ltbWV0cmljIChsb3dlciBjYXNlIHMpXG4gICAgICAgICAqIG1Sb3VuZDogXCJBXCIsIFJvdW5kLUhhbGYtRG93biBBc3ltbWV0cmljIChsb3dlciBjYXNlIGEpXG4gICAgICAgICAqIG1Sb3VuZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAgICAgKiBtUm91bmQ6IFwiVVwiLCBSb3VuZCBVcCBcIlJvdW5kLUF3YXktRnJvbS1aZXJvXCJcbiAgICAgICAgICogbVJvdW5kOiBcIkRcIiwgUm91bmQgRG93biBcIlJvdW5kLVRvd2FyZC1aZXJvXCIgLSBzYW1lIGFzIHRydW5jYXRlXG4gICAgICAgICAqIG1Sb3VuZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAgICAgKiBtUm91bmQ6IFwiRlwiLCBSb3VuZCB0byBGbG9vciBcIlRvd2FyZCBOZWdhdGl2ZSBJbmZpbml0eVwiXG4gICAgICAgICAqIG1Sb3VuZDogXCJOMDVcIiBSb3VuZHMgdG8gdGhlIG5lYXJlc3QgLjA1ID0+IHNhbWUgYXMgXCJDSEZcIiB1c2VkIGluIDEuOVggYW5kIHN0aWxsIHZhbGlkXG4gICAgICAgICAqIG1Sb3VuZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgICAgICogbVJvdW5kOiBcIkQwNVwiIFJvdW5kcyBkb3duIHRvIG5leHQgLjA1XG4gICAgICAgICAqL1xuICAgICAgICBtUm91bmQ6ICdzJyxcblxuICAgICAgICAvKiBjb250cm9scyBkZWNpbWFsIHBhZGRpbmdcbiAgICAgICAgICogYVBhZDogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAgICAgKiBhUGFkOiBmYWxzZSAtIGRvZXMgbm90IHBhZCB3aXRoIHplcm9zLlxuICAgICAgICAgKiBhUGFkOiBgc29tZSBudW1iZXJgIC0gcGFkIGRlY2ltYWxzIHdpdGggemVybyB0byBudW1iZXIgZGlmZmVyZW50IGZyb20gbURlY1xuICAgICAgICAgKiB0aGFua3MgdG8gSm9uYXMgSm9oYW5zc29uIGZvciB0aGUgc3VnZ2VzdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgYVBhZDogdHJ1ZSxcblxuICAgICAgICAvKiBwbGFjZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWUgLSQgOTk5Ljk5IHRvICg5OTkuOTkpXG4gICAgICAgICAqIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIGZvY3VzIHRoZSBsZWZ0IGFuZCByaWdodCBzeW1ib2xzIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHNlcGFyYXRlZCBieSBhIGNvbW1hXG4gICAgICAgICAqIG5CcmFja2V0OiBudWxsIC0gKGRlZmF1bHQpXG4gICAgICAgICAqIG5CcmFja2V0OiAnKCwpJywgbkJyYWNrZXQ6ICdbLF0nLCBuQnJhY2tldDogJzwsPicgb3IgbkJyYWNrZXQ6ICd7LH0nXG4gICAgICAgICAqL1xuICAgICAgICBuQnJhY2tldDogbnVsbCxcblxuICAgICAgICAvKiBEaXNwbGF5ZWQgb24gZW1wdHkgc3RyaW5nIFwiXCJcbiAgICAgICAgICogd0VtcHR5OiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xuICAgICAgICAgKiB3RW1wdHk6IFwicHJlc3NcIiAtIGN1cnJlbmN5IHNpZ24gZGlzcGxheXMgb24gYW55IGtleSBiZWluZyBwcmVzc2VkXG4gICAgICAgICAqIHdFbXB0eTogXCJhbHdheXNcIiAtIGFsd2F5cyBkaXNwbGF5cyB0aGUgY3VycmVuY3kgc2lnbiBvbmx5XG4gICAgICAgICAqIHdFbXB0eTogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRoIGEgY3VycmVuY3kgc2lnblxuICAgICAgICAgKi9cbiAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gdG8gZGlzcGxheSB0aGUgY3VycmVuY3kgc2lnbiBvbmx5IG9uIGhvdmVyIChpZiB0aGUgaW5wdXQgaXMgZW1wdHkpXG4gICAgICAgIHdFbXB0eTogJ2ZvY3VzJyxcblxuICAgICAgICAvKiBjb250cm9scyBsZWFkaW5nIHplcm8gYmVoYXZpb3JcbiAgICAgICAgICogbFplcm86IFwiYWxsb3dcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBaZXJvcyB3aWxsIGJlIHRydW5jYXRlZCB3aGVuIGVudGVyaW5nIGFkZGl0aW9uYWwgZGlnaXRzLiBPbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIGRlbGV0ZWQuXG4gICAgICAgICAqIGxaZXJvOiBcImRlbnlcIiwgLSBhbGxvd3Mgb25seSBvbmUgbGVhZGluZyB6ZXJvIG9uIHZhbHVlcyBsZXNzIHRoYW4gb25lXG4gICAgICAgICAqIGxaZXJvOiBcImtlZXBcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBvbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIHJldGFpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgbFplcm86ICdhbGxvdycsXG5cbiAgICAgICAgLyogZGV0ZXJtaW5lIGlmIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgZm9ybWF0dGVkIG9uIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgKiB0cnVlID0gYXV0b21hdGljYWxseSBmb3JtYXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBhRm9ybTogdHJ1ZSxcblxuICAgICAgICAvKiBkZXRlcm1pbmUgaWYgdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgY29tbWFuZCB3aWxsIHNlbGVjdFxuICAgICAgICAgKiB0aGUgY29tcGxldGUgaW5wdXQgdGV4dCBvciBvbmx5IHRoZSBpbnB1dCBudW1lcmljIHZhbHVlXG4gICAgICAgICAqIGlmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24gb25seSB0aGUgbnVtZXJpYyB2YWx1ZSB3aWxsIHNlbGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICBzTnVtYmVyOiBmYWxzZSxcblxuICAgICAgICAvKiBoZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICAgICAqIHNob3VsZCBiZSB0aGUgdmFsdWUgb2YgdGhlIHVuZm9ybWF0dGVkIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgICogZXhhbXBsZXM6XG4gICAgICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7YW5EZWZhdWx0OiBcIlwifVxuICAgICAgICAgKiB2YWx1ZT0xMjM0LjU2IHthbkRlZmF1bHQ6ICcxMjM0LjU2J31cbiAgICAgICAgICovXG4gICAgICAgIGFuRGVmYXVsdDogbnVsbCxcblxuICAgICAgICAvKiByZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICAgICAqIHRoaXMgb3V0cHV0IGZvcm1hdDogcG9zaXRpdmUgbm5ubi5ubiwgbmVnYXRpdmUgLW5ubm4ubm5cbiAgICAgICAgICogcmV2aWV3IHRoZSAndW5TZXQnIG1ldGhvZCBmb3Igb3RoZXIgZm9ybWF0c1xuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXRPblN1Ym1pdDogZmFsc2UsXG5cbiAgICAgICAgLyogYWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcbiAgICAgICAgICogbnVsbCA9PiBubm5uLm5uIG9yIC1ubm5uLm5uIGRlZmF1bHRcbiAgICAgICAgICogXCIsXCIgID0+IG5ubm4sbm4gb3IgLW5ubm4sbm4gY2FuIGFscyBiZSBcIi0sXCJcbiAgICAgICAgICogXCIuLVwiID0+IG5ubm4ubm4gb3Igbm5ubi5ubi1cbiAgICAgICAgICogXCIsLVwiID0+IG5ubm4sbm4gb3Igbm5ubixubi1cbiAgICAgICAgICovXG4gICAgICAgIGxvY2FsZU91dHB1dDogbnVsbCxcblxuICAgICAgICAvKiBlcnJvciBoYW5kbGluZyBmdW5jdGlvblxuICAgICAgICAgKiB0cnVlID0+IGFsbCBlcnJvcnMgYXJlIHRocm93biAtIGhlbHBmdWwgaW4gc2l0ZSBkZXZlbG9wbWVudFxuICAgICAgICAgKiBmYWxzZSA9PiB0aHJvd3MgZXJyb3JzIHdoZW4gY2FsbGluZyBtZXRob2RzIHByaW9yIHRvIHRoZSBzdXBwb3J0ZWQgZWxlbWVudCBoYXMgYmVlbiBpbml0aWFsaXplZCBiZSBhdXRvTnVtZXJpY1xuICAgICAgICAgKi9cbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG5cbiAgICBnZXREZWZhdWx0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBwdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlclxuICAgICAqL1xuICAgIGF1dG9Gb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhbHVlID0gZnJvbUxvY2FsZSh2YWx1ZSk7XG4gICAgICAgIGlmIChOdW1iZXIodmFsdWUpIDwgMCkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubURlYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgdk1heCA9IHNldHRpbmdzLnZNYXgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgY29uc3Qgdk1pbiA9ICghc2V0dGluZ3Mudk1pbiAmJiBzZXR0aW5ncy52TWluICE9PSAwKSA/IFtdIDogc2V0dGluZ3Mudk1pbi50b1N0cmluZygpLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBzZXR0aW5ncy5tRGVjID0gZGVjTGVuZ3RoKHZNaW4sIHZNYXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGF1dG9DaGVjayh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICBzZW5kQ3VzdG9tRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBgUmFuZ2UgdGVzdCBmYWlsZWRgKTtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB2YWx1ZSBbJHt2YWx1ZX1dIGJlaW5nIHNldCBmYWxscyBvdXRzaWRlIHRoZSB2TWluIFske3NldHRpbmdzLnZNaW59XSBhbmQgdk1heCBbJHtzZXR0aW5ncy52TWF4fV0gc2V0dGluZ3NgLCBzZXR0aW5ncy5kZWJ1Zyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBhdXRvUm91bmQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgdmFsdWUgPSBwcmVzZW50TnVtYmVyKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIHZhbHVlID0gYXV0b0dyb3VwKHZhbHVlLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9Gb3JtYXQgPSBhdXRvRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogcHVibGljIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHVuZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhdXRvVW5Gb3JtYXQgPSBmdW5jdGlvbih2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sICQuZm4uYXV0b051bWVyaWMuZGVmYXVsdHMsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBhbGxvd2VkID0gYC0wMTIzNDU2Nzg5XFxcXCR7c2V0dGluZ3MuYURlY31gO1xuICAgICAgICBjb25zdCBhdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGBbXiR7YWxsb3dlZH1dYCwgJ2dpJyk7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHZhbHVlLmNoYXJBdCgwKSA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5hTmVnID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5CcmFja2V0ICYmIHNldHRpbmdzLm5CcmFja2V0LnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuYU5lZyA9ICctJztcbiAgICAgICAgICAgIHNldHRpbmdzLm9uT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gbmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKGF1dG9TdHJpcCwgJycpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBpZiAoc2V0dGluZ3MubG9jYWxlT3V0cHV0KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRvTG9jYWxlKHZhbHVlLCBzZXR0aW5ncy5sb2NhbGVPdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1VuZm9ybWF0ID0gYXV0b1VuRm9ybWF0O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY3VzdG9tIGV2ZW50LlxuICAgICAqIGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIGRldGFpbFxuICAgICAqIEByZXR1cm5zIHtDdXN0b21FdmVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkge1xuICAgICAgICAvKiBsZXQgZXZlbnRJbmZvID0gbmV3IEN1c3RvbUV2ZW50SW5pdCgpOyAvL1RoaXMgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZCwgYnV0IElFIGRvZXMgbm90IHN1cHBvcnQgJ0N1c3RvbUV2ZW50SW5pdCcgeWV0XG4gICAgICAgIGV2ZW50SW5mby5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBldmVudEluZm8pOyAqL1xuICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgeyBkZXRhaWwsIGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSB9KTsgLy8gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGRlZmF1bHQgYnkgSUUgOyBXZSB1c2UgdGhlIHBvbHlmaWxsIGZvciBJRTkgYW5kIGxhdGVyLlxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgYnJvYWRjYXN0IGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0gZGV0YWlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2VuZEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGV0YWlsID0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChjcmVhdGVDdXN0b21FdmVudChldmVudE5hbWUsIGRldGFpbCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50L0N1c3RvbUV2ZW50IGZvciBvYnNvbGV0ZSBicm93c2VycyAoSUUpXG4gICAgICovXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHsgYnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBkZXRhaWw6IHZvaWQoMCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldmVudCwgcGFyYW1zLmJ1YmJsZXMsIHBhcmFtcy5jYW5jZWxhYmxlLCBwYXJhbXMuZGV0YWlsKTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cblxuICAgICAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9KSgpO1xufSkpO1xuXG4vKipcbiAqIFRoaXMgZXhwb3J0cyB0aGUgaW50ZXJmYWNlIGZvciB0aGUgYXV0b051bWVyaWMgb2JqZWN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBmb3JtYXQgIDogYXV0b0Zvcm1hdCxcbiAgICB1bkZvcm1hdDogYXV0b1VuRm9ybWF0LFxuICAgIGdldERlZmF1bHRDb25maWcsXG5cbiAgICAvL1RPRE8gQ29tcGxldGUgdGhlIGludGVyZmFjZSB3aXRoIGZ1bmN0aW9ucyBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzIDpcbiAgICAvL2luaXQgICAgICAgICA6IGFuLmluaXQob3B0aW9ucywgaW5wdXQpXG4gICAgLy9nZXQgICAgICAgICAgOiBhbi5nZXQoaW5wdXQpXG4gICAgLy9zZXQgICAgICAgICAgOiBhbi5zZXQodmFsdWUsIGlucHV0KVxuICAgIC8vZm9ybVN0cmluZyAgIDogYW4uZm9ybVN0cmluZyhmb3JtKVxuICAgIC8vZm9ybUFycmF5ICAgIDogYW4uZm9ybUFycmF5KGZvcm0pXG4gICAgLy9nZXRGb3JtYXR0ZWQgOiBhbi5nZXRGb3JtYXR0ZWQoaW5wdXQpXG4gICAgLy91bnNldCAgICAgICAgOiBhbi51bnNldChpbnB1dCkgLy90byByZW5hbWUgdG8gJ3VuZm9ybWF0Jz8gKGFuZCBtZXJnZSB3aXRoIGF1dG9VbkZvcm1hdC91bkZvcm1hdD8pXG4gICAgLy9yZWZvcm1hdCAgICAgOiBhbi5yZWZvcm1hdChpbnB1dCkgLy8gJ3JlU2V0JyBpcyB2ZXJ5IHRvIGNsb3NlIHRvICdyZXNldCcgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgcmVuYW1lZC4gV2UgY291bGQgc3RpbGwgZXhwb3NlICdyZVNldCcsIGJ1dCBhZGQgYSBAZGVwcmVjYXRlZCB0YWcgb24gaXRzIGRlY2xhcmF0aW9uLlxuICAgIC8vc2V0dGluZ3MgICAgIDogYW4uc2V0dGluZ3MoaW5wdXQpXG4gICAgLy91cGRhdGUgICAgICAgOiBhbi51cGRhdGUob3B0aW9ucywgaW5wdXQpXG4gICAgLy93aXBlICAgICAgICAgOiBhbi53aXBlKGlucHV0KVxuICAgIC8vZGVzdHJveSAgICAgIDogYW4uZGVzdHJveShpbnB1dClcbiAgICAvL3ZhbGlkYXRlICAgICA6IGFuLnZhbGlkYXRlKG9wdGlvbnMpXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2F1dG9OdW1lcmljLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ])
});
;